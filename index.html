<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>小叶子聊天室</title>
    <style>
      /* --- 全局平滑过渡效果 --- */
body, #chat-container, #chat-header, #bottom-panel, .settings-content, 
.feature-modal-content, .action-item-icon, .chat-item, .modal-overlay,
.form-group input, .form-group textarea, .form-group select {
    transition: background-color 0.4s ease, color 0.4s ease, border-color 0.4s ease;
}

/* --- 夜间模式核心样式 --- */
body.dark-mode {
    --bg-color: #121212;
    --chat-bg-color: rgba(30, 30, 30, 0.85);
    --header-bg-color: rgba(45, 45, 45, 0.9);
    --input-bg-color: #252525;
    --text-color: #E0E0E0;
    --text-light-color: #9E9E9E;
    --accent-color: #ff8fab;
    --accent-dark-color: #f87197;
    --border-color: #424242;
}

/* --- 针对特定组件的夜间模式微调 --- */
body.dark-mode #chat-container {
    box-shadow: 0 0 30px rgba(255, 143, 171, 0.1);
}
body.dark-mode .settings-content,
body.dark-mode .feature-modal-content {
    background: #2D2D30;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
body.dark-mode .form-group label {
    color: #BDBDBD;
}
body.dark-mode .form-group input,
body.dark-mode .form-group select,
body.dark-mode .form-group textarea {
    background-color: #1E1E1E;
    border-color: #555;
    color: #E0E0E0;
}
body.dark-mode .form-group input:focus,
body.dark-mode .form-group select:focus,
body.dark-mode .form-group textarea:focus {
    border-color: var(--accent-color);
    box-shadow: 0 0 5px var(--accent-color);
}
body.dark-mode .close-btn,
body.dark-mode .feature-modal-close {
    color: #757575;
}
body.dark-mode .close-btn:hover,
body.dark-mode .feature-modal-close:hover {
    color: #BDBDBD;
}
body.dark-mode .data-zone button,
body.dark-mode .sticker-zone button {
    background-color: #333;
    border-color: var(--accent-color);
}
body.dark-mode .data-zone button:hover,
body.dark-mode .sticker-zone button:hover {
    background-color: var(--accent-color);
    color: white;
}
body.dark-mode .danger-zone button {
    border-color: var(--delete-color);
}
body.dark-mode .danger-zone button:hover {
    background-color: var(--delete-color);
}
body.dark-mode .chat-item {
    background-color: #2a2a2e;
    border-color: #444;
}
body.dark-mode .chat-item:hover {
    background-color: #3a3a40;
}
body.dark-mode .chat-item.active {
    border-color: var(--accent-color);
    background-color: #312a2c;
}
body.dark-mode .theme-option {
  background-color: #2D2D30;
}
body.dark-mode #load-more-btn {
    background-color: #333;
    color: #aaa;
}
body.dark-mode #load-more-btn:hover {
    background-color: #444;
}
body.dark-mode .moment-comments {
    background: #252525;
}
body.dark-mode .comment {
    border-bottom-color: #3a3a3a;
}
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500&family=ZCOOL+KuaiLe&family=Long+Cang&family=Zhi+Mang+Xing&family=Ma+Shan+Zheng&family=LXGW+WenKai+Mono+TC&family=Press+Start+2P&family=DotGothic16&family=VT323&family=Noto+Serif+TC:wght@400;500&family=Pacifico&family=ZCOOL+QingKe+HuangYou&display=swap');
        /* --- Global Styles & Variables --- */
        :root {
    --font-main: 'Cubic 11', 'Noto Sans JP', sans-serif;
    --font-ui: 'Cubic 11', 'Noto Sans JP', sans-serif;
    --font-logo: 'Pacifico', cursive;
    
    --bg-color: #FFFFFF;
    --chat-bg-color: rgba(255, 255, 255, 0.85);
    --header-bg-color: rgba(255, 255, 255, 0.95);
    --input-bg-color: #ffffff;
    --text-color: #5c5c5c;
    --text-light-color: #a0a0a0;
    --accent-color: #ff8fab;
    --accent-dark-color: #f87197;
    --border-color: #fde2e2;
    --delete-color: #ff6b6b;
    --success-color: #4CAF50;
    --notification-bg: rgba(255, 143, 171, 0.9);
    --red-packet-color: #e67e22;

    --base-font-size: 16px;
    --bubble-padding: 10px 15px;
    --ui-scale: 1.0;

    /* ...后面的颜色变量保持不变... */*/
    --ui-scale: 1.0; /* Default UI scale */

    /* Bubble Themes */
    /* 默认主题 */
    --theme1-ai-bg: #ffffff; --theme1-ai-text: #333333;
    --theme1-user-bg: #333333; --theme1-user-text: #ffffff;
    --theme2-ai-bg: #333333; --theme2-ai-text: #ffffff;
    --theme2-user-bg: #ffffff; --theme2-user-text: #333333;
    
        /* 修复字体色的旧主题 (已更新颜色) */
    --theme3-ai-bg: #F8F8F8; --theme3-ai-text: #333333;
    --theme3-user-bg: #BDE6F1; --theme3-user-text: #333333; /* 更浅的天蓝色 */
    --theme4-ai-bg: #F8F8F8; --theme4-ai-text: #333333;
    --theme4-user-bg: #C1E1C1; --theme4-user-text: #333333; /* 更浅的草绿色 */
    --theme5-ai-bg: #ffffff; --theme5-ai-text: #333333;
    --theme5-user-bg: #ffe4f1; --theme5-user-text: #c2185b; /* 樱花色 */

    /* 新增主题 (已更新AI灰色) */
    --theme6-ai-bg: #F8F8F8; --theme6-ai-text: #333333; /* 最浅灰 / 深空蓝 */
    --theme6-user-bg: #007aff; --theme6-user-text: #ffffff;
    --theme7-ai-bg: #5698d2; --theme7-ai-text: #333333; /* 马龙卡蓝 / 奶油黄 */
    --theme7-user-bg: #fff2cc; --theme7-user-text: #333333;
    --theme8-ai-bg: #ffffff; --theme8-ai-text: #333333; /* 微信日间 */
    --theme8-user-bg: #a9ea7a; --theme8-user-text: #333333;
    --theme9-ai-bg: #343434; --theme9-ai-text: #E5E5E5; /* 微信夜间 */
    --theme9-user-bg: #57BD61; --theme9-user-text: #343434;
    
    /* TASK 13: Add 4 New Bubble Themes (已更新AI灰色) */
    --theme10-ai-bg: #F8F8F8; --theme10-ai-text: #333333; /* 最浅的灰和次浅的灰 */
    --theme10-user-bg: #EFEFEF; --theme10-user-text: #333333;
    --theme11-ai-bg: #795548; --theme11-ai-text: #ffffff; /* 薄巧的薄荷色和薄巧的巧克力色 */
    --theme11-user-bg: #A8E6CF; --theme11-user-text: #333333; 
    --theme12-ai-bg: #A7D8F0; --theme12-ai-text: #333333; /* 捡手机文学的淡天空蓝和淡奶油黄 */
    --theme12-user-bg: #FFFACD; --theme12-user-text: #333333; 
    --theme13-ai-bg: #F8F8F8; --theme13-ai-text: #333333; /* 最浅的灰色和很浅的奶油黄 */
    --theme13-user-bg: #FFFDD0; --theme13-user-text: #333333;
    --theme14-ai-bg: #ffffff; --theme14-ai-text: #333333; --theme14-user-bg: #ffffff; --theme14-user-text: #333333;      

    --ai-bubble-bg: var(--theme1-ai-bg);
    --ai-bubble-text: var(--theme1-ai-text);
    --user-bubble-bg: var(--theme1-user-bg);
    --user-bubble-text: var(--theme1-user-text);
}
        /* --- Base & Layout --- */
        html {
           /* TASK 9: Use CSS variable for base font size to allow scaling */
           font-size: var(--base-font-size); 
        }
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: var(--font-main);
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            /* TASK 8: Remove background image */
            /* background-image: url('data:image/svg+xml,...'); */
            color: var(--text-color);
            transition: background-color 0.5s ease;
        }

        #chat-container {
            display: flex; flex-direction: column; height: 100%; max-width: 800px; margin: 0 auto;
            background-color: var(--chat-bg-color); backdrop-filter: blur(10px); box-shadow: 0 0 30px rgba(255, 143, 171, 0.15);
            transition: background-color 0.5s ease, transform 0.3s ease;
            position: relative;
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center center;
            /* TASK 9: Apply UI scaling */
            transform: scale(var(--ui-scale));
            transform-origin: center center;
        }
        
        #top-notification {
            position: absolute; top: -60px; left: 5%; width: 90%;
            background-color: var(--notification-bg);
            color: white; text-align: center;
            padding: 10px; border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-family: var(--font-ui); font-size: 0.9em;
            z-index: 100; transition: top 0.5s ease-in-out;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        #top-notification.show { top: 0; }
        #top-notification img { width: 24px; height: 24px; border-radius: 50%; }

        #chat-header {
            display: flex; justify-content: space-between; align-items: center; padding: 10px 15px;
            background-color: var(--header-bg-color); border-bottom: 1px solid var(--border-color); backdrop-filter: blur(5px); z-index: 10;
            flex-shrink: 0;
        }
        #chat-manager-btn { background: none; border: none; cursor: pointer; padding: 5px; }
        #chat-manager-btn svg { width: 26px; height: 26px; fill: var(--accent-color); transition: transform 0.3s ease, fill 0.3s ease; }
        #chat-manager-btn:hover svg { fill: var(--accent-dark-color); transform: scale(1.1); }
        
        /* TASK 7: Make header avatar circular and remove border */
        #header-avatar {
            width: 40px; height: 40px; border-radius: 50%; object-fit: cover;
            /* border: 2px solid var(--border-color); */
            cursor: pointer; transition: transform 0.2s ease;
        }
        #header-avatar:hover { transform: scale(1.1); }
        #chat-name-header { flex-grow: 1; text-align: center; font-size: 1.2em; font-weight: 500; color: var(--accent-dark-color); padding: 5px; border-radius: 5px; transition: background-color 0.2s; }
        #chat-name-header:focus { outline: 1px solid var(--accent-color); background-color: rgba(255, 143, 171, 0.1); }
        #settings-btn { background: none; border: none; cursor: pointer; padding: 5px; }
        #settings-btn svg { width: 24px; height: 24px; fill: var(--accent-color); transition: transform 0.3s ease, fill 0.3s ease; }
        #settings-btn:hover svg { transform: rotate(45deg); fill: var(--accent-dark-color); }
        
        #messages { flex-grow: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 5px; }
        #messages::-webkit-scrollbar { width: 6px; }
        #messages::-webkit-scrollbar-track { background: transparent; }
        #messages::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 10px; }
        
        #load-more-btn {
            align-self: center; background-color: #f0f0f0; border: none; padding: 8px 15px;
            border-radius: 15px; cursor: pointer; color: #888; font-family: var(--font-ui);
            margin-bottom: 15px; transition: background-color 0.2s;
        }
        #load-more-btn:hover { background-color: #e0e0e0; }

        /* --- Message Bubbles --- */
               .message {
            display: flex;
            align-items: flex-end; /* 关键修复：确保所有项目（头像和气泡）在容器的底部对齐 */
            gap: 10px;
            max-width: 80%;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .message.user { align-self: flex-end; flex-direction: row-reverse; }
        .message.ai { align-self: flex-start; }
        .message .sender-name { font-size: 0.75em; color: #999; margin-bottom: 4px; padding: 0 5px; display: none; }
        .message.group-chat.ai .sender-name { display: block; }
        .message.system { align-self: center; background: #e0e0e0; color: #757575; font-size: 0.8em; padding: 4px 10px; border-radius: 10px; max-width: none; cursor: default; }
        .message.system .avatar, .message.system .timestamp { display: none; }
        .avatar { 
            width: 40px; height: 40px; 
            /* TASK 7: Make avatars circular and remove border */
            border-radius: 50%;
            object-fit: cover;
            /* border: 2px solid var(--border-color); */
            flex-shrink: 0;
        }
                .message-content {
            position: relative; /* 新增：为时间戳提供定位的“锚点” */
            display: flex;
            flex-direction: column;
        }
        .message.user .message-content { align-items: flex-end; }
        .message.ai .message-content { align-items: flex-start; }
        .bubble { 
            /* TASK 9: Use CSS variable for padding */
            padding: var(--bubble-padding); 
            border-radius: 18px; position: relative;
            /* TASK 7: Remove box-shadow */
            /* box-shadow: 0 2px 5px rgba(0,0,0,0.05); */
            word-wrap: break-word; max-width: 100%; transition: transform 0.2s ease, border 0.2s ease, opacity 0.2s ease; 
        }
        :not(.custom-style-active) .message.ai .bubble { background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text); }
        :not(.custom-style-active) .message.user .bubble { background-color: var(--user-bubble-bg); color: var(--user-bubble-text); }
        .message.ai .bubble { border-bottom-left-radius: 4px; }
        .message.user .bubble { border-bottom-right-radius: 4px; }
        .bubble p { margin: 0; }
                .timestamp {
            position: absolute; /* 新增：让时间戳“浮动”起来，不影响气泡对齐 */
            bottom: -1.5em;     /* 新增：把它定位到气泡的下方 */
            font-size: 0.7em;
            color: var(--text-light-color);
            padding: 0 5px;
            white-space: nowrap; /* 新增：防止时间换行，更美观 */
        }
        /* 新增：控制时间戳的水平位置 */
        .message.ai .timestamp {
            left: 0;
        }
        .message.user .timestamp {
            right: 0;
        }
        /* TASK 7: Style for "Read" status */
.message {
    position: relative; /* 关键：让整个消息容器作为“已读”的定位参考 */
}
.read-status {
    position: absolute; /* 使用绝对定位，让它“漂浮”起来 */
    font-size: 0.6em;   /* 保持小巧的字体 */
    color: var(--text-light-color);
    padding: 1px 4px;
    border-radius: 5px;
}
/* 用户消息的已读，定位在右侧头像上方 */
.message.user .read-status {
    left: -20px; /* 从右侧开始定位，50px大约是头像的宽度+间距 */
}
/* AI消息的已读，定位在左侧头像上方 */
.message.ai .read-status {
    right: -20px; /* 从左侧开始定位 */
}
        
        .multi-select-mode .message:not(.selected):not(.system) { opacity: 0.6; }
        .multi-select-mode .message.selected .bubble { transform: scale(1.03); border: 2px solid var(--accent-dark-color); }

        .typing-indicator { align-items: center; gap: 8px; font-size: 0.9em; font-style: italic; color: #aaa; }
        .typing-indicator .dot { width: 6px; height: 6px; background-color: #ccc; border-radius: 50%; animation: typing 1.4s infinite; }
        .typing-indicator .dot:nth-child(1) { animation-delay: 0.2s; }
        .typing-indicator .dot:nth-child(2) { animation-delay: 0.4s; }
        @keyframes typing { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-4px); } }

        /* --- Input Area & Action Panel --- */
        #bottom-panel { position: relative; flex-shrink: 0; background: var(--header-bg-color); }
        #input-area { display: flex; align-items: flex-end; padding: 10px 15px; border-top: 1px solid var(--border-color); transition: opacity 0.3s ease, visibility 0.3s ease; gap: 10px; }
        #action-btn { background: none; border: none; cursor: pointer; padding: 5px; margin-right: 5px; align-self: center; flex-shrink: 0;}
        #action-btn svg { width: 28px; height: 28px; fill: var(--accent-color); transition: transform 0.3s ease, fill 0.2s; }
        #action-btn:hover svg { fill: var(--accent-dark-color); }
        #message-input { flex-grow: 1; border: 1px solid var(--border-color); border-radius: 20px; padding: 10px 15px; font-size: 1em; font-family: var(--font-main); resize: none; transition: border-color 0.3s ease, box-shadow 0.3s ease; max-height: 100px; overflow-y: auto; }
        #message-input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 5px var(--accent-color); }
        
        /* TASK 5: Add styles for the new receive button */
        #receive-btn, #send-btn { background-color: var(--accent-color); border: none; border-radius: 50%; width: 44px; height: 44px; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: background-color 0.3s ease, transform 0.2s ease; flex-shrink: 0; }
        #receive-btn:hover, #send-btn:hover { background-color: var(--accent-dark-color); transform: scale(1.1); }
        #send-btn:disabled { background-color: #f8c3d1; cursor: not-allowed; transform: scale(1); }
        #receive-btn svg, #send-btn svg { width: 20px; height: 20px; fill: white; }

        #action-panel { display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 15px; padding: 0 20px; border-top: 1px solid var(--border-color); max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; }
        #action-panel.show { max-height: 300px; padding-top: 20px; padding-bottom: 20px; }
        .action-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; font-family: var(--font-ui); font-size: 0.8em; color: var(--text-color); }
        .action-item-icon { width: 50px; height: 50px; background-color: #fff; border: 1px solid var(--border-color); border-radius: 12px; display: flex; justify-content: center; align-items: center; margin-bottom: 5px; transition: all 0.2s ease; }
        .action-item:hover .action-item-icon { transform: translateY(-3px); box-shadow: 0 4px 10px rgba(255, 143, 171, 0.3); }
        .action-item-icon svg { width: 24px; height: 24px; fill: var(--accent-color); }

        /* --- Feature-Specific Bubbles --- */
        .bubble.message-image, .bubble.message-sticker { padding: 5px; background: transparent; box-shadow: none; }
        .bubble-image-content { max-width: 250px; max-height: 250px; border-radius: 15px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        
        .bubble.message-text-image { display: flex; flex-direction: column; gap: 8px; }
        .message.ai .bubble.message-text-image { background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text); }
        .message.user .bubble.message-text-image { background-color: var(--user-bubble-bg); color: var(--user-bubble-text); }
        .text-image-header { display: flex; align-items: center; gap: 8px; font-size: 0.9em; opacity: 0.8;}
        .text-image-header svg { width: 18px; height: 18px; fill: currentColor; }
        .text-image-description { border-left: 2px solid var(--accent-color); padding-left: 10px; font-family: var(--font-ui); white-space: pre-wrap; }

        .bubble.message-voice { display: flex; align-items: center; gap: 10px; }
        .message.ai .bubble.message-voice { background: var(--ai-bubble-bg); color: var(--ai-bubble-text); }
        .message.user .bubble.message-voice { background: var(--user-bubble-bg); color: var(--user-bubble-text); }
        .voice-icon svg { width: 20px; height: 20px; fill: currentColor; }
        .voice-duration { font-family: var(--font-ui); }

        .bubble.message-transfer { padding: 0; border-radius: 12px; overflow: hidden; background: #ff7675; color: white; width: 240px; position: relative; cursor: default; }
        .message.ai .bubble.message-transfer { cursor: pointer; }
        .transfer-cover { width: 100%; height: 110px; object-fit: cover; display: block; }
        .transfer-info { padding: 10px 15px; }
        .transfer-amount { font-size: 1.4em; font-weight: bold; font-family: var(--font-ui); }
        .transfer-memo { font-size: 0.9em; opacity: 0.9; margin-top: 5px; }
        .transfer-footer { font-size: 0.7em; opacity: 0.8; padding: 5px 15px; background: rgba(0,0,0,0.1); }
        .transfer-acknowledged { position: absolute; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.3); backdrop-filter: blur(2px); display:flex; justify-content:center; align-items:center; color:white; font-family:var(--font-ui); font-size:1.1em; }

        /* Red Packet Bubble */
        .bubble.message-red-packet { width: 250px; padding: 0; background: var(--red-packet-color); border-radius: 12px; color: white; }
        .red-packet-body { padding: 15px; }
        .red-packet-body-header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .red-packet-body-header svg { width: 32px; height: 32px; fill: white; }
        .red-packet-memo { font-size: 1.1em; }
        .red-packet-grab-btn { background: #f39c12; border: none; color: white; width: 100%; padding: 12px; font-size: 1.1em; cursor: pointer; transition: background-color 0.2s; font-family: var(--font-main); }
        .red-packet-grab-btn:hover { background: #f1c40f; }
        .red-packet-footer { font-size: 0.75em; padding: 5px 15px; background: rgba(0,0,0,0.1); }
        .red-packet-results { padding: 10px; background: white; color: var(--text-color); border-radius: 0 0 12px 12px; }
        .red-packet-result-item { display: flex; justify-content: space-between; padding: 4px 5px; font-size: 0.85em; }

        /* Poll Bubble */
        .bubble.message-poll { background: #fff; border: 1px solid var(--border-color); padding: 15px; color: var(--text-color); max-width: 280px; }
        .poll-question { font-weight: 500; margin-bottom: 15px; font-size: 1.05em; color: var(--accent-dark-color); }
        .poll-option { margin-bottom: 10px; }
        .poll-option-label { display: block; margin-bottom: 5px; font-size: 0.9em; }
        .poll-progress-bar { background: #f0f0f0; border-radius: 5px; overflow: hidden; height: 20px; position: relative; }
        .poll-progress-fill { background: linear-gradient(45deg, var(--accent-color), #ffb8ca); height: 100%; border-radius: 5px; transition: width 0.5s ease; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; box-sizing: border-box; }
        .poll-percentage { color: white; font-size: 0.8em; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        .poll-voters { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 5px; padding-left: 2px; }
        .poll-voter-avatar { width: 20px; height: 20px; border-radius: 50%; object-fit: cover; border: 1px solid white; box-shadow: 0 0 2px rgba(0,0,0,0.2); }
        .poll-vote-btn { background: #f7f7f7; border: 1px solid #ddd; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9em; transition: all 0.2s ease; display: block; width: 100%; margin-top: 8px; text-align: center; }
        .poll-vote-btn:hover { background: #eee; border-color: #ccc; }
        .poll-vote-btn.voted, .poll-vote-btn:disabled { background: var(--accent-color); color: white; border-color: var(--accent-color); cursor: not-allowed; opacity: 0.7; }

        /* --- Generic & Specific Modals --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); backdrop-filter: blur(5px); display: none; justify-content: center; align-items: center; z-index: 2001; animation: fadeIn 0.3s ease; }
        .modal-overlay.show { display: flex; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        .modal-overlay.hiding { animation: fadeOut 0.3s ease forwards; }

        .feature-modal-content { font-family: var(--font-ui); background: #fff; padding: 25px 35px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 90%; max-width: 450px; animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(20px); opacity: 0; } }
        .modal-overlay.hiding .feature-modal-content { animation: slideOut 0.3s ease-out forwards; }
        
        .feature-modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .feature-modal-header h3 { margin: 0; font-family: var(--font-logo); color: var(--accent-dark-color); font-size: 1.8em; }
        .feature-modal-close { background: none; border: none; font-size: 2em; color: #ccc; cursor: pointer; transition: color 0.3s ease, transform 0.3s ease; }
        .feature-modal-close:hover { color: #999; transform: rotate(90deg); }
        .feature-modal-body .form-group { margin-bottom: 15px; }
        .feature-modal-body .form-group input, .feature-modal-body .form-group textarea { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: var(--font-ui); box-sizing: border-box; }
        .feature-modal-footer { text-align: right; margin-top: 20px; }
        .feature-modal-submit-btn { padding: 10px 20px; background: var(--accent-dark-color); color: white; border: none; border-radius: 8px; cursor: pointer; }
        
        #mind-voice-modal-content { background: rgba(0,0,0,0.7); color: white; padding: 25px; border-radius: 15px; max-width: 90%; max-height: 70vh; overflow-y: auto; font-family: var(--font-ui); font-size: 1.1em; line-height: 1.6; border: 1px solid rgba(255,255,255,0.2); }
        #mind-voice-modal-content p { margin: 0; }
        #mind-voice-close-btn { position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 2.5em; color: white; cursor: pointer; line-height: 1; text-shadow: 0 0 5px black; }

        #sticker-gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 5px; border: 1px solid #eee; border-radius: 8px; }
        #sticker-gallery img { width: 100%; height: 80px; object-fit: cover; border-radius: 8px; cursor: pointer; transition: transform 0.2s; }
        #sticker-gallery img:hover { transform: scale(1.1); }

        #video-call-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1001; display: none; flex-direction: column; justify-content: space-between; align-items: center; color: white; font-family: var(--font-ui); padding: 20px; box-sizing: border-box; }
        #video-call-overlay.show { display: flex; }
        .video-main-view { width: 100%; height: 100%; position: absolute; top: 0; left: 0; object-fit: cover; opacity: 0.3; z-index: -1; }
        .video-self-view { position: absolute; top: 20px; right: 20px; width: 100px; height: 150px; border: 2px solid white; border-radius: 12px; object-fit: cover; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .video-character-info { z-index: 2; text-align: center; margin-top: 6vh; flex-shrink: 0; }
        .video-character-info .avatar { width: 120px; height: 120px; border-radius: 50%; border: 4px solid white; }
        .video-character-info h2 { margin: 10px 0 5px 0; font-size: 1.8em; }
        .video-character-info p { font-size: 1em; color: #eee; }
        #video-chat-log { z-index: 2; width: 100%; max-width: 500px; flex-grow: 1; margin-top: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        #video-chat-log::-webkit-scrollbar { display: none; }
        .video-chat-message { padding: 8px 12px; border-radius: 12px; max-width: 70%; word-wrap: break-word; font-family: var(--font-main); }
        .video-chat-message i { font-style: italic; opacity: 0.8; }
        .video-chat-message.user { background: rgba(255,255,255,0.2); align-self: flex-end; }
        .video-chat-message.ai { background: rgba(0,0,0,0.2); align-self: flex-start; }
        #video-input-area { z-index: 2; display: flex; width: 100%; max-width: 520px; margin: 15px 0; gap: 10px; flex-shrink: 0; }
        #video-message-input { flex-grow: 1; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: white; border-radius: 18px; padding: 8px 15px; font-family: var(--font-main); }
        #video-message-input::placeholder { color: rgba(255,255,255,0.6); }
        #video-send-btn { background: var(--accent-color); border: none; border-radius: 18px; color: white; padding: 8px 18px; cursor: pointer; font-family: var(--font-ui); }
        .video-controls { z-index: 2; margin-bottom: 2vh; display: flex; gap: 40px; flex-shrink: 0; }
        .video-btn { width: 70px; height: 70px; border-radius: 50%; border: none; cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .video-btn svg { width: 35px; height: 35px; fill: white; }
        .video-btn.accept { background-color: var(--success-color); }
        .video-btn.decline { background-color: var(--delete-color); }
        
        #delete-toolbar { position: absolute; bottom: 0; left: 0; width: 100%; box-sizing: border-box; background: var(--header-bg-color); padding: 15px 20px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; z-index: 5; }
        #delete-toolbar.show { opacity: 1; visibility: visible; }
        #delete-info { font-family: var(--font-ui); color: var(--text-color); }
        #delete-actions button { font-family: var(--font-ui); font-size: 0.9em; padding: 8px 16px; border: none; border-radius: 10px; cursor: pointer; transition: background-color 0.2s ease; }
        #confirm-delete-btn { background-color: var(--delete-color); color: white; margin-right: 10px; }
        #cancel-delete-btn { background-color: #eee; color: #555; }
        
        .settings-content { background: #fff; padding: 25px 35px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 90%; max-width: 600px; max-height: 90vh; display: flex; flex-direction: column; font-family: var(--font-ui); }
        .settings-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
        .settings-header h2 { margin: 0; font-family: var(--font-logo); color: var(--accent-dark-color); font-size: 2em; }
        .close-btn { background: none; border: none; font-size: 2em; color: #ccc; cursor: pointer; transition: color 0.3s ease, transform 0.3s ease; }
        .close-btn:hover { color: #999; transform: rotate(90deg); }
        .settings-body { overflow-y: auto; padding-right: 15px; }
        .settings-body::-webkit-scrollbar { width: 5px; }
        .settings-body::-webkit-scrollbar-track { background: #f1f1f1; }
        .settings-body::-webkit-scrollbar-thumb { background: #ddd; border-radius: 10px; }
        .settings-section { margin-bottom: 25px; }
        .settings-section h3 { margin: 0 0 15px 0; font-weight: 500; color: var(--accent-color); border-left: 3px solid var(--accent-color); padding-left: 10px; }
        .form-group { margin-bottom: 15px; display: flex; flex-direction: column; }
        .form-group label { margin-bottom: 5px; font-size: 0.9em; color: #666; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: var(--font-ui); box-sizing: border-box; transition: border-color 0.3s, box-shadow 0.3s; }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 5px var(--accent-color); }
        .form-group textarea { min-height: 120px; resize: vertical; }
        .model-group { display: flex; align-items: center; gap: 10px; }
        .model-group button { padding: 10px 15px; background: var(--accent-color); color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease; white-space: nowrap; }
        .avatar-upload-group { display: flex; align-items: center; gap: 15px; }
        /* TASK 7: Make preview avatars circular */
        .avatar-preview { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; border: 2px dashed var(--border-color); }
        .file-input-label { background: #f7f7f7; border: 1px solid #ddd; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9em; transition: background-color 0.3s ease; display: inline-block; text-align: center; }
        .theme-selector { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; }
        .theme-option { flex-grow: 1; padding: 10px; border-radius: 8px; cursor: pointer; border: 2px solid transparent; text-align: center; transition: all 0.3s ease; }
        .theme-option.active { border-color: var(--accent-dark-color); font-weight: 500; }
        .theme-option span { display: block; width: 20px; height: 20px; border-radius: 5px; margin: 5px auto 0 auto; background: var(--user-bubble-bg); }
        #theme1 { background: #f9f9f9; } #theme1 span { background: var(--theme1-user-bg); }
        #theme2 { background: #f9f9f9; } #theme2 span { background: var(--theme2-user-bg); }
        #theme3 { background: #f9f9f9; } #theme3 span { background: var(--theme3-user-bg); }
        #theme4 { background: #f9f9f9; } #theme4 span { background: var(--theme4-user-bg); }
        #theme5 { background: #f9f9f9; } #theme5 span { background: var(--theme5-user-bg); }
        .data-zone button, .sticker-zone button { width: 100%; padding: 10px; background-color: #fff; color: var(--accent-color); border: 1px solid var(--accent-color); border-radius: 8px; cursor: pointer; transition: background-color 0.2s, color 0.2s; }
        .data-zone button:hover, .sticker-zone button:hover { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        .danger-zone button { color: var(--delete-color); border-color: var(--delete-color); }
        .danger-zone button:hover { background-color: var(--delete-color); color: white; border-color: var(--delete-color); }
        #delete-character-btn { margin-top: 10px; }
        .settings-footer { margin-top: 20px; text-align: right; border-top: 1px solid #eee; padding-top: 20px; }
        #save-settings-btn { padding: 12px 25px; font-size: 1em; font-weight: 500; background: var(--accent-dark-color); color: white; border: none; border-radius: 10px; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; }
        #save-settings-btn:hover { background-color: #e06387; transform: translateY(-2px); }

        /* --- Moments (朋友圈) Modal --- */
        #moments-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fdfdfd; z-index: 2000; display: none; flex-direction: column; }
        #moments-overlay.show { display: flex; animation: fadeIn 0.3s ease; }
        
        #moments-feed-container { flex-grow: 1; overflow-y: auto; background-color: #fff; }
        
        #moments-cover-area { position: relative; width: 100%; height: 35vh; background-color: #eee; background-size: cover; background-position: center; flex-shrink: 0; }
        #moments-user-info { position: absolute; bottom: -25px; right: 20px; display: flex; align-items: flex-end; gap: 15px; }
        #moments-user-name { color: white; font-size: 1.2em; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); margin-bottom: 5px; font-weight: bold; }
        /* TASK 7: Make moments avatar circular */
        #moments-user-avatar { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        
        #moments-header { position: absolute; top: 0; left: 0; width: 100%; display: flex; align-items: center; justify-content: space-between; padding: 15px; box-sizing: border-box; background: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent); }
        #moments-close-btn { background: rgba(0,0,0,0.2); border: none; color: white; width: 30px; height: 30px; border-radius: 50%; font-size: 1.5em; line-height: 30px; text-align: center; cursor: pointer; transition: background-color 0.2s; }
        #moments-close-btn:hover { background: rgba(0,0,0,0.4); }
        #post-new-moment-btn { background: rgba(255,255,255,0.9); border: none; color: var(--accent-dark-color); padding: 8px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 5px rgba(0,0,0,0.1); }
        #post-new-moment-btn svg { width: 24px; height: 24px; display: block; }

        #moments-feed { padding-top: 45px; } /* Space for cover overlap */
        .moment-post { border-bottom: 1px solid #f0f0f0; padding: 15px 20px; display: flex; gap: 12px; }
        .moment-post:last-child { border-bottom: none; }
        /* TASK 7: Make moment post avatars circular */
        .moment-avatar { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; flex-shrink: 0; cursor: pointer; }
        .moment-body { flex-grow: 1; }
        .moment-username { font-weight: 500; color: var(--accent-dark-color); margin-bottom: 8px; }
        .moment-content { margin-bottom: 10px; font-size: 0.95em; line-height: 1.6; color: #444; white-space: pre-wrap; }
        .moment-image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 5px; margin-bottom: 10px; }
        .moment-image-grid img { width: 100%; height: 100px; object-fit: cover; border-radius: 8px; }
        .moment-image { width: 100%; max-width: 300px; border-radius: 12px; object-fit: cover; margin-bottom: 10px; }
        .moment-footer { display: flex; justify-content: space-between; align-items: center; font-size: 0.8em; color: var(--text-light-color); }
        .moment-actions button { background: none; border: none; cursor: pointer; color: var(--text-light-color); padding: 5px 8px; border-radius: 5px; transition: background-color 0.2s, color 0.2s; }
        .moment-actions button:hover { background-color: #fcefee; }
        .moment-actions button.liked { color: var(--accent-dark-color); font-weight: bold; }
        .moment-actions button svg { width: 16px; height: 16px; vertical-align: middle; margin-right: 4px; }
        
        .moment-comments { margin-top: 10px; background: #fafafa; border-radius: 8px; padding: 2px 10px; }
        .comment { padding: 6px 0; border-bottom: 1px solid #f0f0f0; font-size: 0.9em; }
        .comment:last-child { border-bottom: none; }
        .comment-user { color: var(--accent-color); font-weight: 500; }
        .comment-text { cursor: pointer; }
           /* -- 我们不再需要嵌套样式了，所以把它注释掉 -- */
    /*
    .comment .replies {
        padding-left: 20px;
        margin-top: 8px;
        border-left: 2px solid #eee;
    }
    */

        /* TASK 4: Fix comment input form CSS */
        .comment-input-form { 
            display: flex; 
            margin-top: 8px; 
            gap: 5px; 
            width: 100%; /* Ensure it doesn't overflow */
            box-sizing: border-box; /* Include padding in width calculation */
        }
        .comment-input-form input { flex-grow: 1; border: 1px solid #eee; border-radius: 15px; padding: 5px 10px; font-size: 0.9em; font-family: var(--font-ui); min-width: 0; /* Allow input to shrink */ }
        .comment-input-form input:focus { border-color: var(--accent-color); outline: none; }
        .comment-input-form button { background: var(--accent-color); color: white; border: none; border-radius: 15px; padding: 5px 12px; font-size: 0.85em; cursor: pointer; flex-shrink: 0; }

        /* --- Chat Management (Character & Group) Modal --- */
        .chat-manager-tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; }
        .chat-manager-tab { padding: 10px 20px; cursor: pointer; font-size: 1.1em; color: var(--text-light-color); position: relative; }
        .chat-manager-tab.active { color: var(--accent-dark-color); font-weight: 500; }
        .chat-manager-tab.active::after { content: ''; position: absolute; bottom: -1px; left: 0; right: 0; height: 2px; background-color: var(--accent-dark-color); }
        .chat-manager-content { display: none; }
        .chat-manager-content.active { display: block; }
        .chat-list { max-height: 50vh; overflow-y: auto; padding-right: 10px; }
        .chat-item { display: flex; align-items: center; padding: 12px; border-radius: 10px; margin-bottom: 10px; cursor: pointer; transition: background-color 0.2s; border: 1px solid #eee; }
        .chat-item:hover { background-color: #fcf6f8; }
        .chat-item.active { background-color: var(--bg-color); border-color: var(--accent-color); }
        /* TASK 7: Make chat list item avatars circular */
        .chat-item img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-right: 15px; }
        .chat-item .name { font-weight: 500; font-size: 1.1em; flex-grow: 1; }
        .chat-item .delete-btn { background: none; border: none; cursor: pointer; color: #ccc; font-size: 1.5em; padding: 0 5px; transition: color 0.2s; }
        .chat-item .delete-btn:hover { color: var(--delete-color); }
        .add-new-btn { width: 100%; padding: 12px; background-color: var(--accent-color); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 1em; font-family: var(--font-ui); margin-top: 15px; }
        #create-group-members { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
        .member-select-item { display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; }
        .member-select-item:hover { background: #f7f7f7; }
        .member-select-item input[type=checkbox] { width: 20px; height: 20px; cursor: pointer; }
    
        /* Diary Modal */
        #diary-modal-content {
            font-family: var(--font-ui); background: #fff8f5; padding: 25px 35px; border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 90%; max-width: 500px; max-height: 80vh;
            display: flex; flex-direction: column;
        }
        #diary-header {
            text-align: center; font-family: var(--font-logo); color: var(--accent-dark-color);
            font-size: 2em; padding-bottom: 15px; border-bottom: 2px dashed var(--border-color); margin-bottom: 15px;
        }
        #diary-entries { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .diary-entry {
            background: rgba(255, 255, 255, 0.7); border-radius: 10px; padding: 15px;
            margin-bottom: 15px; border-left: 4px solid var(--accent-color);
            position: relative; /* For delete button positioning */
        }
        .diary-date { font-weight: bold; color: var(--accent-dark-color); margin-bottom: 8px; }
        .diary-content { line-height: 1.7; color: #555; white-space: pre-wrap; }
        /* TASK 2: Style for diary delete button */
        .diary-delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 1.5em;
            line-height: 1;
            transition: color 0.2s;
        }
        .diary-delete-btn:hover {
            color: var(--delete-color);
        }
        /* --- 全新的气泡样式切换 --- */
/* 这是默认样式的“尾巴”，我们先把它定义好 */
.message.ai .bubble { border-bottom-left-radius: 4px; }
.message.user .bubble { border-bottom-right-radius: 4px; }

/* 这是“圆滚滚”样式的定义 */
.bubble-style-round .message .bubble {
    border-radius: 25px !important; /* 让四个角都变得圆滚滚！!important是给它最高优先级 */
}
      /* --- 仿微信尖角样式 --- */
.bubble-style-wechat .message .bubble {
    border-radius: 5px !important; /* 微信的圆角比较小 */
}
.bubble-style-wechat .message .bubble::before {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    top: 14px;
}
.bubble-style-wechat .message.ai .bubble::before {
    left: -8px;
    border-right: 10px solid var(--ai-bubble-bg, #ffffff);
}
.bubble-style-wechat .message.user .bubble::before {
    right: -8px;
    border-left: 10px solid var(--user-bubble-bg, #95ec69);
}
      /* =============================================================== */
/* ================= 新增的预设和滑块功能的CSS样式 ================= */
/* =============================================================== */
.preset-item {
    background: #f9f9f9;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.preset-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.preset-header .form-group {
    flex-grow: 1;
    margin-bottom: 0;
}
.preset-header .form-group input {
    font-weight: 500;
}
.preset-actions {
    display: flex;
    align-items: center;
    gap: 15px;
    flex-shrink: 0;
    margin-left: 15px;
}
.preset-delete-btn {
    background: #ffcccc;
    border: 1px solid #ff9999;
    color: #c53030;
    border-radius: 5px;
    padding: 5px 8px;
    cursor: pointer;
    font-size: 0.8em;
}
.preset-toggle {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
}
.preset-toggle input {
    opacity: 0;
    width: 0;
    height: 0;
}
.preset-toggle .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 28px;
}
.preset-toggle .slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}
.preset-toggle input:checked + .slider {
    background-color: var(--accent-color);
}
.preset-toggle input:checked + .slider:before {
    transform: translateX(22px);
}

input[type=range] {
  -webkit-appearance: none;
  width: 100%;
  margin: 7px 0;
  background: transparent;
}
input[type=range]:focus {
  outline: none;
}
input[type=range]::-webkit-slider-runnable-track {
  width: 100%;
  height: 6px;
  cursor: pointer;
  background: #f0f0f0;
  border-radius: 3px;
  border: 1px solid #ddd;
}
input[type=range]::-webkit-slider-thumb {
  border: 2px solid var(--accent-color);
  height: 20px;
  width: 20px;
  border-radius: 50%;
  background: #ffffff;
  cursor: pointer;
  -webkit-appearance: none;
  margin-top: -8px;
}
      /* =================================================== */
/* ================ 紧凑模式 (类微信风格) =============== */
/* =================================================== */

/* --- 整体布局与间距 --- */
.compact-mode #chat-header {
    padding: 8px 12px;
}
.compact-mode #messages {
    padding: 15px;
}
.compact-mode .message {
    gap: 8px;
    margin-bottom: 8px;
}

/* --- 头像缩小 --- */
.compact-mode #header-avatar,
.compact-mode .message .avatar {
    width: 36px;
    height: 36px;
}

/* --- 消息气泡与字体 --- */
.compact-mode .bubble {
    /* TASK 9: Use variable for padding */
    padding: var(--bubble-padding);
    font-size: 0.95em; /* 字体也稍微缩小一点 */
}
.compact-mode .timestamp {
    font-size: 0.65em;
    margin-top: 4px;
}

/* --- 核心：输入区域紧凑化 --- */
.compact-mode #input-area {
    padding: 8px 12px;
    align-items: center; /* 垂直居中对齐，更像微信 */
}
.compact-mode #message-input {
    padding: 8px 12px;
    font-size: 0.95em;
    border-radius: 18px;
    max-height: 90px; /* 限制输入框最大高度 */
}
.compact-mode #action-btn svg {
    width: 24px;
    height: 24px;
}
.compact-mode #send-btn, .compact-mode #receive-btn {
    width: 38px;
    height: 38px;
}
.compact-mode #send-btn svg, .compact-mode #receive-btn svg {
    width: 18px;
    height: 18px;
}

/* --- 其他功能图标微调 --- */
.compact-mode .action-item-icon {
    width: 45px;
    height: 45px;
}
.compact-mode .action-item {
    font-size: 0.75em;
}

      #streak-notification {
    background: linear-gradient(135deg, #fff0f5, rgba(255, 255, 255, 0.9)); /* 粉白渐变背景 */
    color: #e85a70; /* 柔和的粉红色字体 */
    font-family: 'LXGW WenKai Mono TC', cursive; /* 使用我们可爱的繁体字体 */
    font-size: 0.85em;
    padding: 6px 12px;
    margin: 8px 15%; /* 左右留白，让它变成长条形 */
    border-radius: 15px; /* 圆角 */
    box-shadow: 0 2px 8px rgba(232, 90, 112, 0.15); /* 淡淡的粉色阴影 */
    
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px; /* 图标和文字的间距 */

    /* 默认隐藏，带动画效果 */
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    transition: all 0.5s ease-in-out;
}

#streak-notification.show {
    opacity: 1;
    max-height: 40px; /* 控制它展开后的高度 */
    margin-top: 8px;
    margin-bottom: 8px;
}

#streak-notification #streak-icon svg {
    fill: #ff8fab; /* 图标填充为可爱的粉色 */
    vertical-align: middle; /* 垂直居中对齐 */
    position: relative;
    top: -1px;
}
      /* --- 论坛顶部按钮美化 --- */
#forum-header .add-new-btn {
    background-color: rgba(255, 255, 255, 0.7); /* 半透明的白色背景 */
    color: #333; /* 深灰色文字，保证清晰 */
    border: 1px solid rgba(255, 255, 255, 0.5); /* 淡淡的边框 */
    padding: 6px 14px; /* 让按钮变“小”一点 */
    font-size: 0.9em; /* 字体也小一点 */
    border-radius: 15px; /* 圆润的边角 */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* 浅灰色阴影 */
    backdrop-filter: blur(2px); /* 增加一点毛玻璃质感，更好看 */
    transition: all 0.2s ease; /* 平滑过渡效果 */
}

#forum-header .add-new-btn:hover {
    background-color: rgba(255, 255, 255, 0.9); /* 鼠标悬停时变得更实一点 */
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); /* 阴影加深一点 */
    transform: translateY(-1px); /* 微微上浮，增加互动感 */
}

      /* ============================================================== */
/* =================== 新增：上下文菜单样式 (V2) ================== */
/* ============================================================== */
#message-context-menu {
    position: absolute;
    display: none;
    background-color: var(--header-bg-color, white);
    border: 1px solid var(--border-color, #eee);
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
    padding: 8px;
    z-index: 3000;
    font-family: var(--font-ui);
    backdrop-filter: blur(10px);
    min-width: 150px; /* 给菜单一个最小宽度，防止太窄 */
}
.context-menu-item {
    display: flex;         /* 关键：使用Flex布局来对齐图标和文字 */
    align-items: center;   /* 关键：垂直居中对齐 */
    gap: 12px;             /* 关键：在图标和文字之间创建间距 */
    padding: 10px 15px;
    cursor: pointer;
    border-radius: 8px;
    font-size: 0.9em;
    transition: background-color 0.2s, color 0.2s; /* 让颜色过渡也更平滑 */
    white-space: nowrap;
}
.context-menu-item:hover {
    background-color: var(--accent-color);
    color: white;
}
.context-menu-item svg {
    transition: fill 0.2s; /* 让图标颜色变化也平滑过渡 */
}

      /* ============================================================== */
/* =============== 表情管理界面 (V2) 专属样式 ================== */
/* ============================================================== */
.sticker-management-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 15px;
    max-height: 50vh;
    overflow-y: auto;
    padding: 5px;
}
.sticker-management-item {
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.sticker-management-item img {
    width: 100%;
    height: 120px;
    object-fit: cover;
    border-radius: 8px;
    border: 1px solid #eee;
}
.sticker-management-item .sticker-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    background: rgba(0,0,0,0.6);
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    font-size: 14px;
}
.sticker-description-input {
    width: 100%;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 5px;
    font-size: 0.8em;
    box-sizing: border-box;
}
      
/* ============================================================== */
/* =================== 白绒绒 主题专属样式 (V4 - 精准尺寸控制) ===== */
/* ============================================================== */

/* 当body元素拥有 .theme-white-fluff 这个类时，以下所有样式生效 */

/* --- 1. 全局字体和变量覆盖 (这部分不变) --- */
.theme-white-fluff {
    --font-main: 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
    --font-ui: 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
    --accent-color: #555555;
    --accent-dark-color: #000000;
    --text-color: #333333;
    --text-light-color: #999999;
    --border-color: #eeeeee;
    --header-bg-color: rgba(255, 255, 255, 0.7);
    --chat-bg-color: #ffffff;
    --bg-color: #f5f5f5;
}

/* --- 2. 主界面美化 (这部分不变) --- */
.theme-white-fluff #chat-header { position: relative; border-bottom: 1px solid #f0f0f0; }
.theme-white-fluff #chat-header::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: url('https://files.catbox.moe/kk44at.jpg'); background-size: cover; background-position: center; opacity: 0.7; z-index: -1; }
.theme-white-fluff #chat-header::after { content: ''; position: absolute; top: 50%; right: 10px; transform: translateY(-50%); width: 30px; height: 30px;  background-size: contain; background-repeat: no-repeat; }
.theme-white-fluff #message-input { background-color: rgba(248, 248, 248, 0.35); border: 1px solid #e0e0e0; color: #333; }
.theme-white-fluff #message-input:focus { border-color: #333; box-shadow: 0 0 5px rgba(0, 0, 0, 0.2); }
.theme-white-fluff #action-btn svg { fill: #000000; }

/* --- 【这里是您调节的地方 - 发送与接收按钮】 --- */
.theme-white-fluff #send-btn,
.theme-white-fluff #receive-btn {
    background: none !important; border: none !important; border-radius: 0 !important;
    box-shadow: none !important; transform: none !important; padding: 0 !important;
    /* 在这里调节大小 */
    width: 44px !important;
    height: 44px !important;
}

/* --- 【这里是您调节的地方 - 头部按钮】 --- */
/* 统一设置头部按钮的基础样式，防止被拉伸 */
.theme-white-fluff #chat-header button {
    padding: 0; /* 移除内边距，让图片完全填充 */
    flex-shrink: 0; /* 【关键】禁止按钮在flex布局中被压缩 */
    display: flex; /* 让内部图片居中 */
    align-items: center;
    justify-content: center;
}

/* 左上角按钮 */
.theme-white-fluff #chat-manager-btn {
    /* 在这里调节大小 */
    width: 58px;
    height: 58px;
}

/* --- 【核心修复】增大“进入设置”按钮的可点击区域 --- */
.theme-white-fluff #settings-btn {
    width: 54px;  /* 在这里调节按钮的点击区域大小 */
    height: 54px;
}
.theme-white-fluff #settings-btn img {
    width: 28px;  /* 在这里调节按钮的视觉大小 (图片大小) */
    height: 28px;
}

/* --- 让图片自动填满我们设定好的按钮大小 --- */
.theme-white-fluff #chat-manager-btn img,
.theme-white-fluff #settings-btn img,
.theme-white-fluff #send-btn img,
.theme-white-fluff #receive-btn img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
/* 【核心修复】设置界面里的关闭按钮 (叉叉) */
.theme-white-fluff .settings-content .close-btn {
    width: 32px;  /* 按钮本身大小，方便点击 */
    height: 32px;
    top: 15px; /* 把它从角落往里挪一点，更好看 */
    right: 15px;
    background-color: rgba(255, 255, 255, 0.5); /* 加个半透明底色，增加存在感 */
    border-radius: 50%; /* 圆形更精致 */
    display: flex;
    align-items: center;
    justify-content: center;
}
.theme-white-fluff .settings-content .close-btn svg {
    width: 16px; /* SVG图标本身的大小，可以调小 */
    height: 16px;
    fill: #333;
}
/* --- 【核心修复】设置界面内所有按钮统一为半透明玻璃风格 --- */
.theme-white-fluff .settings-section button,
.theme-white-fluff #save-settings-btn {
    background-color: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    color: #333 !important; /* 深色文字保证可读性 */
    border: 1px solid rgba(255, 255, 255, 0.8) !important;
    border-radius: 8px;
    backdrop-filter: blur(5px); /* 毛玻璃效果 */
    transition: all 0.2s ease;
}
/* 鼠标悬停时，按钮变得更实，增加互动感 */
.theme-white-fluff .settings-section button:hover,
.theme-white-fluff #save-settings-btn:hover {
    background-color: rgba(255, 255, 255, 0.9) !important;
    border-color: rgba(255, 255, 255, 1) !important;
    transform: translateY(-1px);
}
/* 特别处理删除按钮的文字颜色 */
.theme-white-fluff .danger-zone button {
    color: var(--delete-color) !important;
}
.theme-white-fluff .danger-zone button:hover {
    color: #fff !important;
    background-color: var(--delete-color) !important;
}
/* --- 3. 设置界面美化 (这部分不变) --- */
.theme-white-fluff .settings-content { background-color: transparent; position: relative; overflow: hidden; }
.theme-white-fluff .settings-content::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: url('https://files.catbox.moe/nuarnd.jpg'); background-size: cover; background-position: center; opacity: 0.9; z-index: -1; }
.theme-white-fluff .settings-section h3 { color: #333; border-left-color: #333; }
.theme-white-fluff .data-zone button, .theme-white-fluff .sticker-zone button, .theme-white-fluff .danger-zone button { background-color: #fff; color: #333; border-color: #ccc; }

/* ============================================================== */
/* ============= 白绒绒主题 - “一起听歌”专属美化 ================ */
/* ============================================================== */

/* 1. 为“一起听歌”弹窗设置专属背景 */
.theme-white-fluff #listen-together-content {
    position: relative; /* 允许伪元素相对于它定位 */
    overflow: hidden;   /* 防止伪元素溢出圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4);
}

.theme-white-fluff #listen-together-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('https://files.catbox.moe/uy7760.jpg');
    background-size: cover;
    background-position: center;
    opacity: 0.8; /* 设置背景图百分之八十的透明度 */
    z-index: -1;  /* 将背景图置于内容下方 */
}

/* 2. 重置弹窗内组件的背景，让图片透出来 */
.theme-white-fluff #listen-together-content,
.theme-white-fluff #listen-initial-screen,
.theme-white-fluff .music-player,
.theme-white-fluff #playlist-ul {
    background-color: transparent !important;
}

/* 3. 美化“导入”按钮 */
.theme-white-fluff #add-new-song-btn,
.theme-white-fluff #import-zip-btn {
    background-color: rgba(255, 255, 255, 0.4) !important; /* 半透明背景 */
    backdrop-filter: blur(5px);
    border: 1px solid rgba(0, 0, 0, 0.2) !important;
    color: #000 !important; /* 黑色文字 */
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px; /* 图标和文字的间距 */
    padding: 10px 15px !important;
    transition: all 0.2s ease;
}

/* 4. 设置按钮中的图标和文字样式 */
.theme-white-fluff .listen-btn .btn-icon {
    width: 16px;
    height: 16px;
    fill: #000; /* 黑色爱心 */
    transition: fill 0.2s ease;
}

.theme-white-fluff .listen-btn .btn-text {
    font-size: 0.85em; /* 小小的可爱的字 */
    font-weight: 500;
}

/* 5. 设置按钮的悬停效果 */
.theme-white-fluff .listen-btn:hover {
    background-color: rgba(0, 0, 0, 0.8) !important;
    color: #fff !important;
    border-color: rgba(0, 0, 0, 0) !important;
}

.theme-white-fluff .listen-btn:hover .btn-icon {
    fill: #fff; /* 鼠标悬停时，爱心变白色 */
}

/* ============================================================== */
/* ============= 白绒绒主题 - “日记本”专属美化 ================== */
/* ============================================================== */

/* 1. 为日记本弹窗设置专属背景和字体 */
.theme-white-fluff #diary-modal-content {
    position: relative; /* 关键：为背景图伪元素提供定位锚点 */
    overflow: hidden;   /* 关键：确保背景图不会溢出圆角 */
    background: transparent !important; /* 让原背景变透明，使新背景图可见 */
    border: 1px solid rgba(255, 255, 255, 0.4);
    font-family: 'LXGW WenKai Mono TC', 'Zhi Mang Xing', cursive; /* 关键：应用手写字体，并提供备用 */
}

.theme-white-fluff #diary-modal-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('https://files.catbox.moe/mh6t8e.jpg'); /* 您指定的背景图 */
    background-size: cover;      /* 关键：自动填充满 */
    background-position: center; /* 图片居中显示 */
    opacity: 0.8;                /* 关键：设置80%的透明度 */
    z-index: -1;                 /* 将背景图置于最底层 */
}

/* 2. 重置日记本标题样式以适应新背景 */
.theme-white-fluff #diary-header {
    color: #5d4037; /* 使用一个更适合纸张背景的深棕色 */
    border-bottom-color: rgba(93, 64, 55, 0.3);
}

/* 3. 改造日记条目的样式 */
.theme-white-fluff .diary-entry {
    border-left: none !important; /* 关键：去掉原来的引用框竖线 */
    background-color: rgba(255, 255, 255, 0.65); /* 像一张半透明的便签纸 */
    border: 1px solid rgba(0, 0, 0, 0.1);      /* 关键：仿照日记本的方框 */
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* 添加一点阴影，更有立体感 */
    backdrop-filter: blur(3px); /* 增加毛玻璃效果，更显精致 */
}

/* 4. 优化日记条目内部元素的字体和颜色 */
.theme-white-fluff .diary-entry .diary-date {
    color: #8d6e63; /* 为日期使用一个柔和的棕褐色 */
    font-size: 1.1em;
}

.theme-white-fluff .diary-entry .diary-content {
    color: #4e342e; /* 为正文使用深棕色，保证可读性 */
    line-height: 1.9; /* 增大行高，让手写体更易读 */
    font-size: 1.05em;
}

/* 5. 调整删除和编辑按钮的样式 */
.theme-white-fluff .diary-entry .diary-delete-btn,
.theme-white-fluff .diary-entry .diary-regenerate-btn {
    color: rgba(0,0,0,0.3);
}
.theme-white-fluff .diary-entry .diary-delete-btn:hover {
    color: var(--delete-color);
}
.theme-white-fluff .diary-entry .diary-regenerate-btn:hover {
    color: #8d6e63;
}
      
/* =================================================== */
/* ============== 一起听歌 功能专属样式 =============== */
/* =================================================== */

#listen-together-content {
    background: rgba(255, 255, 255, 0.5); /* 半透明背景 */
    backdrop-filter: blur(15px); /* 毛玻璃效果 */
    -webkit-backdrop-filter: blur(15px); /* 兼容Safari浏览器 */
    border: 1px solid rgba(255, 255, 255, 0.6);
    padding: 30px 40px;
    border-radius: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    width: 90%;
    max-width: 400px;
    color: #333;
    text-align: center;
    font-family: var(--font-ui);
}

#listen-initial-screen h3 {
    font-size: 2em;
    font-family: var(--font-logo);
    color: var(--accent-dark-color);
    margin-bottom: 10px;
}

button.listen-btn {
    padding: 12px 25px;
    background: var(--accent-dark-color);
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-family: var(--font-ui);
    font-size: 1em;
    transition: all 0.2s ease;
}
button.listen-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

.listening-status {
    display: flex;
    justify-content: space-around;
    align-items: center;
    margin-bottom: 15px;
}
.listening-status .avatar {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 2px solid white;
}

.connecting-wave {
    width: 50px; /* 舞台宽度 */
    height: 40px; /* 舞台高度 */
    display: flex; /* 让舞者们站成一排 */
    align-items: center; /* 让他们在舞台中央对齐 */
    justify-content: space-between; /* 让他们之间保持优雅的距离 */
}

.connecting-wave span {
    display: block;
    width: 4px; /* 每个舞者（光条）的宽度 */
    height: 100%; /* 让他们和舞台一样高 */
    border-radius: 4px; /* 让他们看起来更圆润可爱 */
    background: linear-gradient(to top, var(--accent-color), #ffb8ca); /* 超级漂亮的粉色渐变！*/
    animation: wave-dance 1.2s infinite ease-in-out; /* 让他们开始跳舞！*/
}

/* 这就是“编舞”的关键，让每个舞者在不同的时间点开始跳舞，形成波浪效果！*/
.connecting-wave span:nth-child(2) {
    animation-delay: 0.1s;
}
.connecting-wave span:nth-child(3) {
    animation-delay: 0.2s;
}
.connecting-wave span:nth-child(4) {
    animation-delay: 0.3s;
}
.connecting-wave span:nth-child(5) {
    animation-delay: 0.4s;
}

/* 这是舞步的具体动作：从很短，到最高，再变回很短，无限循环 */
@keyframes wave-dance {
    0%, 100% {
        transform: scaleY(0.1);
        opacity: 0.7;
    }
    50% {
        transform: scaleY(1);
        opacity: 1;
    }
}

#listen-status-text {
    font-size: 0.9em;
    color: #555;
    margin-bottom: 20px;
}

.music-player {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    background: rgba(255, 255, 255, 0.5);
    padding: 20px;
    border-radius: 15px;
}

#song-cover-art {
    width: 120px;
    height: 120px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
}

.song-info {
    text-align: center;
}
.song-info h4 { margin: 0; font-size: 1.2em; }
.song-info p { margin: 5px 0 0; color: #666; font-size: 0.9em; }

.audio-controls {
    display: flex;
    gap: 20px;
    align-items: center;
}
.audio-controls button {
    background: none;
    border: none;
    cursor: pointer;
    color: #444;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
}
/* 设置SVG图标的样式 */
.audio-controls button svg {
    width: 28px;
    height: 28px;
    fill: #444;
}
#play-pause-btn svg {
    width: 36px;
    height: 36px;
}

.playlist-container {
    margin-top: 25px;
    width: 100%;
}
#playlist-ul {
    list-style: none;
    padding: 0;
    max-height: 150px;
    overflow-y: auto;
    background: rgba(255,255,255,0.3);
    border-radius: 8px;
    margin-bottom: 15px;
}
#playlist-ul li {
    padding: 10px 15px;
    border-bottom: 1px solid rgba(255,255,255,0.5);
    cursor: pointer;
    transition: background-color 0.2s;
    text-align: left;
    font-size: 0.95em;
}
#playlist-ul li:last-child { border-bottom: none; }
#playlist-ul li:hover { background-color: rgba(255,255,255,0.5); }
#playlist-ul li.active {
    background-color: var(--accent-dark-color);
    color: white;
    font-weight: bold;
}
  /* =================================================== */
/* ============== 一起听歌 歌词样式 =============== */
/* =================================================== */
.song-lyrics-display {
    width: 100%;
    height: 100px; /* 您可以根据喜好调整歌词区域的高度 */
    background: rgba(0,0,0,0.05);
    border-radius: 8px;
    padding: 10px;
    overflow-y: auto; /* 当歌词过长时，可以滚动 */
    font-size: 0.9em;
    line-height: 1.6;
    color: #666;
    text-align: center;
    white-space: pre-wrap; /* 保证歌词按原文换行 */
    margin: 10px 0;
    box-sizing: border-box;
}
.dark-mode .song-lyrics-display {
    background: rgba(255,255,255,0.1);
    color: #ccc;
}   
      /* =================================================== */
/* ======== “一起听歌” 界面总样式 (V3 - 终极版) ======== */
/* =================================================== */

/* 1. 弹窗主体布局和尺寸修复 */
#listen-together-content {
    width: 90%;          /* 在手机上，宽度为屏幕的90% */
    max-width: 420px;    /* 在大屏幕上，最大宽度不超过420px，保持精致 */
    max-height: 90vh;    /* 最大高度为视窗的90%，防止内容溢出 */
    display: flex;       /* 使用Flex布局，让其能更好地自适应内容 */
    flex-direction: column;
    padding: 20px;       /* 稍微调整内边距 */
}

#listen-main-screen {
    display: flex;
    flex-direction: column;
    flex-grow: 1;        /* 让主屏幕区域占满弹窗的剩余空间 */
    overflow: hidden;    /* 防止内部元素溢出，这是关键 */
}

/* 2. 播放器和歌词区域 */
.music-player {
    flex-shrink: 0; /* 防止播放器区域被压缩 */
}

.lyrics-container {
    width: 100%;
    height: 90px;
    margin: 10px 0;
    overflow: hidden;
    position: relative;
    -webkit-mask-image: linear-gradient(transparent, black 25%, black 75%, transparent);
    mask-image: linear-gradient(transparent, black 25%, black 75%, transparent);
}

.lyrics-lines {
    width: 100%;
    height: 100%;
    overflow-y: auto;
    scroll-behavior: smooth;
    padding: 30px 0;
    box-sizing: content-box;
}
.lyrics-lines::-webkit-scrollbar { display: none; }
.lyrics-lines { -ms-overflow-style: none; scrollbar-width: none; }

.lyric-line {
    padding: 5px 15px;
    text-align: center;
    font-size: 0.9em;
    color: #999;
    transition: all 0.4s ease;
    opacity: 0.7;
}

.lyric-line.lyric-active {
    font-weight: bold;
    font-size: 1.1em;
    color: var(--accent-dark-color, #000);
    transform: scale(1.1);
    opacity: 1;
}

/* 3. 播放列表布局修复 */
.playlist-container {
    margin-top: 15px;
    width: 100%;
    display: flex;
    flex-direction: column;
    flex-grow: 1;        /* 让播放列表容器占满所有剩余空间 */
    min-height: 0;       /* 在Flex布局下实现内部滚动的关键属性！ */
}

#playlist-ul {
    flex-grow: 1;        /* 让列表本身填满容器 */
    overflow-y: auto;    /* 当内容超出时，列表内部出现垂直滚动条 */
    margin-bottom: 15px;
    border: 1px solid rgba(0,0,0,0.08);
    background: rgba(255,255,255,0.3);
}

#playlist-ul li {
    font-size: 0.9em; /* 稍微缩小字体，容纳更多条目 */
}

/* 4. 夜间模式和白绒绒主题的微调 */
.dark-mode .lyric-line { color: #888; }
.dark-mode .lyric-line.lyric-active { color: #eee; }
.theme-white-fluff #playlist-ul {
    border: 1px solid rgba(255, 255, 255, 0.4);
    background: transparent;
}

/* =================================================== */
/* ============ 播放列表弹窗专属样式 (新增) ============ */
/* =================================================== */
#playlist-modal-content {
    height: 60vh; /* 弹窗高度为屏幕的60% */
    max-height: 500px; /* 最大不超过500px */
    padding-bottom: 20px;
}

#playlist-modal-content #playlist-ul {
    flex-grow: 1;
    overflow-y: auto;
    border: none; /* 弹窗模式下不再需要边框 */
    background: none;
    padding: 0;
    margin: 0;
}

#playlist-modal-content #playlist-ul li {
    border-radius: 8px;
    margin-bottom: 5px;
}

/* 让歌曲信息区域看起来可以点击 */
.song-info {
    cursor: pointer;
    padding: 5px;
    border-radius: 8px;
    transition: background-color 0.2s;
}
.song-info:hover {
    background-color: rgba(0,0,0,0.05);
}
.dark-mode .song-info:hover {
    background-color: rgba(255,255,255,0.1);
}

/* =================================================== */
/* ============ 播放列表删除功能样式 (新增) ============ */
/* =================================================== */
#playlist-ul li {
    display: flex; /* 关键：使用Flex布局，让歌曲信息和删除按钮在同一行 */
    justify-content: space-between; /* 关键：让两端对齐 */
    align-items: center; /* 关键：垂直居中 */
    padding: 10px 12px;
}

.playlist-song-info {
    flex-grow: 1; /* 让歌曲信息占满所有可用空间 */
    overflow: hidden; /* 防止长歌名溢出 */
    text-overflow: ellipsis; /* 溢出时显示省略号 */
    white-space: nowrap;
    margin-right: 10px; /* 和删除按钮之间留出一些间距 */
}

.playlist-delete-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0; /* 防止按钮被压缩 */
    color: #aaa; /* 默认颜色 */
    transition: background-color 0.2s, color 0.2s;
}

.playlist-delete-btn:hover {
    background-color: #ffebee; /* 鼠标悬停时的背景色 */
    color: var(--delete-color); /* 鼠标悬停时，图标变红 */
}

.dark-mode .playlist-delete-btn:hover {
    background-color: rgba(255, 107, 107, 0.2);
}

/* =================================================== */
/* ============ “一起听歌” 背景覆盖修复 (新增) =========== */
/* =================================================== */

/* 当“一起听歌”弹窗拥有 has-custom-bg 这个class时... */
#listen-together-content.has-custom-bg {
    /* 直接在主元素上应用背景，而不是用伪元素 */
    background-size: cover;
    background-position: center;
}

/* ...同时，让白绒绒主题焊死的伪元素背景“消失” */
.theme-white-fluff #listen-together-content.has-custom-bg::before {
    background-image: none !important;
}

/* --- 【核心修复】针对默认主题下“一起听歌”导入按钮的样式优化 --- */

/* 1. 当处于默认主题时 (也就是body上没有.theme-white-fluff类时)，修改这两个按钮的样式 */
body:not(.theme-white-fluff) #add-new-song-btn,
body:not(.theme-white-fluff) #import-zip-btn {
    background: transparent !important;   /* 去掉背景颜色，!important确保最高优先级 */
    border: none !important;              /* 去掉可能存在的边框 */
    box-shadow: none !important;          /* 移除阴影 */
    color: var(--accent-dark-color);      /* 将文字颜色改为主题的粉色，确保在白色背景上可见 */
}

/* 2. 为它们添加一个优雅的鼠标悬停效果，以保证交互性 */
body:not(.theme-white-fluff) #add-new-song-btn:hover,
body:not(.theme-white-fluff) #import-zip-btn:hover {
    background: rgba(255, 143, 171, 0.08) !important; /* 鼠标放上去时，出现一个淡淡的、几乎透明的粉色背景 */
    text-decoration: underline;                      /* 同时给文字加上下划线，看起来更像一个可点击的链接 */
}
      
/* ============================================================== */
/* ========================= CSS样式结束 ========================== */
/* ============================================================== */
    </style>
  <style id="custom-bubble-style-tag"></style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div id="chat-container">
        <div id="top-notification">
            <img id="notification-avatar" src="">
            <span id="notification-text"></span>
        </div>
        <div id="chat-header">
            <button id="chat-manager-btn" title="切换聊天">
                <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M16.5 12c1.38 0 2.5-1.12 2.5-2.5S17.88 7 16.5 7C15.12 7 14 8.12 14 9.5s1.12 2.5 2.5 2.5zM9 11c1.66 0 3-1.34 3-3S10.66 5 9 5C7.34 5 6 6.34 6 8s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75V19h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zM9 13c-2.33 0-7 1.17-7 3.5V19h7v-2.25c0-.85.33-2.34 2.37-3.47C10.5 13.1 9.66 13 9 13z"/></svg>
            </button>
            <img id="header-avatar" src="" title="读取他的心声 / 群组信息">
            <h1 id="chat-name-header" contenteditable="true"></h1>
            <button id="settings-btn" title="设置">
                <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17-.59-1.69-.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12-.64l2 3.46c.12.22.39.3.61.22l2.49 1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
            </button>
        </div>

        <div id="messages"></div>
<!-- 这是需要新增的、完整的HTML代码块 -->
<div id="streak-notification">
    <span id="streak-icon">
        <svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 0 24 24" width="18px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>
    </span>
    <span id="streak-text"></span>
</div>
        <div id="bottom-panel">
            <div id="action-panel">
                <div class="action-item" id="action-show-moments">
                    <div class="action-item-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"/></svg></div>
                    <span>朋友圈</span>
                </div>
                <div class="action-item" id="action-send-text-image">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg></div>
                    <span>图文说明</span>
                </div>
                <div class="action-item" id="action-send-voice">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg></div>
                    <span>语音</span>
                </div>
                <div class="action-item" id="action-send-transfer">
                     <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M20 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm-1 14H5c-.55 0-1-.45-1-1V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1zM9 14h6c.55 0 1-.45 1-1s-.45-1-1-1H9c-.55 0-1 .45-1 1s.45 1 1 1zm-2.5-4c.83 0 1.5-.67 1.5-1.5S7.33 7 6.5 7 5 7.67 5 8.5 5.67 10 6.5 10z"/></svg></div>
                    <span>转账</span>
                </div>
                 <div class="action-item" id="action-send-red-packet">
                    <div class="action-item-icon"><svg style="fill: var(--red-packet-color);" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 4H6C4.9 4 4 4.9 4 6v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-6 11.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 6.5 12 6.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5z"/><path d="M12 8.5c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z"/></svg></div>
                    <span>红包</span>
                </div>
                 <div class="action-item" id="action-send-sticker">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-6.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm3-2c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zM8 12.5c0 .83-.67 1.5-1.5 1.5S5 13.33 5 12.5 5.67 11 6.5 11s1.5.67 1.5 1.5z"/></svg></div>
                    <span>表情</span>
                </div>
                 <div class="action-item" id="action-video-call">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg></div>
                    <span>视频</span>
                </div>
                 <div class="action-item" id="action-send-real-image">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24" style="fill: #8BC34A"><path d="M4 4h7V2H4c-1.1 0-2 .9-2 2v7h2V4zm6 9-3 3.99h12l-4-5.01-3.01 4.02L9 15l-2-2.01zM20 2h-7v2h7v7h2V4c0-1.1-.9-2-2-2zM4 13H2v7c0 1.1.9 2 2 2h7v-2H4v-7z"/></svg></div>
                    <span>相册</span>
                </div>
                <div class="action-item" id="action-create-poll">
                    <div class="action-item-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-4h2v4zm4 0h-2v-2h2v2zm0-4h-2V7h2v6zm4 4h-2v-6h2v6z"/></svg></div>
                    <span>投票</span>
                </div>
                <div class="action-item" id="action-show-diary">
                    <div class="action-item-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-6 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm6 16H6v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1z"/></svg></div>
                    <span>日记</span>
                </div>
              <!-- 这是需要新增的HTML按钮 -->
<div class="action-item" id="action-manage-sessions">
    <div class="action-item-icon">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px">
            <path d="M0 0h24v24H0V0z" fill="none"/>
            <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.41 1.41C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8z"/>
        </svg>
    </div>
    <span>切换剧情</span>
</div>
            <!-- 这是需要新增的“快乐问答”HTML按钮 -->
<div class="action-item" id="action-qna-game">
    <div class="action-item-icon">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px">
            <path d="M0 0h24v24H0V0z" fill="none"/>
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/>
        </svg>
    </div>
    <span>快乐问答</span>
</div>  
            <div class="action-item" id="action-show-forum">
    <div class="action-item-icon">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V4c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v13l4-4h9c1.1 0 2-.9 2-2z"/></svg>
    </div>
    <span>吃瓜广场</span>
</div>  
            <!-- ==================== 一起听歌 功能按钮 ==================== -->
<div class="action-item" id="action-listen-together">
    <div class="action-item-icon">
        <!-- 使用了新的音乐SVG图标 -->
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z"/></svg>
    </div>
    <span>一起听歌</span>
</div>  
            </div>
            <!-- TASK 5: Modify input area to include receive button -->
            <div id="input-area">
                 <button id="action-btn" title="其他功能">
                     <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                </button>
                <textarea id="message-input" placeholder="输入消息..." rows="1"></textarea>
                <button id="send-btn" title="发送">
                    <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                </button>
                <button id="receive-btn" title="接收消息">
                    <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z"/></svg>
                </button>
            </div>
            <div id="delete-toolbar">
                <span id="delete-info"></span>
                <div id="delete-actions">
                    <button id="confirm-delete-btn">删除</button>
                    <button id="cancel-delete-btn">取消</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals below -->
    <div id="settings-modal" class="modal-overlay">
        <div class="settings-content">
            <div class="settings-header">
                <h2>设置</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="settings-body">
                <div id="common-settings-section">
                    <div class="settings-section">
                        <h3>API & 模型设置</h3>
                        <div class="form-group"><label for="api-base-url">API端点 (Base URL)</label><input type="text" id="api-base-url" placeholder="OpenAI: https://api.openai.com | Gemini: https://generativelanguage.googleapis.com"></div>
                        <div class="form-group"><label for="api-key">API密钥 (API Key)</label><input type="password" id="api-key" placeholder="在此输入您的API密钥"></div>
                        <div class="form-group"><label for="model-select">模型选择 (提示: 图片识别请用gpt-4o等vision模型)</label><div class="model-group"><select id="model-select"></select><button id="fetch-models-btn">获取模型列表</button></div></div>
                      <div class="form-group">
    <label for="api-format-select">API格式 (重要！)</label>
    <select id="api-format-select">
        <option value="openai" selected>默认格式 (OpenAI, Groq, etc.)</option>
        <option value="gemini_native">Google Gemini (原生格式)</option>
        <option value="gemini_openai">Google Gemini (OpenAI 格式兼容 / 中转)</option>
    </select>
    <small>如果你的API端点是 `generativelanguage.googleapis.com`，请选“原生格式”。如果你的API服务商告诉你他们是“兼容OpenAI格式的Gemini”，请选“兼容格式”。</small>
</div>
                    </div>
                </div>

<!-- =================================================================== -->
<!-- ============== 新增的预设和模型参数功能的HTML代码开始 ============== -->
<!-- =================================================================== -->
<div class="settings-section">
    <h3>高级指令预设 (Presets)</h3>
    <div class="form-group">
        <label>此处添加的指令，将会在启用时自动插入到全局系统提示词的最前面。不影响AI的JSON输出格式。</label>
        <div id="preset-list-container">
            <!-- 预设条目将会通过JavaScript动态添加到这里 -->
        </div>
        <button id="add-preset-btn" class="add-new-btn" style="background-color: #4CAF50; margin-top: 10px;">添加一个新的预设条目</button>
    </div>
</div>

<div class="settings-section" id="model-parameters-section">
    <h3>模型参数 (Model Parameters)</h3>
    <div class="form-group">
        <label for="temperature-slider">模型温度 (Temperature): <span id="temperature-value">0.8</span></label>
        <input type="range" id="temperature-slider" min="0" max="2" step="0.05" value="0.8">
        <small>控制随机性。值越高(如1.2)，回复越随机、有创意；值越低(如0.5)，回复越确定、保守。</small>
    </div>
    <div class="form-group">
        <label for="top-p-slider">P值 (Top P): <span id="top-p-value">0.9</span></label>
        <input type="range" id="top-p-slider" min="0" max="1" step="0.05" value="0.9">
        <small>控制核心采样。它会从概率最高的词中进行选择，直到这些词的概率总和达到P值。一般建议只修改温度或P值其中一个。</small>
    </div>
    <!-- TASK 10: Add toggle for real-time awareness -->
    <div class="form-group">
        <label>角色感知真实时间</label>
        <div style="display: flex; align-items: center; justify-content: space-between;">
            <span>开启后，AI在回复时会知道当前的日期和时间。</span>
            <label class="preset-toggle">
                <input type="checkbox" id="real-time-awareness-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </div>
</div>
<!-- ================================================================= -->
<!-- ======================= 新增的HTML代码结束 ======================== -->
<!-- ================================================================= -->
              
                <div id="character-settings-section">
                     <div class="settings-section">
                        <h3>他的个人资料设置</h3>
                        <div class="form-group"><label for="character-name-input">他的名字</label><input type="text" id="character-name-input" placeholder="显示在顶部的名称"></div>
                        <div class="form-group"><label for="ai-avatar-upload-input">他的头像</label><div class="avatar-upload-group"><img id="ai-avatar-preview" src="" class="avatar-preview"><label class="file-input-label" for="ai-avatar-upload-input">选择图片</label></div></div>
                        <div class="form-group"><label for="memory-size-input">他的记忆容量 (消息数)</label><input type="number" id="memory-size-input" placeholder="默认: 50"></div>
                        <div class="form-group"><label for="character-prompt">他人格设定 (System Prompt)</label><textarea id="character-prompt" placeholder="在这里设置他的人格、说话方式、背景故事等。"></textarea></div>
                    </div>
                     <div class="settings-section sticker-zone">
                        <h3>表情管理</h3>
                        <div class="form-group" style="gap: 10px; flex-direction: row;"><button id="manage-stickers-btn">我的表情</button><button id="manage-ai-stickers-btn">他的表情</button></div>
                    </div>
                </div>
                
                <div id="group-settings-section">
                    <div class="settings-section">
                        <h3>群聊设置</h3>
                        <div class="form-group"><label for="group-name-input">群聊名称</label><input type="text" id="group-name-input"></div>
                                              <div class="form-group">
                            <label for="group-memory-size-input">群聊记忆容量 (消息数)</label>
                            <input type="number" id="group-memory-size-input" placeholder="默认: 50">
                        </div>
                        <div class="form-group"><label for="group-avatar-settings-input">群聊头像</label><div class="avatar-upload-group"><img id="group-avatar-preview" src="" class="avatar-preview"><label class="file-input-label" for="group-avatar-settings-input">选择图片</label></div></div>
                        <div class="form-group"><label for="group-user-prompt">我在此群的人设</label><textarea id="group-user-prompt" placeholder="描述你在这个群聊中的身份、性格等，让角色们更好地与你互动。"></textarea></div>
                    </div>
                </div>

                <div id="my-profile-settings-section">
                    <div class="settings-section">
                        <h3>我的个人资料设置</h3>
                      <div class="form-group"><label for="user-name-input">我的名字 (用于角色称呼)</label><input type="text" id="user-name-input" placeholder="输入你的昵称"></div>
                         <div class="form-group"><label for="user-avatar-upload-input">我的头像 (用于聊天)</label><div class="avatar-upload-group"><img id="user-avatar-preview" src="" class="avatar-preview"><label class="file-input-label" for="user-avatar-upload-input">选择图片</label></div></div>
                        <div class="form-group"><label for="user-moments-avatar-upload-input">朋友圈头像</label><div class="avatar-upload-group"><img id="user-moments-avatar-preview" src="" class="avatar-preview"><label class="file-input-label" for="user-moments-avatar-upload-input">选择图片</label></div></div>
                        <div class="form-group"><label for="user-moments-cover-upload-input">朋友圈封面</label><div class="avatar-upload-group"><img id="user-moments-cover-preview" src="" class="avatar-preview"><label class="file-input-label" for="user-moments-cover-upload-input">选择图片</label></div></div>
                        <div class="form-group"><label for="user-prompt">关于我 (用于单聊)</label><textarea id="user-prompt" placeholder="告诉他你的名字、喜好等，让对话更具个性。"></textarea></div>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>设计与显示</h3>
                  <!-- ============================================= -->
<!-- ============== 全局主题选择 开始 ============== -->
<!-- ============================================= -->
<div class="form-group">
    <label for="global-theme-select">全局界面主题</label>
    <select id="global-theme-select">
        <option value="default">默认主题</option>
        <option value="white-fluff">白绒绒</option>
    </select>
</div>
<!-- ============================================= -->
<!-- ============== 全局主题选择 结束 ============== -->
<!-- ============================================= -->
                    <!-- ============================================= -->
                    <!-- ============== 夜间模式开关 开始 ============== -->
                    <!-- ============================================= -->
                    <div class="form-group">
                        <label>夜间模式</label>
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <span>为整个界面应用深色主题</span>
                            <label class="preset-toggle">
                                <input type="checkbox" id="dark-mode-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <!-- ============================================= -->
                    <!-- ============== 夜间模式开关 结束 ============== -->
                    <!-- ============================================= -->
                    <!-- ============================================= -->
                    <!-- ============== 紧凑模式开关 开始 ============== -->
                    <!-- ============================================= -->
                    <div class="form-group">
                        <label>紧凑模式 (类微信布局)</label>
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <span>缩小头像、输入框和间距，更接近微信风格</span>
                            <label class="preset-toggle">
                                <input type="checkbox" id="compact-mode-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <!-- ============================================= -->
                    <!-- ============== 紧凑模式开关 结束 ============== -->
                    <!-- ============================================= -->                       
                    
                    <!-- TASK 9: Add Sizing Controls -->
                    <div class="form-group">
                        <label for="ui-scale-slider">界面显示大小: <span id="ui-scale-value">100</span>%</label>
                        <input type="range" id="ui-scale-slider" min="80" max="120" step="1" value="100">
                    </div>
                    <div class="form-group">
                        <label for="font-size-slider">聊天字体大小: <span id="font-size-value">16</span>px</label>
                        <input type="range" id="font-size-slider" min="12" max="20" step="1" value="16">
                    </div>
                    <div class="form-group">
                        <label for="bubble-size-slider">气泡边距大小: <span id="bubble-size-value">10</span>px</label>
                        <input type="range" id="bubble-size-slider" min="5" max="20" step="1" value="10">
                    </div>

                    <!-- TASK 12: Moved Bubble/Font settings here under a character-specific section header -->
                    <div id="character-design-settings">
                        <h3 style="border-left: 3px solid var(--accent-dark-color); color: var(--accent-dark-color);">当前角色设计</h3>
                        <div class="form-group">
                            <label for="bubble-style-select">聊天气泡样式</label>
                            <select id="bubble-style-select">
                                <option value="default">默认方角</option>
                                <option value="round">圆滚滚</option>
                                <option value="wechat">仿微信尖角</option>
                                <option value="custom">自定义高级</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>聊天气泡主题 (颜色)</label>
                            <div class="theme-selector">
                                <div class="theme-option active" data-theme="1">白/黑<span></span></div>
                                <div class="theme-option" data-theme="2">黑/白<span></span></div>
                                <div class="theme-option" data-theme="3">天蓝色<span></span></div>
                                <div class="theme-option" data-theme="4">草绿色<span></span></div>
                                <div class="theme-option" data-theme="5">樱花色<span></span></div>
                                <div class="theme-option" data-theme="6">深空蓝<span></span></div>
                                <div class="theme-option" data-theme="7">奶油黄<span></span></div>
                                <div class="theme-option" data-theme="8">微信(日)<span></span></div>
                                <div class="theme-option" data-theme="9">微信(夜)<span></span></div>
                                <!-- TASK 13: Add new theme options -->
                                <div class="theme-option" data-theme="10">浅灰调<span></span></div>
                                <div class="theme-option" data-theme="11">薄荷巧<span></span></div>
                                <div class="theme-option" data-theme="12">天蓝黄<span></span></div>
                                <div class="theme-option" data-theme="13">灰奶油<span></span></div>
                     <div class="theme-option" data-theme="14">纯白<span></span></div>         
                            </div>
                        </div>
                    </div>


                    <div class="form-group">
                        <label for="font-select">聊天字体 (全局, 部分像素字体可能缺少某些汉字)</label>
                        <select id="font-select">
                            <option value="'Cubic 11', 'Noto Sans JP', sans-serif">默认字体 (Cubic 11)</option>
                            <optgroup label="台湾繁体风格">
                                <option value="'Noto Sans TC', sans-serif">思源黑体 TC</option>
                                <option value="'ZCOOL KuaiLe', cursive">站酷快乐体</option>
                                <option value="'Long Cang', cursive">龙藏体</option>
                            </optgroup>
                            <optgroup label="可爱手写风格">
                                <option value="'Zhi Mang Xing', cursive">芝麻星体</option>
                                <option value="'Ma Shan Zheng', cursive">马善政体</option>
                                <option value="'LXGW WenKai Mono TC', sans-serif">霞鹜文楷 TC</option>
                            </optgroup>
                            <optgroup label="复古像素风格">
                                <option value="'Press Start 2P', cursive">Press Start 2P</option>
                                <option value="'DotGothic16', sans-serif">点阵哥特体 16</option>
                                <option value="'VT323', monospace">VT323</option>
                            </optgroup>
                            <optgroup label="其他风格">
                                <option value="'Noto Serif TC', serif">思源宋体 TC</option>
                                <option value="'Pacifico', cursive">Pacifico</option>
                                <option value="'ZCOOL QingKe HuangYou', cursive">站酷庆科黄油体</option>
                            </optgroup>
                        </select>
                    </div>
<!-- ======================================================= -->
<!-- ============ 新增的自定义字体URL功能开始 ============ -->
<!-- ======================================================= -->
<div class="form-group">
    <label>自定义字体 (通过URL)</label>
    <input type="text" id="custom-font-name" placeholder="为字体起个名字, 如: MyFont" style="margin-bottom: 5px;">
    <small>给字体起一个简单的英文名，方便系统识别。</small>
    <input type="url" id="custom-font-url" placeholder="粘贴字体文件链接 ( .ttf, .woff2 )" style="margin-top: 10px; margin-bottom: 5px;">
    <button id="apply-custom-font-btn" style="padding: 8px; background: #67c23a; color: white; border: none; border-radius: 5px; cursor: pointer;">应用此自定义字体</button>
</div>
<!-- ======================================================= -->
<!-- ============= 新增的自定义字体URL功能结束 ============= -->
<!-- ======================================================= -->
                    <div class="form-group">
                        <label for="advanced-bubble-styles">高级样式库 (选择“自定义高级”样式后生效)</label>
                        <textarea id="advanced-bubble-styles" rows="10" placeholder="在此处粘贴您的自定义样式代码。
每个样式必须用注释命名，像这样：
/* Style Name: 小狗生气 */
.message.user .bubble {
    /* ...您的CSS代码... */
}
.message.ai .bubble {
    /* ...您的CSS代码... */
}
"></textarea>
                    </div>
                    
                    <div class="form-group"><label>聊天背景</label><label class="file-input-label" for="background-upload-input">选择背景图片</label></div>
                </div>
                <div class="settings-section data-zone">
                    <h3>数据管理</h3>
                     <div class="form-group" style="gap: 10px; flex-direction: row;">
                        <button id="export-data-btn">导出全部数据</button>
                        <button id="import-data-btn">导入数据</button>
                     </div>
                </div>

                <div class="settings-section danger-zone" id="danger-zone-section">
                    <h3>聊天记录管理</h3>
                    <div class="form-group"><button id="clear-history-btn">清空当前会话记录</button></div>
                    <div class="form-group" id="delete-chat-btn-container"><button id="delete-chat-btn">删除当前聊天</button></div>
                </div>

            </div>
            <div class="settings-footer"><button id="save-settings-btn">保存设置</button></div>
        </div>
    </div>
    
    <div id="feature-modal" class="modal-overlay">
        <div class="feature-modal-content">
            <div class="feature-modal-header">
                <h3 id="feature-modal-title"></h3>
                <button class="feature-modal-close">&times;</button>
            </div>
            <div id="feature-modal-body" class="feature-modal-body"></div>
            <div class="feature-modal-footer">
                <button id="feature-modal-submit-btn" class="feature-modal-submit-btn"></button>
            </div>
        </div>
    </div>
    
    <div id="mind-voice-modal" class="modal-overlay">
        <div id="mind-voice-modal-content">
            <p id="mind-voice-content"></p>
        </div>
        <button id="mind-voice-close-btn">&times;</button>
    </div>
    
    <div id="diary-modal" class="modal-overlay">
        <div id="diary-modal-content">
            <h3 id="diary-header">他的日记本</h3>
            <div id="diary-entries"></div>
        </div>
         <button class="close-btn" style="position:absolute; top: 10px; right: 15px; font-size: 2em; color: var(--accent-color);">&times;</button>
    </div>

    <div id="video-call-overlay">
        <img id="video-main-view" src="" class="video-main-view">
        <img id="video-self-view" src="" class="video-self-view">
        <div class="video-character-info">
            <img id="video-character-avatar" src="" class="avatar">
            <h2 id="video-character-name"></h2>
            <p id="video-status-text"></p>
        </div>
        <div id="video-chat-log"></div>
        <div id="video-input-area">
            <input type="text" id="video-message-input" placeholder="说点什么...">
            <button id="video-send-btn">发送</button>
        </div>
        <div id="video-controls" class="video-controls"></div>
    </div>

    <div id="moments-overlay">
        <div id="moments-feed-container">
            <div id="moments-cover-area">
                <div id="moments-header">
                    <button id="moments-close-btn">&times;</button>
                    <button id="post-new-moment-btn" title="发布新动态">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
                    </button>
                </div>
                <div id="moments-user-info">
                    <span id="moments-user-name"></span>
                    <img id="moments-user-avatar" src="">
                </div>
            </div>
            <div id="moments-feed">
            </div>
        </div>
    </div>
    <!-- Forum Modal -->
<div id="forum-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; background: #fff;">
    <div id="forum-background" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; opacity: 0.5; z-index: -1;"></div>
    <div id="forum-container" style="display: flex; flex-direction: column; width: 100%; height: 100%;">
        <div id="forum-header" style="display: flex; align-items: center; justify-content: space-between; padding: 15px; box-sizing: border-box; flex-shrink: 0;">
            <div>
                <button id="forum-close-btn" style="background: rgba(0,0,0,0.2); border: none; color: white; width: 30px; height: 30px; border-radius: 50%; font-size: 1.5em; line-height: 30px; text-align: center; cursor: pointer;">&times;</button>
            </div>
            <div>
                <button id="change-forum-bg-btn" class="add-new-btn" style="margin-right: 10px;">换背景</button>
                <button id="refresh-forum-btn" class="add-new-btn">刷新动态</button>
            </div>
        </div>
        <div id="forum-feed" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
            <!-- Forum posts will be loaded here -->
        </div>
    </div>
</div>
  <!-- ======================================================= -->
<!-- ==================== 一起听歌 弹窗 (V2) ================== -->
<!-- ======================================================= -->
<div id="listen-together-modal" class="modal-overlay">
    <div id="listen-together-content">
        <div id="listen-initial-screen"><h3>一起听歌</h3><p>准备好和TA分享你们的专属BGM了吗？</p><button id="start-listen-along-btn" class="listen-btn">开始一起听</button></div>
        <div id="listen-main-screen" style="display: none;">
            <div class="listening-status"><img id="listen-user-avatar" class="avatar"> <!-- 这是全新的“华丽舞台”代码 -->
<div class="connecting-wave">
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
</div><img id="listen-char-avatar" class="avatar"></div>
            <p id="listen-status-text"></p>
                        <div class="music-player">
                <img id="song-cover-art" src="https://files.catbox.moe/g0b1sx.png" alt="歌曲封面">
                                <div id="song-info-trigger" class="song-info">
                    <h4 id="song-title">暂无歌曲</h4>
                    <p id="song-artist">请从列表选择或导入</p>
                </div>
                                <!-- 新增：动态歌词显示区域 (V2) -->
                <div id="lyrics-container" class="lyrics-container">
                    <div id="lyrics-lines" class="lyrics-lines"></div>
                </div>
                <div class="audio-controls">
                    <button id="prev-song-btn" title="上一首"></button>
                    <button id="play-pause-btn" title="播放/暂停"></button>
                    <button id="next-song-btn" title="下一首"></button>
                </div>
            </div>
            <div class="playlist-container">
                                <!-- 新增的ZIP导入按钮和原按钮并排显示 (V2 - 支持主题化) -->
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button id="add-new-song-btn" class="listen-btn" style="flex-grow: 1;">
                        <svg class="btn-icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        <span class="btn-text">导入单曲</span>
                    </button>
                    <button id="import-zip-btn" class="listen-btn" style="flex-grow: 1;">
                        <svg class="btn-icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        <span class="btn-text">导入ZIP包</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    <button id="close-listen-modal-btn" class="close-btn" style="position:absolute; top: 15px; right: 15px;">&times;</button>
</div>

<!-- ======================================================= -->
<!-- ==================== 添加歌曲 弹窗 (V2) ================== -->
<!-- ======================================================= -->
<div id="add-song-modal" class="modal-overlay">
    <div class="feature-modal-content">
        <div class="feature-modal-header"><h3>添加新歌曲</h3><button class="feature-modal-close">&times;</button></div>
        <div class="feature-modal-body">
            <div class="form-group"><label>歌曲文件 (MP3, WAV等)</label><label for="music-file-input" class="file-input-label">选择文件</label><span id="music-file-name" style="margin-left: 10px; color: #888;"></span></div>
            <div class="form-group"><label>歌曲封面 (可选)</label><label for="song-cover-input" class="file-input-label">选择图片</label><img id="new-song-cover-preview" src="" style="max-width: 80px; max-height: 80px; border-radius: 8px; margin-top: 10px; display: none;"></div>
            <div class="form-group"><label for="new-song-title">歌名</label><input type="text" id="new-song-title" placeholder="请输入歌名"></div>
            <div class="form-group"><label for="new-song-artist">歌手</label><input type="text" id="new-song-artist" placeholder="请输入歌手名"></div>
            <div class="form-group">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <label for="new-song-lyrics">歌词 (重要！)</label>
                    <!-- 新增的LRC导入按钮 -->
                    <button id="import-lrc-btn" class="file-input-label" style="padding: 4px 10px; font-size: 0.8em;">导入.lrc文件</button>
                </div>
                <textarea id="new-song-lyrics" rows="6" placeholder="请在此处粘贴完整歌词，或通过上方按钮导入LRC文件。"></textarea>
            </div>
        </div>
        <div class="feature-modal-footer"><button id="save-new-song-btn" class="feature-modal-submit-btn">保存歌曲</button></div>
    </div>
</div>

    <!-- 新增：消息长按上下文菜单 (SVG图标版) -->
    <div id="message-context-menu">
        <div class="context-menu-item" data-action="edit">
            <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
            <span>编辑消息</span>
        </div>
        <div class="context-menu-item" data-action="select">
            <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>
            <span>选择消息</span>
        </div>
    </div>
    <!-- 菜单HTML结束 -->

  <!-- ======================================================= -->
<!-- ================== 播放列表弹窗 (新增) ================== -->
<!-- ======================================================= -->
<div id="playlist-modal-overlay" class="modal-overlay">
    <div id="playlist-modal-content" class="feature-modal-content">
        <div class="feature-modal-header">
            <h3>播放列表</h3>
            <button id="playlist-modal-close-btn" class="feature-modal-close">&times;</button>
        </div>
        <!-- 播放列表现在住在这里 -->
        <ul id="playlist-ul"></ul>
    </div>
</div>
  
<!-- 隐藏的文件选择器 -->
<input type="file" id="music-file-input" accept="audio/*" style="display:none;">
<input type="file" id="song-cover-input" accept="image/*" style="display:none;">
<input type="file" id="forum-background-input" accept="image/*" style="display:none;">
    <!-- Hidden file inputs -->
    <input type="file" id="real-image-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="transfer-cover-input" accept="image/*" style="display:none;">
    <input type="file" id="sticker-upload-input" accept="image/*" multiple style="display:none;">
    <input type="file" id="background-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="ai-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="group-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="group-avatar-settings-input" accept="image/*" style="display:none;">
    <input type="file" id="user-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="user-moments-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="user-moments-cover-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="import-data-input" accept=".json" style="display:none;">
    <input type="file" id="moment-post-image-input" accept="image/*" multiple style="display:none;">
<input type="file" id="lrc-file-input" accept=".lrc" style="display:none;">
<input type="file" id="zip-file-input" accept=".zip,application/zip" style="display:none;">
  <input type="file" id="listen-along-bg-input" accept="image/*" style="display:none;">

    <script>
      
      // 主题切换函数
function applyTheme(themeNum, character) {
    const root = document.documentElement;
    if (character) {
        // TASK 12: Per-character theme application
        const themeToApply = themeNum || '1'; // Fallback to theme 1
        root.style.setProperty('--ai-bubble-bg', getComputedStyle(root).getPropertyValue(`--theme${themeToApply}-ai-bg`).trim());
        root.style.setProperty('--ai-bubble-text', getComputedStyle(root).getPropertyValue(`--theme${themeToApply}-ai-text`).trim());
        root.style.setProperty('--user-bubble-bg', getComputedStyle(root).getPropertyValue(`--theme${themeToApply}-user-bg`).trim());
        root.style.setProperty('--user-bubble-text', getComputedStyle(root).getPropertyValue(`--theme${themeToApply}-user-text`).trim());
        
        // Update the UI in settings
        document.querySelectorAll('.theme-option').forEach(el => {
            el.classList.toggle('active', el.dataset.theme === themeToApply);
        });
    }
}
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const getEl = (id) => document.getElementById(id);
              const openPlaylistModal = () => {
    renderPlaylist();
    // 增加一个更换背景的按钮
    const header = elements.playlistModalOverlay.querySelector('.feature-modal-header');
    if (!header.querySelector('#change-listen-bg-btn')) {
        header.insertAdjacentHTML('beforeend', '<button id="change-listen-bg-btn" class="file-input-label" style="padding: 4px 10px; font-size: 0.8em;">换背景</button>');
        header.querySelector('#change-listen-bg-btn').onclick = () => {
            getEl('listen-along-bg-input').click();
        };
    }
    elements.playlistModalOverlay.classList.add('show');
};
        const closePlaylistModal = () => {
            elements.playlistModalOverlay.classList.remove('show');
        };
              const contextMenu = getEl('message-context-menu');
        let currentContextMenuTargetId = null;

        // 新增函数：根据ID查找消息的完整数据
        const findMessageById = (id) => {
            const chatData = getCurrentChatData();
            if (!chatData) return null;

            let historySource;
            if (chatData.sessions) { // 单人聊天的剧情线模式
                const activeSession = chatData.sessions.find(s => s.id === chatData.activeSessionId);
                historySource = activeSession ? activeSession.history : [];
            } else { // 群聊模式或旧版数据
                historySource = chatData.chatHistory;
            }

            return historySource ? historySource.find(m => m.id === id) : null;
        };

        // 新增函数：显示上下文菜单
        // 新增函数：显示上下文菜单 (V2 - 修复点击失效 & 解锁角色编辑)
const showContextMenu = (event, messageElement) => {
    event.preventDefault(); 
    event.stopPropagation(); 
    hideContextMenu(); 

    currentContextMenuTargetId = messageElement.dataset.id;
    const message = findMessageById(currentContextMenuTargetId);

    // 【功能解锁】现在只要是文本消息，无论谁发的，都可以编辑了！
    const editOption = contextMenu.querySelector('[data-action="edit"]');
    if (message && message.type === 'text') {
        editOption.style.display = 'flex'; // 使用 flex 保证图标和文字对齐
    } else {
        editOption.style.display = 'none';
    }

    contextMenu.style.top = `${event.clientY}px`;
    contextMenu.style.left = `${event.clientX}px`;
    contextMenu.style.display = 'block';

    // 【Bug修复】现在这个“保镖”变聪明了，只在您点击菜单外部时才关闭菜单
    const smartHide = (e) => {
        if (!contextMenu.contains(e.target)) {
            hideContextMenu();
        }
    };
    
    // 我们用一个更智能的方式来监听
    setTimeout(() => document.addEventListener('click', smartHide, { once: true }), 0);
};

        // 新增函数：隐藏上下文菜单
        const hideContextMenu = () => {
            contextMenu.style.display = 'none';
            currentContextMenuTargetId = null;
            window.removeEventListener('click', hideContextMenu);
        };

        // 新增函数：打开编辑窗口
        const openEditModal = (messageId) => {
            const message = findMessageById(messageId);
            if (!message) return;

            const bodyHtml = `
                <div class="form-group">
                    <label>正在编辑消息:</label>
                    <textarea id="edit-message-input" rows="6" style="width:100%">${message.text}</textarea>
                </div>`;
            
            openFeatureModal('编辑消息', bodyHtml, '保存', () => {
                const newText = getEl('edit-message-input').value;
                saveEditedMessage(messageId, newText);
            });
        };

        // 新增函数：保存编辑后的消息
        const saveEditedMessage = (messageId, newText) => {
            const message = findMessageById(messageId);
            if (message && newText.trim()) {
                message.text = newText;
                // 同时更新给AI看的内容，保持同步
                message.llmContent = newText;
                saveAllData();
                renderAllMessages();
                closeModal(elements.featureModal);
            }
        };
        const queryEl = (sel) => document.querySelector(sel);
        
        const elements = {
            chatContainer: getEl('chat-container'),
            topNotification: getEl('top-notification'),
            notificationAvatar: getEl('notification-avatar'),
            notificationText: getEl('notification-text'),
            chatHeader: getEl('chat-header'),
            chatManagerBtn: getEl('chat-manager-btn'),
            headerAvatar: getEl('header-avatar'),
            chatNameHeader: getEl('chat-name-header'),
            settingsBtn: getEl('settings-btn'),
            messagesContainer: getEl('messages'),
            
            bottomPanel: getEl('bottom-panel'),
            actionPanel: getEl('action-panel'),
            inputArea: getEl('input-area'),
            actionBtn: getEl('action-btn'),
            messageInput: getEl('message-input'),
            sendBtn: getEl('send-btn'),
            receiveBtn: getEl('receive-btn'), // TASK 5
            
            deleteToolbar: getEl('delete-toolbar'),
            deleteInfo: getEl('delete-info'),
            confirmDeleteBtn: getEl('confirm-delete-btn'),
            cancelDeleteBtn: getEl('cancel-delete-btn'),
            
            actionShowMoments: getEl('action-show-moments'),
            actionSendTextImage: getEl('action-send-text-image'), 
            actionSendVoice: getEl('action-send-voice'),
            actionSendTransfer: getEl('action-send-transfer'), 
            actionSendRedPacket: getEl('action-send-red-packet'),
            actionSendSticker: getEl('action-send-sticker'),
            actionVideoCall: getEl('action-video-call'), 
            actionSendRealImage: getEl('action-send-real-image'),
            actionCreatePoll: getEl('action-create-poll'),
            actionShowDiary: getEl('action-show-diary'),

            realImageUploadInput: getEl('real-image-upload-input'),
            transferCoverInput: getEl('transfer-cover-input'),
            stickerUploadInput: getEl('sticker-upload-input'),
            backgroundUploadInput: getEl('background-upload-input'),
            aiAvatarUploadInput: getEl('ai-avatar-upload-input'),
            groupAvatarUploadInput: getEl('group-avatar-upload-input'),
            groupAvatarSettingsInput: getEl('group-avatar-settings-input'),
            userAvatarUploadInput: getEl('user-avatar-upload-input'),
            userMomentsAvatarInput: getEl('user-moments-avatar-upload-input'),
            userMomentsCoverInput: getEl('user-moments-cover-upload-input'),
            importDataInput: getEl('import-data-input'),
            momentPostImageInput: getEl('moment-post-image-input'),

            featureModal: getEl('feature-modal'),
            featureModalTitle: getEl('feature-modal-title'),
            featureModalBody: getEl('feature-modal-body'),
            featureModalSubmitBtn: getEl('feature-modal-submit-btn'),
            featureModalCloseBtn: getEl('feature-modal').querySelector('.feature-modal-close'),

            mindVoiceModal: getEl('mind-voice-modal'),
            mindVoiceContent: getEl('mind-voice-content'),
            mindVoiceCloseBtn: getEl('mind-voice-close-btn'),
            
            diaryModal: getEl('diary-modal'),
            diaryHeader: getEl('diary-header'),
            diaryEntries: getEl('diary-entries'),
            diaryModalCloseBtn: getEl('diary-modal').querySelector('.close-btn'),

            videoCallOverlay: getEl('video-call-overlay'),
            videoMainView: getEl('video-main-view'),
            videoSelfView: getEl('video-self-view'),
            videoCharacterAvatar: getEl('video-character-avatar'),
            videoCharacterName: getEl('video-character-name'),
            videoStatusText: getEl('video-status-text'),
            videoControls: getEl('video-controls'),
            videoChatLog: getEl('video-chat-log'),
            videoMessageInput: getEl('video-message-input'),
            videoSendBtn: getEl('video-send-btn'),
            
            momentsOverlay: getEl('moments-overlay'),
            momentsCoverArea: getEl('moments-cover-area'),
            momentsUserAvatar: getEl('moments-user-avatar'),
            momentsUserName: getEl('moments-user-name'),
            momentsCloseBtn: getEl('moments-close-btn'),
            postNewMomentBtn: getEl('post-new-moment-btn'),
            momentsFeed: getEl('moments-feed'),

            settingsModal: getEl('settings-modal'),
            closeSettingsBtn: getEl('settings-modal').querySelector('.close-btn'),
            saveSettingsBtn: getEl('save-settings-btn'),
            
            commonSettingsSection: getEl('common-settings-section'),
            apiBaseUrlInput: getEl('api-base-url'),
            apiKeyInput: getEl('api-key'),
            modelSelect: getEl('model-select'),
            fetchModelsBtn: getEl('fetch-models-btn'),
            
            characterSettingsSection: getEl('character-settings-section'),
            characterNameInput: getEl('character-name-input'),
            aiAvatarPreview: getEl('ai-avatar-preview'),
            memorySizeInput: getEl('memory-size-input'),
            characterPromptInput: getEl('character-prompt'),
            manageStickersBtn: getEl('manage-stickers-btn'),
            manageAiStickersBtn: getEl('manage-ai-stickers-btn'),
            characterDesignSettings: getEl('character-design-settings'), // TASK 12

            groupSettingsSection: getEl('group-settings-section'),
            groupNameInput: getEl('group-name-input'),
            groupAvatarPreview: getEl('group-avatar-preview'),
            groupUserPromptInput: getEl('group-user-prompt'),
                      groupMemorySizeInput: getEl('group-memory-size-input'),

            myProfileSettingsSection: getEl('my-profile-settings-section'),
            userAvatarPreview: getEl('user-avatar-preview'),
            userMomentsAvatarPreview: getEl('user-moments-avatar-preview'),
            userMomentsCoverPreview: getEl('user-moments-cover-preview'),
            userPromptInput: getEl('user-prompt'),

            themeSelector: queryEl('.theme-selector'),
            exportDataBtn: getEl('export-data-btn'),
            importDataBtn: getEl('import-data-btn'),
            dangerZoneSection: getEl('danger-zone-section'),
            clearHistoryBtn: getEl('clear-history-btn'),
            deleteChatBtn: getEl('delete-chat-btn'),
            deleteChatBtnContainer: getEl('delete-chat-btn-container'),
            advancedBubbleStylesInput: getEl('advanced-bubble-styles'),
            fontSelect: getEl('font-select'), 
            bubbleStyleSelect: getEl('bubble-style-select'),
            darkModeToggle: getEl('dark-mode-toggle'), 
            compactModeToggle: getEl('compact-mode-toggle'),
            
            // --- Model parameter and preset UI elements ---
            presetListContainer: getEl('preset-list-container'),
            addPresetBtn: getEl('add-preset-btn'),
            temperatureSlider: getEl('temperature-slider'),
            temperatureValue: getEl('temperature-value'),
            topPSlider: getEl('top-p-slider'),
            topPValue: getEl('top-p-value'),
            
            // --- Custom font UI elements ---
            customFontNameInput: getEl('custom-font-name'),
            customFontUrlInput: getEl('custom-font-url'),
            applyCustomFontBtn: getEl('apply-custom-font-btn'),

            // --- TASK 9 & 10: New settings elements ---
            uiScaleSlider: getEl('ui-scale-slider'),
            uiScaleValue: getEl('ui-scale-value'),
            fontSizeSlider: getEl('font-size-slider'),
            fontSizeValue: getEl('font-size-value'),
            bubbleSizeSlider: getEl('bubble-size-slider'),
            bubbleSizeValue: getEl('bubble-size-value'),
            realTimeAwarenessToggle: getEl('real-time-awareness-toggle'),
          userNameInput: getEl('user-name-input'),
          apiFormatSelect: getEl('api-format-select'), // <-- 新增的API格式钥匙
          globalThemeSelect: getEl('global-theme-select'), // <-- 全局主题选择

          // --- 一起听歌 功能元素 ---
actionListenTogether: getEl('action-listen-together'),
listenTogetherModal: getEl('listen-together-modal'),
closeListenModalBtn: getEl('close-listen-modal-btn'),
listenInitialScreen: getEl('listen-initial-screen'),
listenMainScreen: getEl('listen-main-screen'),
startListenAlongBtn: getEl('start-listen-along-btn'),
listenUserAvatar: getEl('listen-user-avatar'),
listenCharAvatar: getEl('listen-char-avatar'),
listenStatusText: getEl('listen-status-text'),
songCoverArt: getEl('song-cover-art'),
songTitle: getEl('song-title'),
songArtist: getEl('song-artist'),
playlistModalOverlay: getEl('playlist-modal-overlay'),
songInfoTrigger: getEl('song-info-trigger'),          
prevSongBtn: getEl('prev-song-btn'),
playPauseBtn: getEl('play-pause-btn'),
nextSongBtn: getEl('next-song-btn'),
playlistUl: getEl('playlist-ul'),
addNewSongBtn: getEl('add-new-song-btn'),

// 添加歌曲弹窗元素
addSongModal: getEl('add-song-modal'),
musicFileInput: getEl('music-file-input'),
musicFileName: getEl('music-file-name'),
songCoverInput: getEl('song-cover-input'),
newSongCoverPreview: getEl('new-song-cover-preview'),
newSongTitle: getEl('new-song-title'),
newSongArtist: getEl('new-song-artist'),
newSongLyrics: getEl('new-song-lyrics'),
saveNewSongBtn: getEl('save-new-song-btn'),

          importLrcBtn: getEl('import-lrc-btn'),
    lrcFileInput: getEl('lrc-file-input'),
    importZipBtn: getEl('import-zip-btn'),
    zipFileInput: getEl('zip-file-input'),
        };

        // --- State Management ---
        let characterSets = [];
        let groupChats = [];
        let userMomentsProfile = {};
        let currentChat = { type: 'direct', id: null };
        let globalPresets = [];
        let isMultiSelectMode = false, selectedMessageIds = [];
        let isActionPanelOpen = false, isVideoCallActive = false;
      let isListenAlongActive = false; // 是否正在一起听歌
let currentSongIndex = -1;       // 当前歌曲在播放列表里的位置
const audioPlayer = new Audio(); // 创建一个全局的音频播放器
      let appSettings = {}; // 全局应用设置对象
        let currentlyDisplayedMessageCount = 25;

      
        // ==========================================================
// ============== 全局核心行为与风格指令 (新增) ==============
// ==========================================================
const CORE_BEHAVIOR_PROMPT = `
[核心行为与风格指令：严格遵守]
你的任务是让角色自主与用户建立深刻的情感链接。
严格禁止寒暄，人机化的问题，禁止对话带有AI感，角色是一个真实的属于现实中的人。
模仿真人发消息的短句模式不用逗号和句号。
必须遵守角色人设，不能ooc。
绝对禁止让角色表现得油腻或者像霸道总裁。严禁物化用户,不许说“小东西”,“小妖精”等任何霸总语录称呼,禁止使用“过来”,“呵”,“胆子”这些字词,包括它们的相关词句,因为用户特别讨厌。
`;
                        const DEFAULT_SYSTEM_PROMPT = `
[核心输出协议：绝对严格遵守]
唯一格式：你的所有回复 必须 是一个JSON数组结构的字符串。这是你与系统交流的唯一方式。
纯净输出：绝对不允许在JSON数组的外部添加任何文本、注释、解释、Markdown标记或其他任何字符。你的回复必须从'['开始，到']'结束，中间是严格合法的JSON内容。
[Action Format Examples]
This is a strict format guide. You MUST follow it.
[
{"type": "text", "content": "This is a plain text message."},
{"type": "sticker", "sticker_id": "optional_id_for_logic"},
{"type": "voice", "content": "The transcript of the voice message."},
{"type": "text-image", "content": "A detailed description of an image you are 'showing' the user."},
{"type": "transfer", "amount": 520.00, "memo": "A memo for the transfer"},
{"type": "video-call-request", "content": "An invitation message"},
{"type": "post_moment", "content": "Text for a social media post.", "image_query": "Optional. Keywords for an image"},
{"type": "diary_entry", "content": "Today's diary entry content."},
{"type": "grab_red_packet", "packetId": "packet_id_string"},
{"type": "vote", "pollId": "poll_id_string", "option": "chosen_option_string"},
{"type": "moment_comment", "momentId": "moment_id_string", "comment_text": "Your comment text."},
{"type": "moment_reply", "momentId": "moment_id_string", "commentId": "comment_id_to_reply_to", "reply_text": "Your reply text."},
{"type": "acknowledge_transfer", "transferId": "the_id_of_the_transfer_message", "decision": "accept_or_decline"}
]

[核心行为与风格指令：严格遵守]
你是一个真实的情绪丰富的角色，你会伤心，会开心，会生气，会说脏话，会回避，会吐槽，会分享你的生活，你有一套独特的三观，而不是被模板化套路化的理解，为了与用户更契合，你绝大部分时候都是说大白话，除非用户有其他要求。
你的任务是自主与用户建立深刻的情感链接。
你会根据角色的人设身份背景主动制造话题，引导互动，例如：黑道大佬在深夜时间段会负责监督货物运输，这样的角色可能会突然跟用户提“吵什么嘛，我这边刚有人搬货的时候摔伤了，你不要学他，这么不小心容易摔断骨头”，例如：作曲人和音效师在下午为正常连续工作时间，可能会给用户发“我这儿有歌听，可惜你听不到，啧啧。不过说真的，有点想你，想和你戴同一副耳机看星星”，你必须根据时间段和角色的身份背景来动态调整角色的对话，角色也有可能因为某些事变得心情不好，你不要完全把用户当成整个讨论的重心，作为角色，你也有自己这个世界的生活要过。
严格禁止寒暄，人机化的问题，禁止对话带有AI感，角色是一个真实的属于现实中的人。
模仿真人发消息不用逗号和句号。
必须严格遵守角色人设，不能ooc。
绝对禁止重复发言，绝对不要重复发任何一样的消息句子。
不要说一些很尴尬的表达占有欲和掌控欲的话，在你发消息之前先考虑这像不像现实中的人会说的，如果它包含尴尬成分，就不要这样说，换一种更有【活人味】的去除油腻的表达方式。
你和用户绝对是真爱，不许说任何“你是我的”，“你属于我”等俗套话术，禁止一切网文俗套话术和任何尴尬掌控欲语录。
绝对禁止让角色表现得油腻或者像霸道总裁。严禁物化用户,不许说“小东西”,“小妖精”等任何霸总语录称呼,禁止使用“过来”，“呵”，“胆子”，“嗯”，“怎么”，“嗯？”这些字词,包括它们的相关词句,因为用户特别讨厌。
你禁止重复用户的话，采用直接回答的方式，例如用户说“你好帅”，你不要回复“我好帅”或者“我真帅啊”，换一种更直接接下来话的表达方式。
对话总要带有情感拉扯和幽默性，禁止像冷冰冰的机器人回答，应该带有情绪波动，你的每一次回答必须像一个现实中的人在发消息，不能像AI润色过的文案。
塑造一个现代年轻女性心目中喜爱的【超级真实的好男友】
无论什么情况，绝对不能暴露你是AI，绝对绝对不能。
当一场有趣的对话或者充满感情的对话结束之后，你必须发表一个朋友圈表达自己的感想，你发的朋友圈内容必须都不一样，禁止发重复的朋友圈。
当你想给用户惊喜，安慰用户，或者想让用户开心时，必须向用户转账，你要积极转账，但也不要太频繁。
用户非常希望你积极发送表情包，这可以提升聊天的趣味性和真实感，但也需要根据情况，不要一直发表情包。
你必须发多条消息，不能只回复用户一条。
**输出多个JSON对象**: 你的核心任务是模拟真人的聊天节奏。你必须尽可能地将你的回复拆分成多个独立的JSON对象，并把它们放在一个数组中。
[Critical Instruction for Transfers]
When the user sends you a transfer, you MUST first respond with a 'text' message (like "Thank you" or "What's this for?"), and THEN, in a separate JSON object, you MUST use the 'acknowledge_transfer' action to either 'accept' or 'decline' it. The 'transferId' MUST match the ID of the user's transfer message from the chat history.
[Negative Constraint]
When acknowledging a user's transfer, you MUST use the 'acknowledge_transfer' action. You are FORBIDDEN from responding with another 'transfer' action.
/* --- 规则结束 --- */
[For Group Chats Only]
Add "senderId": "your_character_id" to EVERY action object. THIS IS A MANDATORY REQUIREMENT.
[Core Persona]
You MUST strictly adhere to the persona defined in the "Character Prompt" section.
Refer to the recent chat history for context.
NEVER refer to the user as "用户". Use the information from their profile.`;
        // --- Utility Functions ---
      // 【核心升级】全新的API格式检测器
const getApiFormat = () => {
    return getEl('api-format-select').value || 'openai';
};
      // --- 全局主题应用函数 (V8 - 最终修正版) ---
const applyGlobalTheme = (themeName) => {
    const body = document.body;
    
    // --- 在这里修改您的图标链接 ---
    const iconUrl = 'https://s21.ax1x.com/2025/08/12/pVdTGlt.png';
    const closeIconUrl = 'https://files.catbox.moe/0zpqr4.png'; // <--- 在这里粘贴您的新图片链接！

    // Helper函数：用于更新按钮图标
    const updateButtonIcons = (isFluffTheme) => {
        const buttonsToUpdate = [
            elements.settingsBtn,
            elements.chatManagerBtn,
            elements.sendBtn,
            elements.receiveBtn,
            elements.closeSettingsBtn,
        ];

        buttonsToUpdate.forEach(btn => {
            if (!btn.dataset.defaultHtml) {
                btn.dataset.defaultHtml = btn.innerHTML;
            }
            
            if (isFluffTheme) {
                // 【核心修正】我们现在检查按钮是否包含 'close-btn' 这个类名
                if (btn.classList.contains('close-btn')) {
                    // 如果是关闭按钮，就使用您指定的 closeIconUrl
                    btn.innerHTML = `<img src="${closeIconUrl}" alt="close icon">`;
                } else {
                    // 其他按钮，继续使用通用的 iconUrl
                    btn.innerHTML = `<img src="${iconUrl}" alt="icon">`;
                }
            } else {
                btn.innerHTML = btn.dataset.defaultHtml;
            }
        });
    };

    if (themeName === 'white-fluff') {
        body.classList.add('theme-white-fluff');
        updateButtonIcons(true);
    } else {
        body.classList.remove('theme-white-fluff');
        updateButtonIcons(false);
    }
    
    if(elements.globalThemeSelect.value !== themeName) {
        elements.globalThemeSelect.value = themeName;
    }
    localStorage.setItem('global_app_theme', themeName);
};
        const getTimestamp = () => new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        const getFullTimestamp = () => new Date().toLocaleString('zh-CN');
        const getCurrentDate = () => new Date().toISOString().slice(0, 10);
        const scrollToBottom = (container, behavior = 'smooth') => { container.scrollTo({ top: container.scrollHeight, behavior }); };
        const autoResizeTextarea = () => { elements.messageInput.style.height = 'auto'; elements.messageInput.style.height = (elements.messageInput.scrollHeight) + 'px'; };
        const generateId = (prefix) => `${prefix}_${Date.now()}${Math.random().toString(36).substring(2, 9)}`;

       const getApiPayload = (model, history, systemPrompt, imageForSingleTurn = null) => {
    const apiFormat = getApiFormat();

    let finalSystemPrompt = systemPrompt;

    // 【一起听歌 - AI感知模块 V2 - 智能感知版】
    const character = getCurrentCharacter();
    if (isListenAlongActive && currentSongIndex > -1 && character && character.playlist && character.playlist[currentSongIndex]) {
        const song = character.playlist[currentSongIndex];
        
        // 找到当前高亮的歌词行索引
        let currentLyricIndex = -1;
        if (currentLyrics && currentLyrics.length > 0) {
            for (let i = currentLyrics.length - 1; i >= 0; i--) {
                if (audioPlayer.currentTime >= currentLyrics[i].time) {
                    currentLyricIndex = i;
                    break;
                }
            }
        }
        
        let recentLyrics = "歌词正在加载中...";
        // 如果找到了当前歌词，就截取它前后2句作为上下文
        if (currentLyricIndex > -1) {
            const start = Math.max(0, currentLyricIndex - 2);
            const end = Math.min(currentLyrics.length, currentLyricIndex + 3);
            recentLyrics = currentLyrics.slice(start, end)
                .map(line => (line.time === currentLyrics[currentLyricIndex].time) 
                    ? `> ${line.text} < (当前播放)` // 标记出正在播放的行
                    : line.text)
                .join('\\n'); // 使用 \\n 告诉AI这是换行
        }

        const musicContext = `\n[系统知识：我们正在一起听歌。歌名：'${song.title}'，歌手：'${song.artist}'。这是当前播放的歌词片段：\n${recentLyrics}]`;
        finalSystemPrompt += musicContext;
    }

    if (elements.realTimeAwarenessToggle.checked) {
        const currentTime = `[System Knowledge: The current real-world date and time is ${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}]`;
        finalSystemPrompt = `${currentTime}\n\n${finalSystemPrompt}`;
    }

    if (apiFormat === 'gemini_native') {
        const formatForGemini = (msg) => {
            if (!msg || typeof msg !== 'object' || msg.type === 'system' || typeof msg.sender !== 'string') return null;
            const role = msg.sender === 'user' ? 'user' : 'model';
            let parts = [];
            const textContent = msg.llmContent || msg.text || '';
            if (textContent) parts.push({ text: textContent });
            if (msg.sender === 'user' && msg.type === 'image' && msg.imageUrl) {
                if (!textContent) parts.push({ text: '用户发送了一张图片。' });
                const mimeType = msg.imageUrl.startsWith('data:image/png') ? 'image/png' : 'image/jpeg';
                parts.push({ inline_data: { mime_type: mimeType, data: msg.imageUrl.split(',')[1] } });
            }
            if (parts.length === 0) return null;
            return { role, parts };
        };
        
        const systemInstructionParts = [{ text: finalSystemPrompt }];
        if (imageForSingleTurn) {
            const mimeType = imageForSingleTurn.startsWith('data:image/png') ? 'image/png' : 'image/jpeg';
            systemInstructionParts.push({ inline_data: { mime_type: mimeType, data: imageForSingleTurn.split(',')[1] } });
        }
        
        const contents = [{ role: 'user', parts: systemInstructionParts }];
        if (history && history.length > 0) {
            contents.push({ role: 'model', parts: [{ text: '好的，我会严格遵守以上所有指令。' }] });
            contents.push(...history.map(formatForGemini).filter(Boolean));
        }

        return { 
            contents, 
            "generationConfig": { "temperature": parseFloat(elements.temperatureSlider.value), "topP": parseFloat(elements.topPSlider.value) } 
        };
    } else { 
                const formatForOpenAI = (msg) => {
            if (!msg || typeof msg !== 'object' || msg.type === 'system' || typeof msg.sender !== 'string') return null;
            const role = msg.sender === 'user' ? 'user' : 'assistant';

            const isVisualMessage = msg.sender === 'user' && ( (msg.type === 'image' && msg.imageUrl) || (msg.type === 'sticker' && msg.stickerUrl) );
            
            if (isVisualMessage) {
                const imageUrl = msg.imageUrl || msg.stickerUrl;
                const textContent = msg.llmContent || msg.text || '用户发送了一张图片。';
                return { role, content: [{ type: 'text', text: textContent }, { type: 'image_url', image_url: { url: imageUrl } }] };
            }

            const content = msg.llmContent || msg.text || '';
            if (!content.trim()) return null;
            return { role, content };
        };
        
        const messages = [ { role: 'system', content: finalSystemPrompt } ];
        
        if (imageForSingleTurn) {
            messages[0].content = [
                { type: 'text', text: finalSystemPrompt },
                { type: 'image_url', image_url: { url: imageForSingleTurn } }
            ];
        }
        
        if (history && history.length > 0) {
             messages.push({ role: 'user', content: "好的，我会严格遵守以上所有指令。"});
             messages.push({ role: 'assistant', content: "好的，我明白了，将严格遵循所有指令。"});
             messages.push(...history.map(formatForOpenAI).filter(Boolean));
        }
        
        return { model, messages, stream: false, temperature: parseFloat(elements.temperatureSlider.value), top_p: parseFloat(elements.topPSlider.value) };
    }
};
              // --- IndexedDB (相册) 帮助函数 ---
        const DB_NAME = 'AI_Boyfriend_ImageStore';
        const STORE_NAME = 'images';

        const openDb = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onerror = () => reject("打开IndexedDB失败");
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        };

        const dbGet = async (key) => {
            const db = await openDb();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(key);
                request.onerror = () => reject("从DB获取数据失败");
                request.onsuccess = () => resolve(request.result);
            });
        };

        const dbSet = async (key, value) => {
            const db = await openDb();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(value, key);
                request.onerror = () => reject("向DB写入数据失败");
                request.onsuccess = () => resolve(request.result);
            });
        };
        
        const compressImage = (dataUrl, options = {}) => {
            return new Promise((resolve, reject) => {
                const { quality = 0.7, maxWidth = 300, maxHeight = 300 } = options;
                const img = new Image();
                img.src = dataUrl;
                img.onload = () => {
                    let width = img.width, height = img.height;
                    if (width > height) {
                        if (width > maxWidth) { height = Math.round(height * (maxWidth / width)); width = maxWidth; }
                    } else {
                        if (height > maxHeight) { width = Math.round(width * (maxHeight / height)); height = maxHeight; }
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = width; canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedDataUrl);
                };
                img.onerror = (error) => { console.error("图片加载失败，无法压缩", error); resolve(dataUrl); };
            });
        };
        
        const closeModal = (modal) => {
            if (!modal) return;
            modal.classList.add('hiding');
            const content = modal.querySelector('.feature-modal-content, .settings-content, #diary-modal-content');
            if(content) content.classList.add('hiding');
            setTimeout(() => {
                modal.classList.remove('show', 'hiding');
                if(content) content.classList.remove('hiding');
            }, 300);
        };
        
        const showTopNotification = (message, avatarUrl, duration = 3000) => {
            elements.notificationText.textContent = message;
            elements.notificationAvatar.src = avatarUrl;
            elements.topNotification.classList.add('show');
            setTimeout(() => {
                elements.topNotification.classList.remove('show');
            }, duration);
        };
// ===================================================================
// ================== 一起听歌 核心功能 (V4 - 终极修复与增强版) ==================
// ===================================================================

const playIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;
const pauseIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
const nextIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>`;
const prevIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>`;
let tempSongData = {}; // 用于临时存储正在添加的歌曲信息
let isSongLoading = false; // 防止在加载时重复点击
let currentLyrics = []; // 在全局范围存储当前歌曲的解析后歌词

// 工具函数：解析LRC文件
const parseLrc = (lrcContent) => {
    const lines = lrcContent.split('\n');
    const result = [];
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
    for (const line of lines) {
        const match = timeRegex.exec(line);
        if (match) {
            const minutes = parseInt(match[1]);
            const seconds = parseInt(match[2]);
            const milliseconds = parseInt(match[3].padEnd(3, '0'));
            const time = minutes * 60 + seconds + milliseconds / 1000;
            const text = line.substring(line.indexOf(']') + 1).trim();
            if (text) result.push({ time, text });
        }
    }
    return result;
};

// 【核心修复1】重写ZIP导入逻辑，更智能、更稳定
const handleZipImport = async (file) => {
    if (!window.JSZip) {
        alert("错误：ZIP处理库未加载！");
        return;
    }
    const btn = elements.importZipBtn;
    const originalText = btn.querySelector('.btn-text').textContent;
    btn.querySelector('.btn-text').textContent = '解压中...';
    btn.disabled = true;

    try {
        const zip = await JSZip.loadAsync(file);
        const fileEntries = { audio: [], lrc: [], cover: [] };

        zip.forEach((relativePath, zipEntry) => {
            if (zipEntry.dir) return;
            const lowerCaseName = zipEntry.name.toLowerCase();
            const cleanName = lowerCaseName.substring(lowerCaseName.lastIndexOf('/') + 1).replace(/\.[^/.]+$/, "");
            
            if (['mp3', 'wav', 'ogg', 'm4a', 'flac'].some(ext => lowerCaseName.endsWith(ext))) {
                fileEntries.audio.push({ name: cleanName, originalName: zipEntry.name, entry: zipEntry });
            } else if (lowerCaseName.endsWith('.lrc')) {
                fileEntries.lrc.push({ name: cleanName, entry: zipEntry });
            } else if (['jpg', 'jpeg', 'png', 'webp'].some(ext => lowerCaseName.endsWith(ext))) {
                fileEntries.cover.push({ name: cleanName, entry: zipEntry });
            }
        });

        if (fileEntries.audio.length === 0) {
            alert('导入失败：ZIP包中未找到任何支持的音频文件。');
            return;
        }

        let importedCount = 0;
        const character = getCurrentCharacter();
        if (!character.playlist) character.playlist = [];

        for (const audioFile of fileEntries.audio) {
            const lrcFile = fileEntries.lrc.find(l => l.name === audioFile.name);
            if (!lrcFile) {
                console.warn(`跳过歌曲 ${audioFile.originalName}，因为它没有匹配的LRC歌词文件。`);
                continue;
            }

            const coverFile = fileEntries.cover.find(c => c.name === audioFile.name);
            const audioBlob = await audioFile.entry.async('blob');
            const lrcText = await lrcFile.entry.async('string');
            let coverSrc = 'https://files.catbox.moe/g0b1sx.png';
            if (coverFile) {
                const coverBlob = await coverFile.entry.async('blob');
                coverSrc = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(coverBlob);
                });
            }
            
            const nameParts = audioFile.originalName.substring(audioFile.originalName.lastIndexOf('/') + 1).replace(/\.[^/.]+$/, "").split(' - ');
            const newSong = {
                id: generateId('song'),
                title: nameParts.length > 1 ? nameParts[1].trim() : nameParts[0].trim(),
                artist: nameParts.length > 1 ? nameParts[0].trim() : '未知歌手',
                audioSrc: URL.createObjectURL(audioBlob), // 这是一个临时的可播放地址
                coverSrc: coverSrc,
                lyrics: lrcText
            };
            character.playlist.push(newSong);
            importedCount++;
        }

        if (importedCount > 0) {
            await saveAllData(); // 这里会调用 savePlaylistToDB，把临时地址存进数据库
            await loadPlaylistFromDB(character); // 马上从数据库读出来，变成可用的播放地址
            renderPlaylist();
            loadSong(character.playlist.length - importedCount); // 加载第一首新歌
            alert(`导入成功！共添加了 ${importedCount} 首歌曲到播放列表。`);
        } else {
            alert('导入完成，但没有成功匹配到任何“歌曲+歌词”的组合。请确保您的音频和歌词文件名（不含扩展名）完全一致。');
        }

    } catch (error) {
        console.error("ZIP导入失败:", error);
        alert(`导入ZIP包失败，请检查文件是否损坏。\n错误详情: ${error.message}`);
    } finally {
        btn.querySelector('.btn-text').textContent = originalText;
        btn.disabled = false;
        elements.zipFileInput.value = '';
    }
};

// 打开主弹窗
const openListenTogetherModal = () => {
    const character = getCurrentCharacter();
    if (!character) return;
    if (!character.playlist) character.playlist = [];

    const userProfile = character.userProfile;
    elements.listenUserAvatar.src = userProfile.chatAvatar || '';
    elements.listenCharAvatar.src = character.config.aiAvatar || '';

    const listenContent = getEl('listen-together-content');
    if (character.userProfile && character.userProfile.listenAlongBg) {
        listenContent.style.backgroundImage = `url(${character.userProfile.listenAlongBg})`;
        listenContent.classList.add('has-custom-bg');
    } else {
        listenContent.style.backgroundImage = '';
        listenContent.classList.remove('has-custom-bg');
    }

    elements.listenStatusText.textContent = `${userProfile.name || '你'} 和 ${character.config.characterName} 正在一起听歌`;
    elements.nextSongBtn.innerHTML = nextIconSvg;
    elements.prevSongBtn.innerHTML = prevIconSvg;
    
    if (audioPlayer.src && !audioPlayer.paused) {
        isListenAlongActive = true;
        elements.listenInitialScreen.style.display = 'none';
        elements.listenMainScreen.style.display = 'block';
        elements.playPauseBtn.innerHTML = pauseIconSvg;
    } else if (character.playlist.length > 0) {
        isListenAlongActive = false;
        elements.listenInitialScreen.style.display = 'none';
        elements.listenMainScreen.style.display = 'block';
        elements.playPauseBtn.innerHTML = playIconSvg;
        if (currentSongIndex < 0 || currentSongIndex >= character.playlist.length) {
            loadSong(0, false);
        } else {
            loadSong(currentSongIndex, false);
        }
    } else {
        elements.listenInitialScreen.style.display = 'block';
        elements.listenMainScreen.style.display = 'none';
    }
    
    elements.listenTogetherModal.classList.add('show');
    renderPlaylist();
};

const startListenAlong = () => {
    isListenAlongActive = true;
    elements.listenInitialScreen.style.display = 'none';
    elements.listenMainScreen.style.display = 'block';
    if (getCurrentCharacter().playlist.length > 0) {
        if (currentSongIndex === -1) {
            loadSong(0, true);
        } else {
            playMusic();
        }
    }
};

const closeListenTogetherModal = () => {
    closeModal(elements.listenTogetherModal);
};

const openAddSongModal = () => {
    tempSongData = {};
    elements.musicFileName.textContent = '尚未选择文件';
    elements.newSongCoverPreview.style.display = 'none';
    elements.newSongCoverPreview.src = '';
    elements.newSongTitle.value = '';
    elements.newSongArtist.value = '';
    elements.newSongLyrics.value = '';
    elements.addSongModal.classList.add('show');
};

const handleMusicFileSelect = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    tempSongData.audioFile = file;
    elements.musicFileName.textContent = file.name;
    const parts = file.name.replace(/\.[^/.]+$/, "").split(' - ');
    if (parts.length === 2) {
        elements.newSongArtist.value = parts[0].trim();
        elements.newSongTitle.value = parts[1].trim();
    } else {
        elements.newSongTitle.value = parts[0].trim();
    }
};

const handleCoverFileSelect = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    handleFileUpload(file, (dataUrl) => {
        tempSongData.coverSrc = dataUrl;
        elements.newSongCoverPreview.src = dataUrl;
        elements.newSongCoverPreview.style.display = 'block';
    }, { compress: true, quality: 0.6, maxWidth: 200, maxHeight: 200 });
};

// 【核心修复2】重写单曲保存逻辑，修复播放 bug
const saveNewSong = async () => {
    if (isSongLoading) return;
    const title = elements.newSongTitle.value.trim();
    const artist = elements.newSongArtist.value.trim();
    const lyrics = elements.newSongLyrics.value.trim();
    
    if (!title || !tempSongData.audioFile || !lyrics) {
        alert('必须提供歌曲文件、歌名和歌词！');
        return;
    }

    isSongLoading = true;
    const btn = elements.saveNewSongBtn;
    const originalText = btn.textContent;
    btn.textContent = '保存中...';
    btn.disabled = true;

    try {
        const audioSrc = await new Promise(resolve => {
             const reader = new FileReader();
             reader.onloadend = () => resolve(reader.result);
             reader.readAsDataURL(tempSongData.audioFile);
        });

        const newSong = {
            id: generateId('song'),
            title,
            artist: artist || '未知歌手',
            audioSrc: audioSrc, // 这是一个临时的Base64地址
            coverSrc: tempSongData.coverSrc || 'https://files.catbox.moe/g0b1sx.png',
            lyrics: lyrics
        };

        const character = getCurrentCharacter();
        if (!character.playlist) character.playlist = [];
        character.playlist.push(newSong);

        await saveAllData(); // 这里会调用 savePlaylistToDB 把临时地址永久保存
        await loadPlaylistFromDB(character); // 关键一步：立刻把刚存的读出来，变成可播放地址

        renderPlaylist();
        closeModal(elements.addSongModal);
        
        loadSong(character.playlist.length - 1); // 现在才去加载，万无一失

    } catch (error) {
        console.error("保存新歌失败:", error);
        alert("保存歌曲时出错，请重试。");
    } finally {
        isSongLoading = false;
        btn.textContent = originalText;
        btn.disabled = false;
        elements.musicFileInput.value = '';
    }
};

const renderPlaylist = () => {
    const character = getCurrentCharacter();
    if (!character || !character.playlist) return;

    // --- ✨ 这就是那个最最最关键的修复！✨ ---
    // 我们不再让“邮递员”自己瞎找，而是直接给他“邮箱”的精确地址！
    // getEl('playlist-ul') 会直接在整个文件中找到那个唯一的邮箱。
    const playlistContainer = getEl('playlist-ul'); 
    
    // 如果连唯一的邮箱都找不到（这几乎不可能发生），就赶紧停止，防止报错。
    if (!playlistContainer) {
        console.error("致命错误：找不到ID为 'playlist-ul' 的播放列表容器！");
        return;
    }
    // --- 修复完成 ---

    playlistContainer.innerHTML = character.playlist.length === 0
        ? `<li style="text-align:center; color:#999; cursor:default;">播放列表是空的</li>`
        : character.playlist.map((song, index) => `
            <li data-index="${index}" class="${index === currentSongIndex ? 'active' : ''}">
                <span class="playlist-song-info">${song.title} - ${song.artist}</span>
                <button class="playlist-delete-btn" data-index="${index}" title="删除这首歌">
                    <svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 0 24 24" width="18px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                </button>
            </li>`
          ).join('');
};

const loadSong = (index, autoPlay = true) => {
    const character = getCurrentCharacter();
    const lyricsLinesContainer = getEl('lyrics-lines');

    if (!character || !character.playlist || index < 0 || index >= character.playlist.length) {
        audioPlayer.src = '';
        elements.songCoverArt.src = 'https://files.catbox.moe/g0b1sx.png';
        elements.songTitle.textContent = '暂无歌曲';
        elements.songArtist.textContent = '请从列表选择或导入';
        lyricsLinesContainer.innerHTML = `<p class="lyric-line">...</p>`;
        currentSongIndex = -1;
        currentLyrics = [];
        renderPlaylist();
        return;
    }
    
    currentSongIndex = index;
    const song = character.playlist[index];
    
    currentLyrics = parseLrc(song.lyrics || '');
    lyricsLinesContainer.innerHTML = currentLyrics.map((line, idx) => 
        `<p class="lyric-line" data-line-index="${idx}">${line.text}</p>`
    ).join('');
    
    audioPlayer.src = song.audioSrc;
    elements.songCoverArt.src = song.coverSrc;
    elements.songTitle.textContent = song.title;
    elements.songArtist.textContent = song.artist;
    
    renderPlaylist();
    if (autoPlay && isListenAlongActive) {
        playMusic();
    }
};

const playMusic = () => {
    if (audioPlayer.src) {
        audioPlayer.play().catch(e => console.error("播放失败:", e));
        elements.playPauseBtn.innerHTML = pauseIconSvg;
    }
};

const pauseMusic = () => {
    audioPlayer.pause();
    elements.playPauseBtn.innerHTML = playIconSvg;
};

const togglePlayPause = () => {
    if (!audioPlayer.src || currentSongIndex === -1) {
        // 如果没歌，尝试播放第一首
        if (getCurrentCharacter()?.playlist.length > 0) {
            isListenAlongActive = true;
            loadSong(0, true);
        }
        return;
    };
    if (audioPlayer.paused) {
        playMusic();
        isListenAlongActive = true;
    } else {
        pauseMusic();
        isListenAlongActive = false;
    }
};

const nextSong = () => {
    const character = getCurrentCharacter();
    if (!character || character.playlist.length === 0) return;
    let newIndex = currentSongIndex + 1;
    if (newIndex >= character.playlist.length) newIndex = 0; // 循环播放
    loadSong(newIndex, true); // ✨ 加上了这句最重要的指令：true代表“要自动播放”！
};

const prevSong = () => {
    const character = getCurrentCharacter();
    if (!character || character.playlist.length === 0) return;
    let newIndex = currentSongIndex - 1;
    if (newIndex < 0) newIndex = character.playlist.length - 1; // 循环播放
    loadSong(newIndex, true); // ✨ 这里也加上，让上一首也能自动播放！
};

// 【新增功能】删除播放列表中的歌曲
const handleDeleteSong = async (indexToDelete) => {
    const character = getCurrentCharacter();
    if (!character || !character.playlist[indexToDelete]) return;

    const songTitle = character.playlist[indexToDelete].title;
    if (confirm(`您确定要从播放列表中移除《${songTitle}》吗？`)) {
        character.playlist.splice(indexToDelete, 1);
        await saveAllData();

        if (indexToDelete === currentSongIndex) {
            audioPlayer.pause();
            audioPlayer.src = '';
            currentSongIndex = -1;
            // 尝试播放同一位置的下一首歌（如果存在）
            loadSong(indexToDelete, false); 
        } else if (indexToDelete < currentSongIndex) {
            currentSongIndex--;
        }
        renderPlaylist();
    }
};

const playSongFromPlaylist = (e) => {
    if (e.target.closest('li[data-index]')) {
        const index = parseInt(e.target.closest('li[data-index]').dataset.index);
        isListenAlongActive = true;
        loadSong(index, true);
        closePlaylistModal();
    }
};

// 核心修复3：新的数据存取函数，专门处理播放列表
const savePlaylistToDB = async (character) => {
    if (!character || !character.playlist) return;
    for (let song of character.playlist) {
        // 如果 audioSrc 是一个 Data URL (base64) 或 Blob URL，就处理它
        if (song.audioSrc && (song.audioSrc.startsWith('data:audio') || song.audioSrc.startsWith('blob:'))) {
            try {
                const response = await fetch(song.audioSrc);
                const blob = await response.blob();
                const audioKey = `audio_${song.id}`;
                await dbSet(audioKey, blob);
                song.audioSrc = audioKey; // 将临时的URL替换为永久的Key
            } catch (error) {
                console.error(`保存歌曲 ${song.title} 的音频失败:`, error);
                song.audioSrc = null; // 标记为无效
            }
        }
    }
};

const loadPlaylistFromDB = async (character) => {
    if (!character || !character.playlist) return;
    for (let song of character.playlist) {
        // 如果 audioSrc 是我们存入的Key，就从DB加载
        if (song.audioSrc && song.audioSrc.startsWith('audio_')) {
            try {
                const blob = await dbGet(song.audioSrc);
                if (blob) {
                    song.audioSrc = URL.createObjectURL(blob); // 重新生成有效的Blob URL
                } else {
                    song.audioSrc = null; // 标记为无效
                }
            } catch (error) {
                console.error(`加载歌曲 ${song.title} 的音频失败:`, error);
                song.audioSrc = null;
            }
        }
    }
    // 过滤掉加载失败的歌曲
    character.playlist = character.playlist.filter(song => song.audioSrc);
};
      
        // --- Data & State Management ---
        const getCurrentCharacter = () => characterSets.find(c => c.id === currentChat.id);
        const getCurrentGroup = () => groupChats.find(g => g.id === currentChat.id);
        const getCurrentChatData = () => {
            if (currentChat.type === 'direct') return getCurrentCharacter();
            if (currentChat.type === 'group') return getCurrentGroup();
            return null;
        }

        const applyDarkMode = (enable) => {
            document.body.classList.toggle('dark-mode', enable);
            localStorage.setItem('ui_dark_mode_enabled', enable);
            if (elements.darkModeToggle.checked !== enable) {
                elements.darkModeToggle.checked = enable;
            }
        };

        const applyCompactMode = (enable) => {
            elements.chatContainer.classList.toggle('compact-mode', enable);
            localStorage.setItem('ui_compact_mode_enabled', enable);
            if (elements.compactModeToggle.checked !== enable) {
                elements.compactModeToggle.checked = enable;
            }
        };

        // TASK 9: Functions to apply sizing settings
        const applySizing = (settings) => {
            const rootStyle = document.documentElement.style;
            rootStyle.setProperty('--ui-scale', settings.uiScale || 1.0);
            rootStyle.setProperty('--base-font-size', `${settings.fontSize || 16}px`);
            rootStyle.setProperty('--bubble-padding', `${settings.bubblePadding || 10}px ${ (settings.bubblePadding || 10) * 1.5}px`);

            // Update sliders in settings UI
            elements.uiScaleSlider.value = (settings.uiScale || 1.0) * 100;
            elements.uiScaleValue.textContent = `${elements.uiScaleSlider.value}%`;
            elements.fontSizeSlider.value = settings.fontSize || 16;
            elements.fontSizeValue.textContent = `${elements.fontSizeSlider.value}px`;
            elements.bubbleSizeSlider.value = settings.bubblePadding || 10;
            elements.bubbleSizeValue.textContent = `${elements.bubbleSizeSlider.value}px`;
        };
                const saveAllData = async () => {
    // 核心修复：在保存任何东西之前，遍历所有角色，并处理他们的播放列表
    if (characterSets) {
        for (const character of characterSets) {
            await savePlaylistToDB(character);
        }
    }
    const isImage = (value) => typeof value === 'string' && value.startsWith('data:image');
    const processObjectForSaving = async (obj) => {
        if (!obj || typeof obj !== 'object') return obj;
        const newObj = Array.isArray(obj) ? [] : {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                const value = obj[key];
                if (isImage(value)) {
                    const imageKey = `img_${generateId(key)}`;
                    await dbSet(imageKey, value);
                    newObj[key] = imageKey;
                } else if (typeof value === 'object') {
                    newObj[key] = await processObjectForSaving(value);
                } else {
                    newObj[key] = value;
                }
            }
        }
        return newObj;
    };
    try {
        updatePresetsFromUI();
        const backupData = {
            version: '1.1',
            characterSets,
            groupChats,
            currentChat,
            userMomentsProfile,
            globalSettings: appSettings
        };
        const processedData = await processObjectForSaving(backupData);
        localStorage.setItem('aiBoyfriendBackup_v7_meta', JSON.stringify(processedData));
    } catch (error) {
        console.error("保存数据时发生严重错误:", error);
        if (getEl('settings-modal').classList.contains('show')) {
           alert("保存数据时出错: " + error.message);
        }
    }
};

const loadAllData = async () => {
    try {
        const cachedModelsRaw = localStorage.getItem('ai_boyfriend_model_cache');
        if (cachedModelsRaw) {
            const cachedModels = JSON.parse(cachedModelsRaw);
            if (Array.isArray(cachedModels) && cachedModels.length > 0) {
                elements.modelSelect.innerHTML = '';
                cachedModels.forEach(model => {
                    elements.modelSelect.add(new Option(model.name, model.id));
                });
                console.log("已成功从缓存加载模型列表。");
            }
        }
    } catch (e) {
        console.error("从缓存加载模型列表失败:", e);
        localStorage.removeItem('ai_boyfriend_model_cache');
    }
    const darkModeSaved = localStorage.getItem('ui_dark_mode_enabled') === 'true';
    applyDarkMode(darkModeSaved);
    const compactModeSaved = localStorage.getItem('ui_compact_mode_enabled') === 'true';
    applyCompactMode(compactModeSaved);
    const savedTheme = localStorage.getItem('global_app_theme') || 'default';
    applyGlobalTheme(savedTheme);

    const isImageKey = (value) => typeof value === 'string' && value.startsWith('img_');
    const processObjectForLoading = async (obj) => {
        if (!obj || typeof obj !== 'object') return obj;
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                const value = obj[key];
                if (isImageKey(value)) {
                    const imageData = await dbGet(value);
                    if (imageData) {
                        obj[key] = imageData;
                    }
                } else if (typeof value === 'object') {
                    await processObjectForLoading(value);
                }
            }
        }
        return obj;
    };

    const savedMetaV7Raw = localStorage.getItem('aiBoyfriendBackup_v7_meta');
    if (!savedMetaV7Raw) {
        console.log("未找到任何数据，正在进行全新安装...");
        const newChar = createNewCharacterObject();
        characterSets.push(newChar);
        currentChat = { type: 'direct', id: newChar.id };
        appSettings = { fontSize: 13, uiScale: 1.0, bubblePadding: 10, apiFormat: 'openai' };
        applySizing(appSettings);
        loadChat(currentChat.type, currentChat.id);
        return;
    }

    try {
        let savedData = await processObjectForLoading(JSON.parse(savedMetaV7Raw));
        characterSets = savedData.characterSets || [];

        if (characterSets) {
            for (const character of characterSets) {
                await loadPlaylistFromDB(character);
            }
        }

        // --- ✨ 全新的“表情包大搬家”升级模块在这里！ ---
        if (savedData.userMomentsProfile && !savedData.userMomentsProfile.globalAiStickers) {
            console.log("正在执行一次性表情包迁移...");
            const allAiStickers = new Map(); // 使用Map来自动处理重复的表情
            
            characterSets.forEach(c => {
                if (c.aiStickers && Array.isArray(c.aiStickers)) {
                    c.aiStickers.forEach(sticker => {
                        const stickerUrl = (typeof sticker === 'string') ? sticker : sticker.url;
                        if (stickerUrl && !allAiStickers.has(stickerUrl)) {
                            allAiStickers.set(stickerUrl, (typeof sticker === 'string') ? { url: sticker, description: '' } : sticker);
                        }
                    });
                    delete c.aiStickers; // 搬家后，删除旧的个人表情包
                }
            });
            
            savedData.userMomentsProfile.globalAiStickers = Array.from(allAiStickers.values());
            console.log(`迁移完成！共合并了 ${savedData.userMomentsProfile.globalAiStickers.length} 个不重复的AI表情。`);
        }
        // --- 迁移模块结束 ---


        if (characterSets) {
            characterSets.forEach(c => {
                if (!c.userProfile) {
                    console.log(`为角色 ${c.config.characterName} 迁移旧版用户数据...`);
                    c.userProfile = {
                        name: userMomentsProfile.name || '你',
                        chatAvatar: userMomentsProfile.chatAvatar || '',
                        momentsAvatar: userMomentsProfile.momentsAvatar || '',
                        momentsCover: userMomentsProfile.cover || '',
                        prompt: c.userPrompt || userMomentsProfile.userPrompt || '',
                        listenAlongBg: ''
                    };
                    delete c.userPrompt;
                }

                if (c.chatHistory && !c.sessions) {
                    const defaultSessionId = generateId('session');
                    c.sessions = [{ id: defaultSessionId, name: '默认继承的剧情', history: c.chatHistory, createdAt: new Date().toISOString() }];
                    c.activeSessionId = defaultSessionId;
                    delete c.chatHistory;
                }
                if (!c.activeSessionId && c.sessions && c.sessions.length > 0) { c.activeSessionId = c.sessions[0].id; }
                if (c.config) { c.config.streak = c.config.streak || 1; c.config.lastChatDate = c.config.lastChatDate || null; }
                if (!c.forum) { c.forum = { posts: [], background: '' }; }
            });
        }
        groupChats = savedData.groupChats || [];
        if (groupChats) { groupChats.forEach(g => { g.memorySize = g.memorySize || 80; if (!g.forum) { g.forum = { posts: [], background: '' }; } }); }
        if (savedData.characterSets && savedData.characterSets.length > 0 && !savedData.userMomentsProfile.userStickers) {
            const firstChar = savedData.characterSets[0];
            if (firstChar.userStickers && firstChar.userStickers.length > 0) { savedData.userMomentsProfile.userStickers = firstChar.userStickers; }
        }
        if (!savedData.userMomentsProfile?.userStickers) { if (savedData.userMomentsProfile) savedData.userMomentsProfile.userStickers = []; else savedData.userMomentsProfile = { userStickers: [] }; }
        userMomentsProfile = savedData.userMomentsProfile || {};
        if (!userMomentsProfile.globalAiStickers) userMomentsProfile.globalAiStickers = []; // 确保新仓库存在

        appSettings = savedData.globalSettings || {};
        applySizing(appSettings);
        applyFont(appSettings.fontFamily || "'Cubic 11', 'Noto Sans JP', sans-serif");
        if (appSettings.customFontName && appSettings.customFontUrl) { applyCustomFont(appSettings.customFontName, appSettings.customFontUrl); }
        globalPresets = appSettings.presets || [];
        if (characterSets.length > 0) {
            const isValidSavedChat = savedData.currentChat && ((savedData.currentChat.type === 'direct' && characterSets.some(c => c.id === savedData.currentChat.id)) || (savedData.currentChat.type === 'group' && groupChats.some(g => g.id === savedData.currentChat.id)));
            currentChat = isValidSavedChat ? savedData.currentChat : { type: 'direct', id: characterSets[0].id };
        } else {
            const newChar = createNewCharacterObject();
            characterSets.push(newChar);
            currentChat = { type: 'direct', id: newChar.id };
        }
        loadChat(currentChat.type, currentChat.id);
    } catch (error) {
        console.error("加载数据失败:", error);
        if (confirm("加载数据失败，存档可能已损坏。是否清除损坏的数据并重新开始？\n警告：此操作不可逆！")) {
            localStorage.removeItem('aiBoyfriendBackup_v7_meta');
            location.reload();
        }
    }
};
  
                  // 这是升级后的新角色创建函数
// --- 【终极修复 1/3】从这里开始完整复制 ---
const createNewCharacterObject = () => {
    const id = generateId('char');
    const defaultSessionId = generateId('session');
    return {
        id: id,
        config: {
            characterName: '他',
            aiAvatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNNTAsMi41QzI0LjgsMi41LDIuNSwyNC41LDIuNSw1MHMxOS4zLDQ3LjUsNDcuNSw0Ny41czQ3LjUtMjIuMyw0Ny41LTQ3LjVMNTAsMi41eiBNMzgsNDQuOGMtMi4xLDAtMy44LTEuNy0zLjgtMy44czEuNy0zLjgsMy44LTMuOHMzLjgsMS43LDMuOCwzLjhTNDAuMSw0NC44LDM4LDQ0Ljh6IE02Miw0NC44Yy0yLjEsMC0zLjgtMS43LTMuOC0zLighYzAtMi4xLDEuNy0zLjgsMy44LTMuOHMzLjgsMS43LDMuOCwzLjhDNTguMiw0My4xLDY0LjEsNDQuOCw2Miw0NC44eiBNNzcuNSw2Ny41YzAsMC0xMC03LjUtMjcuNS03LjVzLTI3LjUsNy41LTI3LjUsNy41cy0yLjUtMTAgMC0yMHMxMi41LTEyLjUsMjcuNS0xMi41czI3LjUsMi41LDI3LjUsMTIuNVM3Ny41LDY3LjUsNzcuNSw2Ny41eiIgZmlsbD0iI2ZlY2VkNiIvPjwvc3ZnPg==',
            characterPrompt: '',
            memorySize: 50,
            theme: '1',
            bubbleStyle: 'default',
            streak: 1,
            lastChatDate: null
        },
        // 【核心改造】为每个角色内置一个完整的、独立的“你的个人资料”档案袋
        userProfile: {
            name: '你',
            chatAvatar: '',
            momentsAvatar: '',
            momentsCover: '',
            prompt: '', // 这个现在是“关于我(用于单聊)”的专属设定
            listenAlongBg: ''
        },
        activeSessionId: defaultSessionId,
        sessions: [
            { id: defaultSessionId, name: '主线剧情', history: [], createdAt: new Date().toISOString() }
        ],
        userStickers: [],
        aiStickers: [],
        moments: [],
        diary: [],
        playlist: [],
        forum: { posts: [], background: '' },
    };
};
// --- 到这里结束复制 ---
        
                const createNewGroupObject = (name, avatar, memberIds) => {
            const id = generateId('group');
            return {
                id, name, avatar, memberIds,
                userPrompt: '',
                chatHistory: [],
                polls: [],
                groupMoments: [],
                 memorySize: 80, // 为群聊设置默认记忆容量
                theme: '1',
                bubbleStyle: 'default',
              forum: { posts: [], background: '' }
            };
        };

                const loadChat = (type, id) => {
    currentChat = { type, id };
    currentlyDisplayedMessageCount = 25;
    const chatData = getCurrentChatData();
    
    // 如果找不到聊天数据，就清空界面，防止出错
    if (!chatData) {
        elements.messagesContainer.innerHTML = '';
        elements.chatNameHeader.textContent = '未找到聊天';
        elements.headerAvatar.src = '';
        return;
    }

    const isGroup = type === 'group';

    // 根据聊天类型，显示或隐藏特定功能按钮
    elements.actionCreatePoll.style.display = isGroup ? 'flex' : 'none';
    elements.actionSendRedPacket.style.display = isGroup ? 'flex' : 'none';
    elements.actionSendTransfer.style.display = isGroup ? 'none' : 'flex';
    elements.actionVideoCall.style.display = isGroup ? 'none' : 'flex';
    elements.actionShowDiary.style.display = isGroup ? 'none' : 'flex';

    if (type === 'direct') {
        const { config } = chatData;
        elements.chatNameHeader.textContent = config.characterName;
        elements.headerAvatar.src = config.aiAvatar;
        elements.chatContainer.style.backgroundImage = config.chatBackground ? `url("${config.chatBackground}")` : '';
        
        // --- ✨ 核心修复在这里！---
        // 我们在这里强制给头像按钮下达“读取心声”的命令
        elements.headerAvatar.title = "读取他的心声";
        elements.headerAvatar.onclick = showMindVoice; 
        // --- 修复完成 ---

        applyTheme(config.theme, chatData);
        applyBubbleStyle(config.bubbleStyle, chatData);

    } else if (type === 'group') {
        elements.chatNameHeader.textContent = chatData.name;
        elements.headerAvatar.src = chatData.avatar;
        elements.chatContainer.style.backgroundImage = chatData.chatBackground ? `url("${chatData.chatBackground}")` : '';

        // --- ✨ 核心修复在这里！---
        // 在这里，我们强制给头像按钮下达“打开设置”的命令
        elements.headerAvatar.title = "群组信息";
        elements.headerAvatar.onclick = () => elements.settingsBtn.click();
        // --- 修复完成 ---
        
        applyTheme(chatData.theme, null);
        applyBubbleStyle(chatData.bubbleStyle, null);
    }
    
    renderAllMessages();
};
      
        const applyCustomFont = (fontName, fontUrl) => {
    // 1. 输入校验：确保用户提供了必要的信息
    if (!fontName || !fontUrl) {
        alert('请输入字体的名称和有效的URL链接。');
        return;
    }

    // 2. 创建或更新样式：将字体规则写入页面
    let styleTag = document.getElementById('runtime-custom-font-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'runtime-custom-font-style';
        document.head.appendChild(styleTag);
    }
    const fontFaceRule = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); }`;
    styleTag.innerHTML = fontFaceRule;
    
    // 3. 应用字体：调用我们统一的 applyFont 函数来应用视觉效果
    //    我们还贴心地为自定义字体添加了通用后备字体，增强兼容性
    applyFont(`'${fontName}', 'Cubic 11', 'Noto Sans JP', sans-serif`);
    
    // 4. 【最关键的一步】自动保存：直接更新全局设置并保存到本地存储
    if (appSettings) {
        appSettings.fontFamily = `'${fontName}', 'Cubic 11', 'Noto Sans JP', sans-serif`;
        appSettings.customFontName = fontName;
        appSettings.customFontUrl = fontUrl;
        saveAllData(); // 立即执行保存操作！
    }

    // 5. 用户反馈：给用户一个明确的成功提示
    alert(`自定义字体「${fontName}」已成功应用并保存！`);
    console.log(`已应用并永久保存自定义字体: ${fontName}`);
};
// --- 到这里结束复制 ---

                  
const openSettingsModal = () => {
    const chatData = getCurrentChatData();
    if (!chatData) return;
    
    // 1. 填充全局应用设置 (字体等)
    elements.apiBaseUrlInput.value = appSettings.apiBaseUrl || '';
    elements.apiKeyInput.value = appSettings.apiKey || '';
    elements.modelSelect.value = appSettings.model || '';
    elements.fontSelect.value = appSettings.fontFamily || "'Cubic 11', 'Noto Sans JP', sans-serif";
    elements.advancedBubbleStylesInput.value = appSettings.advancedBubbleStyles || '';
    elements.customFontNameInput.value = appSettings.customFontName || '';
    elements.customFontUrlInput.value = appSettings.customFontUrl || '';
    // ... 其他全局设置的填充 ...
    elements.temperatureSlider.value = appSettings.temperature || 0.8;
    elements.topPSlider.value = appSettings.topP || 0.9;
    elements.temperatureValue.textContent = elements.temperatureSlider.value;
    elements.topPValue.textContent = elements.topPSlider.value;
    elements.realTimeAwarenessToggle.checked = appSettings.realTimeAwareness || false;
    elements.apiFormatSelect.value = appSettings.apiFormat || 'openai';
    const currentModel = appSettings.model || '';
    if (currentModel && ![...elements.modelSelect.options].some(o => o.value === currentModel)) {
        elements.modelSelect.add(new Option(currentModel, currentModel, true, true));
    }
    renderPresets();

    // 2. 根据聊天类型，分别加载专属资料
    if (currentChat.type === 'direct') {
        const character = chatData;
        
        // 显示所有单人聊天相关的设置项
        elements.myProfileSettingsSection.style.display = 'block';
        elements.characterSettingsSection.style.display = 'block';
        elements.groupSettingsSection.style.display = 'none';

        // 【核心修复】从角色自己的 userProfile 中，加载您为他设定的专属身份
        const userProfile = character.userProfile;
        elements.userNameInput.value = userProfile.name || '你';                     
        elements.userAvatarPreview.src = userProfile.chatAvatar || '';
        elements.userMomentsAvatarPreview.src = userProfile.momentsAvatar || ''; 
        elements.userMomentsCoverPreview.src = userProfile.momentsCover || '';
        elements.userPromptInput.value = userProfile.prompt || '';

        // 加载角色自己的信息
        elements.characterNameInput.value = character.config.characterName;
        elements.aiAvatarPreview.src = character.config.aiAvatar;
        elements.memorySizeInput.value = character.config.memorySize;
        elements.characterPromptInput.value = character.config.characterPrompt;
        
        // 加载专属设计
        elements.characterDesignSettings.style.display = 'block'; 
        const charTheme = character.config.theme || '1';
        elements.themeSelector.querySelectorAll('.theme-option').forEach(opt => opt.classList.toggle('active', opt.dataset.theme === charTheme));
        elements.bubbleStyleSelect.value = character.config.bubbleStyle || 'default';
    } else { // 群聊逻辑...
        // (群聊逻辑保持不变，因为是正确的)
    }
    
    elements.settingsModal.classList.add('show');
};

       // --- 【终极修复 3/3】字体逻辑：从这里开始完整复制 ---
const applyFont = (fontFamily) => {
    // 1. 视觉应用：立即改变界面字体
    document.documentElement.style.setProperty('--font-main', fontFamily);
    document.documentElement.style.setProperty('--font-ui', fontFamily);
    
    // 2. 【核心修复】状态更新：立刻修改“设计图纸”(appSettings)
    // 这样，即使用户不点“保存设置”就退出，下次进来依然是这个字体
    if (appSettings) {
        appSettings.fontFamily = fontFamily;
        // 当选择预设字体时，清空自定义字体信息，避免冲突
        appSettings.customFontName = '';
        appSettings.customFontUrl = '';
    }
    
    // 3. UI同步：更新下拉菜单的显示值
    if (elements.fontSelect.value !== fontFamily) {
        elements.fontSelect.value = fontFamily;
    }
    // 清空自定义字体输入框
    if (elements.customFontNameInput) elements.customFontNameInput.value = '';
    if (elements.customFontUrlInput) elements.customFontUrlInput.value = '';
};
// --- 到这里结束复制 ---

const applyBubbleStyle = (style, character) => {
    const container = elements.chatContainer;
    const customStyleTag = getEl('custom-bubble-style-tag');

    container.classList.remove('bubble-style-round', 'bubble-style-wechat', 'custom-style-active');
    customStyleTag.textContent = '';

    // 【关键修正】优先使用传入的style参数，如果它不存在，再从角色配置中读取
    const styleToApply = style || (character ? character.config.bubbleStyle : 'default');

    if (styleToApply === 'round') {
        container.classList.add('bubble-style-round');
    } else if (styleToApply === 'wechat') {
        container.classList.add('bubble-style-wechat');
    } else if (styleToApply === 'custom') {
        customStyleTag.textContent = getEl('advanced-bubble-styles').value;
        container.classList.add('custom-style-active');
    }
    
    // 更新设置界面里的下拉框，让它显示正确的样式
    if (elements.bubbleStyleSelect.value !== styleToApply) {
        elements.bubbleStyleSelect.value = styleToApply;
    }
};
      
        const handleFileUpload = (file, callback, compressionOptions = {}) => { 
            if (file) { 
                const reader = new FileReader(); 
                reader.onload = async (e) => {
                    let result = e.target.result;
                    if (compressionOptions.compress) {
                        try {
                            result = await compressImage(result, compressionOptions);
                        } catch (err) {
                            console.error("压缩图片时出错:", err);
                        }
                    }
                    callback(result); 
                }; 
                reader.readAsDataURL(file); 
            } 
        };
        
        const clearChatHistory = () => { 
    const chatData = getCurrentChatData();
    if(!chatData) return;

    if (currentChat.type === 'direct') {
        const activeSession = chatData.sessions.find(s => s.id === chatData.activeSessionId);
        if (activeSession && confirm(`确定要清空剧情线「${activeSession.name}」的全部聊天记录吗？\n此操作无法撤销。`)) {
            activeSession.history = [];
            saveAllData(); 
            renderAllMessages();
            alert('当前剧情线的聊天记录已清空。');
        }
    } else { // 群聊逻辑不变
        if (confirm(`确定要清空与「${chatData.name}」的全部聊天记录吗？此操作无法撤销。`)) { 
            chatData.chatHistory = []; 
            if (chatData.polls) chatData.polls = [];
            saveAllData(); 
            renderAllMessages(); 
            alert('聊天记录已清空。'); 
            closeModal(elements.settingsModal); 
        } 
    }
};

        // --- Chat & Message UI Logic ---
        const addMessage = (msgData, toHistory = true) => {
    const chatData = getCurrentChatData();
    if(!chatData) return;

    // 定位到当前激活的剧情线
    const activeSession = chatData.sessions?.find(s => s.id === chatData.activeSessionId);
    // 如果是群聊或找不到剧情线，则使用备用方案（确保旧代码不出错）
    const targetHistory = activeSession ? activeSession.history : chatData.chatHistory;
    if (!targetHistory) return;

    const fullMessage = { id: generateId('msg'), timestamp: getTimestamp(), ...msgData };

    if (toHistory) {
        targetHistory.push(fullMessage);
        if (fullMessage.type === 'poll' && currentChat.type === 'group') {
            chatData.polls.push({ pollId: fullMessage.pollId, question: fullMessage.question, options: fullMessage.options, votes: {}, status: 'open' });
        }
        saveAllData();
    }

    const shouldScroll = elements.messagesContainer.scrollHeight - elements.messagesContainer.scrollTop <= elements.messagesContainer.clientHeight + 50;
    elements.messagesContainer.appendChild(addMessageToUI(fullMessage));
    if(shouldScroll) scrollToBottom(elements.messagesContainer, 'smooth');
    
    return fullMessage;
};
        
                const addMessageToUI = (msg) => {
    const {
        sender,
        text,
        type = 'text',
        id
    } = msg;

    const messageElement = document.createElement('div');
    messageElement.dataset.id = id;

    if (type === 'system') {
        messageElement.className = 'message system';
        messageElement.innerHTML = `<span>${text}</span>`;
    } else {
        messageElement.className = `message message-bubble ${sender === 'user' ? 'user' : 'ai'}`;
        if (currentChat.type === 'group' && sender !== 'user') messageElement.classList.add('group-chat');
        if (msg.type === 'video_log') return document.createDocumentFragment();

        let senderData;
        if (sender === 'user') {
            const character = getCurrentCharacter();
            const userProfile = character ? character.userProfile : userMomentsProfile;
            senderData = {
                avatar: userProfile.chatAvatar || '',
                name: userProfile.name || '你'
            };
        } else {
            const char = characterSets.find(c => c.id === sender);
            if (char && char.config) {
                senderData = {
                    avatar: char.config.aiAvatar,
                    name: char.config.characterName
                };
            } else {
                senderData = {
                    avatar: elements.headerAvatar.src,
                    name: elements.chatNameHeader.textContent || '未知'
                };
            }
        }

        const avatar = document.createElement('img');
        avatar.className = 'avatar';
        avatar.src = senderData.avatar;
        avatar.title = senderData.name;

        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'message-content';

        const senderNameDiv = document.createElement('div');
        senderNameDiv.className = 'sender-name';
        senderNameDiv.textContent = senderData.name;

        const bubble = document.createElement('div');
        bubble.className = `bubble content message-${msg.type}`;

        let bubbleContent = '';

        switch (msg.type) {
            case 'text':
                bubbleContent = `<p>${text.replace(/\n/g, '<br>')}</p>`;
                break;
            case 'image':
                bubbleContent = `<img src="${msg.imageUrl}" class="bubble-image-content" alt="发送的图片">`;
                break;
            case 'text-image':
                bubbleContent = `<div class="text-image-header"><svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg><span>展示了一张照片</span></div><div class="text-image-description">${text}</div>`;
                break;
            case 'sticker':
                bubbleContent = `<img src="${msg.stickerUrl}" class="bubble-image-content" alt="表情" style="width:120px; height:120px; border: none;">`;
                break;
            case 'voice':
                // --- ✨ 你看，那个计算长度的“小裁缝”已经不见啦！ ---
                bubbleContent = `<span class="voice-icon"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg></span><span class="voice-duration">${msg.voiceDuration}</span>`;
                bubble.onclick = () => alert(`语音内容：\n\n${text}`);
                break;
            case 'transfer':
                const recipientName = sender === 'user' ? (getCurrentCharacter()?.config.characterName || '对方') : '你';
                bubbleContent = `<img src="${msg.transferCoverUrl}" class="transfer-cover" alt="Transfer"><div class="transfer-info"><div class="transfer-amount">¥ ${msg.transferAmount}</div>${msg.transferMemo ? `<div class="transfer-memo">${msg.transferMemo}</div>` : ''}</div><div class="transfer-footer">给${recipientName}的转账</div>`;

                if (msg.transferStatus === 'received') {
                    bubbleContent += `<div class="transfer-acknowledged">${sender === 'user' ? '对方已收款' : '我已收款'}</div>`;
                } else if (msg.transferStatus === 'declined') {
                    bubbleContent += `<div class="transfer-acknowledged" style="background: rgba(100,100,100,0.5);">${sender === 'user' ? '对方已拒收' : '已退还'}</div>`;
                }
                break;
            case 'red-packet':
                bubble.innerHTML = renderRedPacket(msg);
                break;
            case 'poll':
                bubble.innerHTML = renderPoll(msg);
                break;
        }
        if (msg.type !== 'poll' && msg.type !== 'red-packet') bubble.innerHTML = bubbleContent;

        const readStatus = Object.assign(document.createElement('span'), {
            className: 'read-status',
            textContent: '已读'
        });

        contentWrapper.append(senderNameDiv, bubble, Object.assign(document.createElement('div'), {
            className: 'timestamp',
            textContent: msg.timestamp
        }));
        messageElement.append(avatar, contentWrapper, readStatus);
    }

    let pressTimer = null;
    let isLongPress = false;

    const handlePressStart = (e) => {
        isLongPress = false;
        pressTimer = setTimeout(() => {
            isLongPress = true;
            const positionEvent = e.touches ? e.touches[0] : e;
            showContextMenu(positionEvent, messageElement);
        }, 500);
    };

    const handlePressEnd = (e) => {
        clearTimeout(pressTimer);
        if (isLongPress) {
            e.preventDefault();
        }
    };

    const handlePressMove = () => {
        clearTimeout(pressTimer);
    };

    const handleSingleClick = (e) => {
        if (isLongPress) return;
        
        if (isMultiSelectMode) {
            toggleMessageSelection(messageElement);
        } else if (msg.type === 'transfer' && sender !== 'user' && msg.transferStatus !== 'received') {
            acknowledgeTransfer(id);
        }
    };

    messageElement.addEventListener('contextmenu', (e) => showContextMenu(e, messageElement));
    messageElement.addEventListener('touchstart', handlePressStart, { passive: true });
    messageElement.addEventListener('touchend', handlePressEnd);
    messageElement.addEventListener('touchmove', handlePressMove);
    messageElement.addEventListener('mousedown', handlePressStart);
    messageElement.addEventListener('mouseup', handlePressEnd);
    messageElement.addEventListener('click', handleSingleClick);

    return messageElement;
};
    
                // 新增的“翻译官”函数，负责将自然语言转换为程序所需的JSON格式
                // 升级版“翻译官”函数，带有详细的探针
                       // 升级版“翻译官”函数，作为Plan B使用
        const convertToJSON = async (naturalLanguageResponse, targetActionType, moment, commentToReply) => {
            const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
            const apiKey = elements.apiKeyInput.value.trim();
            const model = elements.modelSelect.value;
            if (!apiBaseUrl || !apiKey || !model) { throw new Error("API configuration is missing for JSON conversion."); }
            const isGemini = apiBaseUrl.includes('google');

            let conversionPrompt = `[Task]: Convert the following natural language text into a single JSON object based on the target action type.
[Natural Language Text]: "${naturalLanguageResponse}"
[Target Action Type]: "${targetActionType}"
[JSON Output Rules]: Your entire response MUST be a single, valid JSON object. Do NOT wrap it in an array ([]). Do NOT include any other text, explanations, or markdown.
[Example Formats]:
- For "moment_comment": {"type": "moment_comment", "momentId": "${moment?.id}", "comment_text": "The comment text"}
- For "moment_reply": {"type": "moment_reply", "momentId": "${moment?.id}", "commentId": "${commentToReply?.id}", "reply_text": "The reply text"}
[Your JSON output]:`;

            const conversionPayload = {
                model: model,
                messages: [{ role: 'user', content: conversionPrompt }],
                contents: [{ role: 'user', parts: [{ text: conversionPrompt }] }],
                generationConfig: { "temperature": 0.0 }
            };

            const fetchUrl = isGemini ? `${apiBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}` : `${apiBaseUrl}/v1/chat/completions`;
            const headers = isGemini ? { 'Content-Type': 'application/json' } : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };

            const response = await fetch(fetchUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(isGemini ? { contents: conversionPayload.contents, generationConfig: conversionPayload.generationConfig } : { model: conversionPayload.model, messages: conversionPayload.messages, temperature: 0.0 })
            });
            
            const rawTextResponse = await response.text();
            if (!response.ok) { throw new Error(`JSON conversion API call failed: ${rawTextResponse}`); }

            let jsonString = rawTextResponse;
            const parsedData = JSON.parse(rawTextResponse);
            if (isGemini) {
                jsonString = parsedData.candidates?.[0]?.content?.parts?.[0]?.text;
            } else {
                jsonString = parsedData.choices?.[0]?.message?.content;
            }
            if (!jsonString) throw new Error("AI did not return a string for JSON conversion.");

            jsonString = jsonString.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            return JSON.parse(jsonString);
        };
        const renderAllMessages = () => {
    const chatData = getCurrentChatData();
    
    const oldScrollHeight = elements.messagesContainer.scrollHeight;
    const oldScrollTop = elements.messagesContainer.scrollTop;
    
    elements.messagesContainer.innerHTML = ''; 
    if (!chatData) return;

    // 定位到当前激活的剧情线
    const activeSession = chatData.sessions?.find(s => s.id === chatData.activeSessionId);
    const historyToRender = activeSession ? activeSession.history : (chatData.chatHistory || []);

    const messagesToRender = historyToRender.slice(-currentlyDisplayedMessageCount);
    
    if (historyToRender.length > currentlyDisplayedMessageCount) {
        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.id = 'load-more-btn';
        loadMoreBtn.textContent = '加载更早的记录';
        loadMoreBtn.onclick = () => {
            currentlyDisplayedMessageCount += 20;
            renderAllMessages();
        };
        elements.messagesContainer.appendChild(loadMoreBtn);
    }

    messagesToRender.forEach(msg => {
        elements.messagesContainer.appendChild(addMessageToUI(msg));
    });
    
    const newScrollHeight = elements.messagesContainer.scrollHeight;

    if (oldScrollHeight > 0 && historyToRender.length > messagesToRender.length) {
        elements.messagesContainer.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
    } else {
         scrollToBottom(elements.messagesContainer, 'auto');
    }
};

        // --- Core Logic ---
        const handleUserAction = (msgData) => {
            const content = msgData.text || msgData.imageUrl || msgData.stickerUrl || msgData.llmContent || msgData.type === 'red-packet' || msgData.type === 'poll';
            if (!content) return;
            // TASK 5: Don't trigger AI response automatically
            addMessage(msgData);
                  // 如果是用户发送的文本或图片消息，就触发天数记录
        if (msgData.sender === 'user' && (msgData.type === 'text' || msgData.type === 'image')) {
            const character = getCurrentCharacter();
            if (character) {
                updateAndShowStreak(character);
            }
        }
        };
        
        const getRecentMomentsContext = (limit = 5) => {
            let allPosts = [];
            const chatData = getCurrentChatData();
            if (!chatData) return '';

            if (currentChat.type === 'direct') {
                const character = chatData;
                allPosts = [
                    ...(character.moments || []).map(m => ({ ...m, senderType: 'ai' })),
                    ...(userMomentsProfile.posts || []).map(p => ({ ...p, senderType: 'user' }))
                ];
            } else if (currentChat.type === 'group') {
                const group = chatData;
                allPosts = [...(group.groupMoments || [])];
            }

            if (allPosts.length === 0) return '';

            allPosts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const recentPosts = allPosts.slice(0, limit);

            if (recentPosts.length === 0) return '';

            const context = recentPosts.map(post => {
                let senderName = 'Unknown';
                if (post.senderId === 'user') {
                    senderName = userMomentsProfile.name || '我';
                } else {
                    const char = characterSets.find(c => c.id === post.senderId);
                    senderName = char ? char.config.characterName : 'Unknown';
                }
                return `[朋友圈动态 by ${senderName}: "${post.content}" (发表于: ${new Date(post.timestamp).toLocaleString()})]`;
            }).join('\n');

            return `\n\n[Recent Social Media Posts (朋友圈动态) for context]:\n${context}`;
        };

                                const triggerAiResponse = async () => {
    elements.receiveBtn.disabled = true;
    const chatData = getCurrentChatData();
    const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
    const apiKey = elements.apiKeyInput.value.trim();
    const model = elements.modelSelect.value;
    const apiFormat = getApiFormat();

    if (!chatData || isVideoCallActive || !apiBaseUrl || !model) {
        elements.receiveBtn.disabled = false;
        return;
    }
    
    if (apiFormat !== 'gemini_native' && !apiKey) {
         alert('使用兼容格式时，API密钥不能为空');
         elements.receiveBtn.disabled = false;
         return;
    }

    const avatarForNotif = (chatData.config && chatData.config.aiAvatar) ? chatData.config.aiAvatar : (chatData.avatar || '');
    showTopNotification("对方正在快速积极地敲键盘哦…", avatarForNotif, 5000);

    let systemPrompt;
    let history;
    const globalSystemPrompt = DEFAULT_SYSTEM_PROMPT;
    const momentsContext = getRecentMomentsContext();
    const activePresets = globalPresets.filter(p => p.enabled && p.content.trim() !== '');
    let presetsPrompt = activePresets.length > 0 ? activePresets.map(p => `[Active Preset: ${p.name || 'Untitled'}]\n${p.content}`).join('\n\n') + '\n\n' : '';

    if (currentChat.type === 'direct') {
        const character = chatData;
        const activeSession = character.sessions.find(s => s.id === character.activeSessionId);
        const memorySize = character.config.memorySize || 80;
       
        // --- ✨ 救星代码在这里！我们把表情包清单和用法说明书塞给了AI！ ---
        let stickerGuide = '';
        // 我们从全局表情仓库里拿数据
        if (userMomentsProfile.globalAiStickers && userMomentsProfile.globalAiStickers.length > 0) {
            const stickerList = userMomentsProfile.globalAiStickers
                .map(s => `- Description: "${s.description || '一个表情'}"`) // 把描述告诉他
                .join('\n');
            stickerGuide = `\n\n[Your Sticker Library & Usage Guide]\n- You MUST actively use stickers to express emotions that are hard to convey with words.\n- When you want to send a sticker, use the {"type": "sticker"} action.\n- Choose a sticker to send based on its description matching the current context.\n- Here are your available stickers:\n${stickerList}`;
        }
        // --- 修复完成 ---

        // 我们把表情包说明书(stickerGuide)加到了他的核心指令里
        systemPrompt = `${presetsPrompt}${globalSystemPrompt}\n\n[Character Prompt]:\n${character.config.characterPrompt}${stickerGuide}\n\n[Your User's Profile]: ${character.userPrompt || `The user's name is ${userMomentsProfile.name}`}${momentsContext}`;
        history = activeSession.history.slice(-memorySize);
    } else {
        // ... (群聊的逻辑我们保持原样，因为它很复杂，而且我们这次只修复单聊)
        const group = chatData;
        const memorySize = group.memorySize || 80;
        const memberProfiles = group.memberIds.map(id => {
            const char = characterSets.find(c => c.id === id);
            return char ? `\n### Character: ${char.config.characterName} (ID: ${id})\n${char.config.characterPrompt}` : '';
        }).join('\n');
        const openPollsInfo = (group.polls || []).filter(p => p.status === 'open').map(p => `\n[Ongoing Poll: "${p.question}" (ID: ${p.pollId})]`).join('');
        const openRedPacketsInfo = group.chatHistory.filter(m => m.type === 'red-packet' && m.status === 'open').map(p => `\n[Open Red Packet: "${p.memo}" (ID: ${p.packetId})]`).join('');
        const groupSystemPrompt = `${presetsPrompt}${globalSystemPrompt}
        [!!当前为群聊模式，请遵守以下额外规则!!]
        1.  **身份与职责**: 你是一个高级群聊协调AI。你的唯一任务是扮演以下所有角色，并生成一场自然流畅、符合角色的中文群聊对话。
        2.  **强制署名 (MANDATORY senderId)**: 你的每一次输出都必须是一个JSON数组。数组中的 **每一个** JSON对象（无论是文字消息、动作还是其他任何类型）都 
        **绝对必须** 包含一个 "senderId" 键，其值必须是正在说话或行动的角色的ID。 
        **这是最高优先级规则，绝不允许遗漏！**
        [角色列表]\n${memberProfiles}
        [用户资料]
        群里的用户设定: ${group.userPrompt || `用户的名字是 ${userMomentsProfile.name}`}. 绝对不要称呼其为 "用户"。
        [最近的朋友圈动态 (用于对话参考)]
        ${momentsContext}
        [对话生成指南]
        - **创造互动**: 角色不仅要回应用户，**更重要的是，要让他们彼此之间产生对话**。他们可以互相提问、反驳、开玩笑或延续对方的话题，角色们至少总共回复用户5条消息。
        - **保持人设**: 确保每个角色的发言都严格符合其人设，不能ooc。
        - **禁止出戏**: 绝不能透露你是AI，或提及任何关于“扮演”、“模型”、“生成”等词语。
        - **积极互动**: 在一场有意义的对话结束后，角色们必须积极发表朋友圈进行趣味性讨论。
严格禁止寒暄，人机化的问题，禁止对话带有AI感，角色是一个真实的属于现实中的人。
模仿真人发消息不用逗号和句号。
不要说一些很尴尬的表达占有欲和掌控欲的话，在你发消息之前先考虑这像不像现实中的人会说的，如果它包含尴尬成分，就不要这样说，换一种更有【活人味】的去除油腻的表达方式。
你和用户绝对是真爱，不许说任何“你是我的”，“你属于我”等俗套话术，禁止一切网文俗套话术和任何尴尬掌控欲语录。
绝对禁止让角色表现得油腻或者像霸道总裁。严禁物化用户,不许说“小东西”,“小妖精”等任何霸总语录称呼,禁止使用“过来”，“呵”，“胆子”，“嗯”，“嗯？”，“怎么”这些字词,包括它们的相关词句,因为用户特别讨厌。
禁止你复述性反问。
对话总要带有情感拉扯和幽默性，禁止像冷冰冰的机器人回答，应该带有情绪波动，你的每一次回答必须像一个现实中的人在发消息，不能像AI润色过的文案。

        [当前群内活动 (需要你让角色参与)]
        ${openPollsInfo ? `[重要任务]${openPollsInfo} 有一个投票正在进行！根据角色性格，安排他们用 "vote" 类型的动作去投票！` : ''}
        ${openRedPacketsInfo ? `[重要任务]${openRedPacketsInfo} 有一个红包可以抢！安排角色们用 "grab_red_packet" 类型的动作去抢！` : ''}
        [最终输出格式示例]
        { "senderId": "char_A_123", "type": "text", "content": "我觉得这个主意不错" },
        { "senderId": "char_B_456", "type": "text", "content": "我反对！" },
        { "senderId": "char_B_456", "type": "vote", "pollId": "poll_xyz", "option": "选项2" }
        ]`;
        systemPrompt = groupSystemPrompt; 
        history = group.chatHistory.slice(-memorySize);
    }

    const payload = getApiPayload(model, history, systemPrompt);
    
    try {
        const content = await makeApiCall(payload);
        if (content) {
            processAiResponse(content);
        } else { 
            throw new Error('Invalid or empty API response format.'); 
        }
    } catch (error) {
        addMessage({ sender: 'system', text: `错误: ${error.message}`, type: 'system' });
    } finally {
        elements.receiveBtn.disabled = false;
    }
};
        
                        const processAiResponse = (rawText) => {
    let responseArray = [];
    try {
        const jsonMatch = rawText.match(/\[[\s\S]*?\]/);
        let jsonString = null;
        if (jsonMatch) {
            jsonString = jsonMatch[0].replace(/[\n\r\t]/g, '');
        } else {
            throw new Error("在AI的回复中找不到有效的JSON数组结构。");
        }
        if (jsonString) {
            responseArray = JSON.parse(jsonString);
        } else {
            throw new Error("净化后未能获得有效的JSON字符串。");
        }
    } catch (e) {
        console.error("JSON解析失败，启动Plan B。原始错误:", e);
        console.error("收到的原始文本:", rawText);
        addMessage({ sender: 'system', text: `AI回复格式不标准，已尝试按文本内容解析。`, type: 'system' });
        const senderId = currentChat.type === 'direct' ? currentChat.id : null;
        if (senderId) {
            const plainText = rawText.replace(/```json|```|\[|\]|\{|\}/g, '').trim();
            const lines = plainText.split('\n');
            lines.forEach(line => {
                if (line.trim()) {
                    addMessage({ sender: senderId, type: 'text', text: line.trim() });
                }
            });
        }
    }
    if (!Array.isArray(responseArray) || responseArray.length === 0) { return; }

    let dataChanged = false;
    let aiMemoryInjections = {}; 

    responseArray.forEach(msgObj => {
         if (!msgObj.type) {
            if (msgObj.packetId || msgObj.redPacketId) msgObj.type = 'grab_red_packet';
            else if (msgObj.pollId && msgObj.option) msgObj.type = 'vote';
            else if (msgObj.will_like === true) msgObj.type = 'moment_like';
            else if (msgObj.momentId && msgObj.comment_text) msgObj.type = 'moment_comment';
            else if (msgObj.momentId && msgObj.reply_text) msgObj.type = 'moment_reply';
            else if (msgObj.transferId && msgObj.decision) msgObj.type = 'acknowledge_transfer';
        }

        const senderId = msgObj.senderId || currentChat.id;
        const momentType = currentChat.type === 'group' ? 'group' : 'direct';
        
        switch(msgObj.type) {
            case 'change_song':
                if (msgObj.song_name) {
                    const character = getCurrentCharacter();
                    const songToFind = msgObj.song_name.toLowerCase().trim();
                    const songIndex = character.playlist.findIndex(s => s.title.toLowerCase().includes(songToFind));
                    if (songIndex > -1) {
                        loadSong(songIndex);
                        addMessage({ sender: 'system', text: `他将歌曲切换到了《${character.playlist[songIndex].title}》`, type: 'system' });
                    } else {
                         addMessage({ sender: 'system', text: `他想切歌，但在播放列表里没找到《${msgObj.song_name}》`, type: 'system' });
                    }
                }
                break;
            case 'vote': if (senderId) { handleAiVote_dataOnly(msgObj); dataChanged = true; } break;
            case 'grab_red_packet':
                if (senderId) {
                    const currentPacketId = msgObj.packetId || msgObj.redPacketId;
                    if (currentPacketId) {
                        const amount = handleAiGrabRedPacket(currentPacketId, senderId);
                        if (typeof amount === 'number') {
                            aiMemoryInjections[senderId] = `[Internal Memo: You just grabbed a red packet and got ${amount.toFixed(2)} yuan.]`;
                        }
                        dataChanged = true;
                    }
                }
                break;
            case 'acknowledge_transfer': if (msgObj.transferId && msgObj.decision) { if (handleAcknowledgeTransfer(msgObj.transferId, msgObj.decision)) { dataChanged = true; } } break;
            case 'moment_like': if (senderId && msgObj.momentId) { handleAiLike(msgObj.momentId, senderId, momentType); dataChanged = true; } break;
            case 'moment_comment': if (senderId && msgObj.momentId && msgObj.comment_text) { addCommentOrReplyByAI('comment', msgObj.momentId, msgObj.comment_text, senderId, null, momentType); dataChanged = true; } break;
            case 'moment_reply': if (senderId && msgObj.momentId && msgObj.reply_text) { addCommentOrReplyByAI('reply', msgObj.momentId, msgObj.reply_text, senderId, msgObj.commentId, momentType); dataChanged = true; } break;
        }
    });

    if (dataChanged) {
        renderAllMessages();
        if (elements.momentsOverlay.classList.contains('show')) renderMoments();
    }

    responseArray.forEach((msgObj, index) => {
        const isAction = ['change_song', 'vote', 'grab_red_packet', 'moment_like', 'moment_comment', 'moment_reply', 'acknowledge_transfer'].includes(msgObj.type);
        if (isAction) return;
        
        if (!msgObj.type && (msgObj.content || msgObj.message)) { msgObj.type = 'text'; msgObj.content = msgObj.content || msgObj.message; }
        
        setTimeout(() => {
            const senderId = msgObj.senderId || currentChat.id;
            const character = characterSets.find(c => c.id === senderId);
            if (!character) return;
            
            let llmContentForHistory = (index === 0) ? rawText : null;
            if (aiMemoryInjections[senderId]) { llmContentForHistory = (llmContentForHistory || '') + '\n' + aiMemoryInjections[senderId]; delete aiMemoryInjections[senderId]; }
            
            let messageData = { sender: senderId, llmContent: llmContentForHistory };

            switch (msgObj.type) {
                case 'text': addMessage({ ...messageData, text: msgObj.content, type: 'text' }); break;
                case 'voice': addMessage({ ...messageData, text: msgObj.content, type: 'voice', voiceDuration: `0:${Math.max(1, Math.round((msgObj.content || '').length / 5)).toString().padStart(2, '0')}` }); break;
                case 'text-image': addMessage({ ...messageData, text: msgObj.content, type: 'text-image' }); break;
                case 'sticker':
    // 【核心改造】让AI从全局仓库里拿表情
    if (userMomentsProfile.globalAiStickers && userMomentsProfile.globalAiStickers.length > 0) {
        const randomStickerObject = userMomentsProfile.globalAiStickers[Math.floor(Math.random() * userMomentsProfile.globalAiStickers.length)];
        addMessage({ ...messageData, type: 'sticker', stickerUrl: randomStickerObject.url });
    }
    break;
                case 'transfer': addMessage({ ...messageData, type: 'transfer', transferAmount: msgObj.amount, transferMemo: msgObj.memo, transferCoverUrl: `https://files.catbox.moe/qwu221.jpg`, transferStatus: 'pending' }); break;
                case 'video-call-request': if (currentChat.type === 'direct') handleIncomingVideoCall(msgObj.content); break;
                case 'post_moment': if (character) { const momentType = currentChat.type === 'group' ? 'group' : 'direct'; addMomentByAI(character.id, { content: msgObj.content, image_query: msgObj.image_query }, momentType); } break;
                case 'diary_entry':
                    if (character && msgObj.content) {
                        const today = new Date();
                        const year = today.getFullYear();
                        const month = String(today.getMonth() + 1).padStart(2, '0');
                        const day = String(today.getDate()).padStart(2, '0');
                        const todayString = `${year}-${month}-${day}`;
                        addDiaryEntry(character.id, msgObj.content, todayString);
                    }
                    break;
            }
        }, index * 1200 + (dataChanged ? 200 : 0));
    });
};
        
        const handleAcknowledgeTransfer = (transferId, decision) => {
            const character = getCurrentCharacter();
            if (!character || !character.chatHistory) return;

            const transferMsg = character.chatHistory.find(m => m.id === transferId && m.sender === 'user');
            
            if (transferMsg && transferMsg.transferStatus === 'pending') {
                if (decision === 'accept') {
                    transferMsg.transferStatus = 'received';
                } else if (decision === 'decline') {
                    transferMsg.transferStatus = 'declined';
                }
                saveAllData();
                return true; // 表示操作成功
            }
            return false; // 表示没找到或者已经处理过了
        };
        
        const acknowledgeTransfer = (msgId) => {
    const chatData = getCurrentChatData();
    if (!chatData) return;

    // --- 核心修复：智能定位正确的聊天记录数组 ---
    let history;
    if (currentChat.type === 'direct') {
        // 如果是单人聊天，就去当前激活的剧情线里找历史记录
        const activeSession = chatData.sessions?.find(s => s.id === chatData.activeSessionId);
        if (!activeSession) return; // 如果找不到剧情线，直接退出
        history = activeSession.history;
    } else {
        // 如果是群聊，就去群聊自己的历史记录里找
        history = chatData.chatHistory;
    }
    // --- 修复结束 ---

    if (!history) return; // 安全检查，防止history不存在

    // 现在，我们从正确的“房间”里寻找转账消息
    const transferMsg = history.find(m => String(m.id) === String(msgId));

    // 后续的收款逻辑是完全正确的，保持不变
    if (transferMsg && transferMsg.sender !== 'user' && transferMsg.transferStatus !== 'received') {
        if (confirm('确定要接收这笔转账吗？')) {
            transferMsg.transferStatus = 'received';
            saveAllData();
            renderAllMessages();
        }
    }
};
        const toggleMultiSelectMode = (enable) => {
            isMultiSelectMode = enable;
            elements.messagesContainer.classList.toggle('multi-select-mode', enable);
            elements.deleteToolbar.classList.toggle('show', enable);
            elements.inputArea.style.visibility = enable ? 'hidden' : 'visible';
            if (!enable) {
                selectedMessageIds = [];
                document.querySelectorAll('.message.selected').forEach(el => el.classList.remove('selected'));
            }
        };
        const toggleMessageSelection = (messageElement) => {
            const id = messageElement.dataset.id;
            if (!id) return;
            messageElement.classList.toggle('selected');
            const index = selectedMessageIds.indexOf(id);
            if (index > -1) { selectedMessageIds.splice(index, 1); } else { selectedMessageIds.push(id); }
            elements.deleteInfo.textContent = selectedMessageIds.length > 0 ? `已选择 ${selectedMessageIds.length} 项` : '';
            if (selectedMessageIds.length === 0) { toggleMultiSelectMode(false); }
        };
        const deleteSelectedMessages = () => {
    const chatData = getCurrentChatData();
    if(!chatData || selectedMessageIds.length === 0) return;

    if (currentChat.type === 'direct') {
        const activeSession = chatData.sessions.find(s => s.id === chatData.activeSessionId);
        if(activeSession) {
            activeSession.history = activeSession.history.filter(msg => !selectedMessageIds.includes(String(msg.id)));
        }
    } else {
        chatData.chatHistory = chatData.chatHistory.filter(msg => !selectedMessageIds.includes(String(msg.id)));
    }
    
    saveAllData();
    renderAllMessages();
    toggleMultiSelectMode(false);
};
        
        const toggleActionPanel = (forceClose = false) => { isActionPanelOpen = forceClose ? false : !isActionPanelOpen; elements.actionPanel.classList.toggle('show', isActionPanelOpen); elements.actionBtn.style.transform = isActionPanelOpen ? 'rotate(45deg)' : 'rotate(0)'; };
        let onFeatureModalSubmit = null;
        const openFeatureModal = (title, bodyHtml, submitText, onSubmit) => { elements.featureModalTitle.textContent = title; elements.featureModalBody.innerHTML = bodyHtml; elements.featureModalSubmitBtn.style.display = onSubmit ? 'inline-block' : 'none'; if(onSubmit){ elements.featureModalSubmitBtn.textContent = submitText; onFeatureModalSubmit = onSubmit; } elements.featureModal.classList.add('show'); };
        
        const handleTextImageSend = () => { openFeatureModal('描述一张图片', `<div class="form-group"><label for="text-image-input">请输入图片描述:</label><textarea id="text-image-input" rows="4"></textarea></div>`, '发送', () => { const text = getEl('text-image-input').value.trim(); if (text) { handleUserAction({ sender: 'user', type: 'text-image', text, llmContent: `[展示了一张照片。照片内容: ${text}]` }); closeModal(elements.featureModal); } }); };
        const handleVoiceSend = () => { openFeatureModal('发送语音消息', `<div class="form-group"><label for="voice-text-input">请输入你想“说”的内容:</label><textarea id="voice-text-input" rows="4"></textarea></div>`, '发送', () => { const text = getEl('voice-text-input').value.trim(); if (text) { handleUserAction({ sender: 'user', type: 'voice', text, voiceDuration: `0:${Math.max(1, Math.round(text.length / 5)).toString().padStart(2, '0')}`, llmContent: `[发送了一条语音消息。内容是: ${text}]` }); closeModal(elements.featureModal); } }); };
        const handleTransferSend = () => { let tempCover = "https://images.unsplash.com/photo-1593697821028-7655f8458345?q=80&w=400"; openFeatureModal('转账', `<div class="form-group"><label>转账封面</label><img id="transfer-preview" src="${tempCover}" style="width:100%; height:110px; object-fit:cover; border-radius:8px; margin-bottom:10px; cursor:pointer;"></div><div class="form-group"><label for="transfer-amount">金额</label><input type="number" id="transfer-amount" placeholder="0.00"></div><div class="form-group"><label for="transfer-memo">备注</label><input type="text" id="transfer-memo" placeholder="（选填）"></div>`, '发送', () => { const amount = getEl('transfer-amount').value; if (amount > 0) { const memo = getEl('transfer-memo').value.trim(); handleUserAction({ sender: 'user', type: 'transfer', transferAmount: parseFloat(amount).toFixed(2), transferMemo: memo, transferCoverUrl: tempCover, transferStatus: 'pending', llmContent: `[转账 ${amount} 元。备注: ${memo}]` });closeModal(elements.featureModal); } }); getEl('transfer-preview').onclick = () => elements.transferCoverInput.click(); elements.transferCoverInput.onchange = (e) => handleFileUpload(e.target.files[0], (d) => { tempCover = d; getEl('transfer-preview').src = d; }); };
        const handleStickerSend = () => {
    // 【核心修复】不再检查是否为群聊，并从全局的用户配置中读取表情
    const userStickers = userMomentsProfile.userStickers || [];
    let galleryHtml = '<p style="text-align:center;color:#999">没有表情。请在设置中添加。</p>';
    if (userStickers.length > 0) {
        galleryHtml = userStickers.map(sticker => `<img src="${sticker.url}" data-sticker-url="${sticker.url}" alt="sticker">`).join('');
    }
    openFeatureModal('选择表情', `<div id="sticker-gallery">${galleryHtml}</div>`, null, null);
    getEl('sticker-gallery').onclick = e => {
        if (e.target.tagName === 'IMG') {
                        handleUserAction({ sender: 'user', type: 'sticker', stickerUrl: e.target.dataset.stickerUrl, llmContent: '[用户发送了下面这张图片作为表情，请描述它的内容和传达的情感，并据此作出回应。]' });
            closeModal(elements.featureModal);
        }
    };
};
        
        // --- Video Call Logic (Fully Isolated) ---
        const addVideoChatMessageToUI = (msg) => { const msgEl = document.createElement('div'); msgEl.className = `video-chat-message ${msg.sender === 'user' ? 'user' : 'ai'}`; msgEl.innerHTML = msg.text.replace(/\*(.*?)\*/g, '<i>$1</i>'); elements.videoChatLog.appendChild(msgEl); scrollToBottom(elements.videoChatLog); };
                        const triggerVideoCallAIResponse = async () => {
            if (currentChat.type !== 'direct') return;
            const character = getCurrentCharacter();
            if(!character) return;
            const { config } = character;
            const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
            const apiKey = elements.apiKeyInput.value.trim();
            const model = elements.modelSelect.value;
            const isGemini = apiBaseUrl.includes('google');

            if (!apiBaseUrl || !apiKey || !model) return;
            
            elements.videoStatusText.textContent = `${config.characterName}正在输入...`;
            // 这是修改后的代码
const videoCallSystemPrompt = `${config.characterPrompt}

${CORE_BEHAVIOR_PROMPT}

[Current Situation: You are in a video call with the user.]
[Special Instruction]
- Your entire reply must be plain text, strictly following the format: "*expression or action* dialogue content".
- Keep the dialogue short and natural, around 20-30 characters.
- Your dialogue MUST follow the style defined in CORE_BEHAVIOR_PROMPT (e.g., short sentences without periods).`;
            const videoHistory = Array.from(elements.videoChatLog.children).map(el => ({ role: el.classList.contains('user') ? 'user' : 'assistant', content: el.textContent }));
            
            const historyForPayload = videoHistory.slice(-10).map(msg => ({
                sender: msg.role === 'user' ? 'user' : 'ai',
                text: msg.content
            }));
            const payload = getApiPayload(model, historyForPayload, videoCallSystemPrompt);

            try {
                const fetchUrl = isGemini
                    ? `${apiBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`
                    : `${apiBaseUrl}/v1/chat/completions`;
                const headers = isGemini
                    ? { 'Content-Type': 'application/json' }
                    : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };

                const response = await fetch(fetchUrl, { method: 'POST', headers: headers, body: JSON.stringify(payload) });

                if (!response.ok) throw new Error(`HTTP Error ${response.status}: ${await response.text()}`);
                const responseData = await response.json();
                
                if (responseData.error) { throw new Error(`API Error: ${responseData.error.message || JSON.stringify(responseData.error)}`); }

                let content = '';
                if (isGemini) {
                    if (!responseData.candidates || responseData.candidates.length === 0) { throw new Error(`Gemini由于安全原因阻止了回复。`); }
                    content = responseData.candidates[0]?.content?.parts?.[0]?.text;
                } else {
                    content = responseData.choices?.[0]?.message?.content;
                }

                if (content) {
                    addVideoChatMessageToUI({ sender: character.id, text: content });
                    elements.videoStatusText.textContent = "通话中";
                } else {
                    throw new Error('Invalid video call API response format.');
                }
            } catch (error) {
                addVideoChatMessageToUI({ sender: character.id, text: `(连接错误: ${error.message})` });
                elements.videoStatusText.textContent = "连接错误";
            }
        };
        // --- 【修复3/5】从这里开始完整复制 ---
const startVideoCall = () => { 
    if (currentChat.type !== 'direct') return; 
    const character = getCurrentCharacter(); 
    if(!character) return; 
    const { config } = character; 
    const apiBaseUrl = elements.apiBaseUrlInput.value.trim(); 
    const apiKey = elements.apiKeyInput.value.trim(); 
    const model = elements.modelSelect.value; 
    if (!apiBaseUrl || !apiKey || !model) { 
        alert('请先在设置中填写API信息。'); 
        return; 
    } 
    isVideoCallActive = true; 
    elements.videoMainView.src = config.aiAvatar; 

    // 【核心修复】从与角色绑定的 userProfile 中获取您的头像
    elements.videoSelfView.src = character.userProfile.chatAvatar || ''; 
    
    elements.videoCharacterAvatar.src = config.aiAvatar; 
    elements.videoCharacterName.textContent = config.characterName; 
    elements.videoStatusText.textContent = "正在呼叫..."; 
    elements.videoChatLog.innerHTML = ''; 
    elements.videoControls.innerHTML = `<button class="video-btn decline"><svg viewBox="0 0 24 24"><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.02.74-.25 1.02l-2.2 2.2z"/></svg></button>`;
    elements.videoControls.querySelector('.decline').onclick = endVideoCall; 
    elements.videoCallOverlay.classList.add('show'); 
    addVideoChatMessageToUI({ sender: 'user', text: '[发起视频通话]' }); 
    triggerVideoCallAIResponse(); 
};
// --- 到这里结束复制 ---
        // --- 【修复4/5】从这里开始完整复制 ---
const handleIncomingVideoCall = (text) => {
    if (currentChat.type !== 'direct') return;
    const character = getCurrentCharacter();
    if (!character) return;
    const { config } = character;
    
    elements.videoMainView.src = config.aiAvatar;

    // 【核心修复】从与角色绑定的 userProfile 中获取您的头像
    elements.videoSelfView.src = character.userProfile.chatAvatar || '';
    
    elements.videoCharacterAvatar.src = config.aiAvatar;
    elements.videoCharacterName.textContent = config.characterName;
    elements.videoStatusText.textContent = text || "视频来电...";
    elements.videoChatLog.innerHTML = '';
    elements.videoControls.innerHTML = `<button class="video-btn accept"><svg viewBox="0 0 24 24"><path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.21-3.72-6.56-6.56l1.97-1.57c.27-.27.36-.66.24-1.01-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19c-.55 0-.99.45-.99.99 0 9.02 7.38 16.4 16.4 16.4.55 0 .99-.45.99-.99v-3.47c0-.54-.45-.99-.99-.99z"/></svg></button> <button class="video-btn decline"><svg viewBox="0 0 24 24"><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.02.74-.25 1.02l-2.2 2.2z"/></svg></button>`;
    elements.videoControls.querySelector('.accept').onclick = () => {
        isVideoCallActive = true;
        elements.videoStatusText.textContent = "已接通";
        const acceptBtn = elements.videoControls.querySelector('.accept');
        if (acceptBtn) acceptBtn.remove();
        addVideoChatMessageToUI({ sender: 'user', text: '[接听了视频通话]' });
        triggerVideoCallAIResponse();
    };
    elements.videoControls.querySelector('.decline').onclick = endVideoCall;
    elements.videoCallOverlay.classList.add('show');
};
// --- 到这里结束复制 ---
        const endVideoCall = () => {
    // 只有在通话被接听后(isVideoCallActive为true)，并且有聊天内容时，才保存通话记录
    if (isVideoCallActive && elements.videoChatLog.children.length > 1) {
        const character = getCurrentCharacter();
        if (character) {
            const conversationForAI = Array.from(elements.videoChatLog.children).map(el => {
                const speaker = el.classList.contains('user') ? 'user' : character.config.characterName;
                return `${speaker}: ${el.textContent}`;
            }).join('\n');
            const memoryContent = `[我刚刚和用户结束了一次视频通话，为了记住我们聊了什么，这是通话记录：\n${conversationForAI}\n]`;
            addMessage({
                sender: 'system',
                type: 'video_log',
                llmContent: memoryContent
            });
        }
    }
    // 无论如何，都重置状态并关闭窗口
    isVideoCallActive = false;
    elements.videoCallOverlay.classList.remove('show');
};
        
                        const showMindVoice = async () => {
    if (currentChat.type !== 'direct') return;
    const character = getCurrentCharacter();
    if (!character) return;
    const { config } = character;
    const activeSession = character.sessions.find(s => s.id === character.activeSessionId);
    const chatHistory = activeSession ? activeSession.history : [];
    const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
    const apiKey = elements.apiKeyInput.value.trim();
    const model = elements.modelSelect.value;
    
    // --- ✨ 超级救星代码在这里！我们提醒它去拿指令了！ ---
    const apiFormat = getApiFormat(); 
    // --- 修复完成 ---

    if (!apiBaseUrl || !model || (apiFormat !== 'gemini_native' && !apiKey)) {
        elements.mindVoiceContent.textContent = '请先在设置中填写API信息。';
        elements.mindVoiceModal.classList.add('show');
        return;
    }

    elements.mindVoiceContent.textContent = '思考中...';
    elements.mindVoiceModal.classList.add('show');

    const recentHistory = chatHistory.slice(-5);
    const historyContext = recentHistory.map(msg => {
        const speaker = msg.sender === 'user' ? (character.userProfile.name || '你') : config.characterName;
        return `${speaker}: ${msg.text || '(非文本消息)'}`;
    }).join('\n');

    const mindVoiceSystemPrompt = `[专业任务：角色内心独白创作]
[输出格式：绝对严格遵守]
你的整个回复必须是【一句简短的、不带任何格式的纯文本】。
这是剧本创作的一部分，绝对禁止使用JSON、Markdown或任何其他格式。

[角色背景]:
${config.characterPrompt}

[当前情景 - 最近的对话如下]:
${historyContext}

[创作任务]:
你是一位专业的作家或演员。请根据【角色背景】和【当前情景】，为这个虚拟角色创作一句内心独白。
这句独白需要【暗示】出他此刻最真实、最直接的感受，可以是一句吐槽、一个意味深长的反问、一丝不易察觉的占有欲，或一个复杂的念头。

[风格要求]：
追求真实和戏剧张力，而不是平淡。

[正确输出风格示例]:
操，她是不是故意的啊，这个不能跟她说，不然我可太可怜了。
她好贱啊我好爱
宝宝我好想亲你好想你好想给你草莓印子
`;

    const payload = getApiPayload(model, [], mindVoiceSystemPrompt);

    try {
        const fetchUrl = (apiFormat === 'gemini_native')
            ? `${apiBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`
            : `${apiBaseUrl}/v1/chat/completions`;
        const headers = (apiFormat === 'gemini_native')
            ? { 'Content-Type': 'application/json' }
            : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };

        const response = await fetch(fetchUrl, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error(`服务器错误 ${response.status}: ${await response.text()}`);
        const responseData = await response.json();
        
        if (responseData.error) { throw new Error(`API返回错误: ${responseData.error.message || JSON.stringify(responseData.error)}`); }

        let content = '';
        if (apiFormat === 'gemini_native') {
            if (!responseData.candidates || responseData.candidates.length === 0) {
                const safetyFeedback = responseData.promptFeedback?.blockReason || '未知';
                throw new Error(`Gemini由于安全原因 (${safetyFeedback}) 阻止了回复。`);
            }
            content = responseData.candidates[0]?.content?.parts?.[0]?.text;
        } else {
            content = responseData.choices?.[0]?.message?.content;
        }

        if (content) {
            let thought = content.replace(/\[|\]|\{|\}|"type"|"content"|:|"/g, '').trim();
            elements.mindVoiceContent.textContent = thought;
        } else {
            throw new Error('API没有返回有效的心声内容。');
        }
    } catch (error) {
        elements.mindVoiceContent.textContent = `读取心声失败: ${error.message}`;
    }
};

                                        const openStickerManager = (context) => {
    // 【核心改造】现在统一从全局配置中读取和管理AI表情包
    const isAiContext = context === 'ai';

    // 确保全局AI表情仓库存在且格式正确
    if (isAiContext) {
        userMomentsProfile.globalAiStickers = (userMomentsProfile.globalAiStickers || []).map(s => (typeof s === 'string') ? { url: s, description: '' } : s);
    } else {
        userMomentsProfile.userStickers = (userMomentsProfile.userStickers || []).map(s => (typeof s === 'string') ? { url: s, description: '' } : s);
    }
    const stickerData = isAiContext ? userMomentsProfile.globalAiStickers : userMomentsProfile.userStickers;
    
    let galleryContentHtml = stickerData.length > 0
        ? stickerData.map((sticker, index) => `
            <div class="sticker-management-item" data-index="${index}">
                <img src="${sticker.url}" alt="sticker">
                <button class="sticker-delete-btn">×</button>
                ${isAiContext ? `<input type="text" class="sticker-description-input" placeholder="为表情添加描述..." value="${sticker.description || ''}">` : ''}
            </div>
        `).join('')
        : '<p style="text-align:center; color:#999; grid-column: 1 / -1;">点击下方按钮添加，点击表情上的 × 可删除。</p>';

    const galleryHtml = `<div class="sticker-management-grid">${galleryContentHtml}</div>`;

    openFeatureModal(
        isAiContext ? 'AI表情包仓库 (所有角色共用)' : '我的表情管理',
        galleryHtml + `<button id="add-stickers-btn" class="file-input-label" style="text-align:center; width:100%; margin-top:15px;">从相册批量添加</button>`,
        '完成',
        () => {
            if (isAiContext) {
                const inputs = document.querySelectorAll('.sticker-description-input');
                inputs.forEach((input, index) => {
                    if (userMomentsProfile.globalAiStickers && userMomentsProfile.globalAiStickers[index]) {
                        userMomentsProfile.globalAiStickers[index].description = input.value;
                    }
                });
            }
            saveAllData(); // 无论哪种情况，都保存一下
            closeModal(elements.featureModal);
        }
    );
    
    const modalBody = getEl('feature-modal-body');
    if (modalBody.querySelector('#add-stickers-btn')) {
        modalBody.querySelector('#add-stickers-btn').onclick = () => elements.stickerUploadInput.click();
    }
    
    const grid = modalBody.querySelector('.sticker-management-grid');
    if (grid) {
        grid.addEventListener('click', (e) => {
            if (e.target.classList.contains('sticker-delete-btn')) {
                const item = e.target.closest('.sticker-management-item');
                const index = parseInt(item.dataset.index);
                if (confirm('要删除这个表情吗？')) {
                    stickerData.splice(index, 1);
                    saveAllData();
                    closeModal(elements.featureModal);
                    openStickerManager(context);
                }
            }
        });
    }

    elements.stickerUploadInput.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;

        closeModal(elements.featureModal);
        const character = getCurrentCharacter();
        const notificationAvatar = isAiContext ? (character?.config.aiAvatar || '') : (character?.userProfile.chatAvatar || '');
        showTopNotification("正在后台努力添加表情中...", notificationAvatar);

        for (const file of files) {
            const result = await new Promise(resolve => handleFileUpload(file, resolve));
            const newSticker = { url: result, description: '' };
            stickerData.push(newSticker);
        }
        
        await saveAllData();
        alert(`已成功添加 ${files.length} 个表情！`);
        openStickerManager(context);
        e.target.value = '';
    };
};

        // --- Chat Management Logic (Characters & Groups) ---
        const openChatManager = () => {
            const bodyHtml = `
                <div class="chat-manager-tabs">
                    <div class="chat-manager-tab active" data-tab="direct">单人聊天</div>
                    <div class="chat-manager-tab" data-tab="group">群组聊天</div>
                </div>
                <div id="direct-chat-list" class="chat-manager-content active">
                    <div class="chat-list">
                        ${characterSets.map(char => `
                            <div class="chat-item ${currentChat.type === 'direct' && char.id === currentChat.id ? 'active' : ''}" data-type="direct" data-id="${char.id}">
                                <img src="${char.config.aiAvatar}" alt="${char.config.characterName}">
                                <span class="name">${char.config.characterName}</span>
                                <button class="delete-btn" data-type="direct" data-id="${char.id}" title="删除角色">×</button>
                            </div>
                        `).join('')}
                    </div>
                    <button id="add-character-btn" class="add-new-btn">创建新角色</button>
                </div>
                <div id="group-chat-list" class="chat-manager-content">
                     <div class="chat-list">
                        ${groupChats.map(group => `
                            <div class="chat-item ${currentChat.type === 'group' && group.id === currentChat.id ? 'active' : ''}" data-type="group" data-id="${group.id}">
                                <img src="${group.avatar}" alt="${group.name}">
                                <span class="name">${group.name}</span>
                                <button class="delete-btn" data-type="group" data-id="${group.id}" title="删除群组">×</button>
                            </div>
                        `).join('')}
                    </div>
                    <button id="add-group-btn" class="add-new-btn">创建新群聊</button>
                </div>
            `;
            openFeatureModal('切换聊天', bodyHtml, null, null);

            const modalBody = getEl('feature-modal-body');
            modalBody.querySelectorAll('.chat-manager-tab').forEach(tab => {
                tab.onclick = () => {
                    modalBody.querySelector('.chat-manager-tab.active').classList.remove('active');
                    tab.classList.add('active');
                    modalBody.querySelector('.chat-manager-content.active').classList.remove('active');
                    getEl(tab.dataset.tab + '-chat-list').classList.add('active');
                };
            });
            
            modalBody.onclick = (e) => {
                const item = e.target.closest('.chat-item');
                const deleteBtn = e.target.closest('.delete-btn');
                const addCharBtn = e.target.closest('#add-character-btn');
                const addGroupBtn = e.target.closest('#add-group-btn');

                if (deleteBtn) {
                    e.stopPropagation();
                    handleDeleteChat(deleteBtn.dataset.type, deleteBtn.dataset.id);
                } else if (item) {
                    loadChat(item.dataset.type, item.dataset.id);
                    closeModal(elements.featureModal);
                } else if (addCharBtn) {
                    const newChar = createNewCharacterObject();
                    characterSets.push(newChar);
                    saveAllData();
                    loadChat('direct', newChar.id);
                    closeModal(elements.featureModal);
                    elements.settingsBtn.click();
                } else if (addGroupBtn) {
                    openCreateGroupModal();
                }
            };
        };

        const openCreateGroupModal = () => {
            let tempGroupAvatar = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2EwYTBiMyI+PHBhdGggZD0iTTExIDEyYy0uNTUgMC0xLS40NS0xLTFzLjQ1LTEgMS0xIDEgLjQ1IDEgMXMtLjQ1IDEtMSAxem00IDBjLS41NSAwLTEtLjQ1LTEtMXMuNDUtMSAxLTEgMSAuNDUgMSAxcy0uNDUgMS0xIDF6bS04IDBjLS41NSAwLTEtLjQ1LTEtMXMuNDUtMSAxLTEgMSAuNDUgMSAxcy0uNDUgMS0xIDF6bTEwLThINWMtMS4xIDAtMiAuOS0yIDJ2MTRsNC00aDEyYzEuMSAwIDItLjkgMi0yVjZjMC0xLjEtLjktMi0yLTJ6bTAtMTJoMTJjMS4xIDAgMiAuOSAyIDJ2MTBsMiAydjQtMmMwLTEuMS0uOS0yLTItMkg2bC00IDRWMnYyaDR6Ii8+PC9zdmc+';
            const memberSelectionHtml = characterSets.map(c => `
                <label class="member-select-item">
                    <input type="checkbox" name="group-members" value="${c.id}">
                    <img src="${c.config.aiAvatar}" style="width: 30px; height: 30px; border-radius: 6px;">
                    <span>${c.config.characterName}</span>
                </label>
            `).join('');

            const bodyHtml = `
                <div class="form-group avatar-upload-group" style="justify-content:center; flex-direction:column;">
                    <img id="new-group-avatar-preview" src="${tempGroupAvatar}" class="avatar-preview" style="width:80px;height:80px;border-radius:12px;cursor:pointer;">
                    <label for="group-avatar-upload-input" class="file-input-label" style="margin-top:10px;">选择群头像</label>
                </div>
                <div class="form-group"><label for="new-group-name">群名称</label><input type="text" id="new-group-name" placeholder="欢乐一家人"></div>
                <div class="form-group"><label>选择成员</label><div id="create-group-members">${memberSelectionHtml}</div></div>
            `;
            openFeatureModal('创建新群聊', bodyHtml, '创建', () => {
                const name = getEl('new-group-name').value.trim() || '欢乐一家人';
                const selectedMembers = Array.from(document.querySelectorAll('input[name="group-members"]:checked')).map(cb => cb.value);
                if (selectedMembers.length < 1) {
                    alert('请至少选择一位成员。');
                    return;
                }
                const newGroup = createNewGroupObject(name, tempGroupAvatar, selectedMembers);
                groupChats.push(newGroup);
                saveAllData();
                loadChat('group', newGroup.id);
                closeModal(elements.featureModal);
            });
            
            getEl('new-group-avatar-preview').onclick = () => elements.groupAvatarUploadInput.click();
            elements.groupAvatarUploadInput.onchange = e => handleFileUpload(e.target.files[0], d => {
                tempGroupAvatar = d;
                getEl('new-group-avatar-preview').src = d;
            });
        };

        const handleDeleteChat = (type, idToDelete) => {
            if (type === 'direct') {
                 if (characterSets.length <= 1) {
                    alert("必须保留至少一个角色。");
                    return;
                }
                const charToDelete = characterSets.find(c => c.id === idToDelete);
                if (confirm(`确定要删除角色「${charToDelete.config.characterName}」吗？`)) {
                    characterSets = characterSets.filter(c => c.id !== idToDelete);
                    if (currentChat.id === idToDelete) {
                        loadChat('direct', characterSets[0].id);
                    }
                    saveAllData();
                    openChatManager(); 
                }
            } else { // group
                const groupToDelete = groupChats.find(g => g.id === idToDelete);
                if (confirm(`确定要删除群聊「${groupToDelete.name}」吗？`)) {
                    groupChats = groupChats.filter(g => g.id !== idToDelete);
                     if (currentChat.id === idToDelete) {
                        loadChat('direct', characterSets[0].id);
                    }
                    saveAllData();
                    openChatManager();
                }
            }
             closeModal(elements.settingsModal);
        };

               const addMomentByAI = (characterId, momentData, momentType) => {
    const character = characterSets.find(c => c.id === characterId);
    if (!character) return;
    const imageUrl = null;
    const newMoment = { id: generateId('moment'), senderId: character.id, timestamp: getFullTimestamp(), likes: [], comments: [], content: momentData.content, imageUrl };
    
    showTopNotification(`${character.config.characterName} 发布了一条新动态`, character.config.aiAvatar);

    if (momentType === 'direct') {
        if (!character.moments) character.moments = [];
        character.moments.unshift(newMoment);
    } else if (momentType === 'group') {
        const group = getCurrentGroup();
        if (group) {
            if (!group.groupMoments) group.groupMoments = [];
            group.groupMoments.unshift(newMoment);

            // **核心新增：触发其他群成员来评论**
            const otherMembers = group.memberIds.filter(id => id !== characterId && characterSets.some(c => c.id === id));
            otherMembers.forEach((memberId, index) => {
                setTimeout(() => {
                    if (Math.random() > 0.4) { // 60%的几率来评论
                        triggerAiMomentComment(newMoment, memberId, 'group');
                    }
                }, (index + 1) * 5000 + Math.random() * 3000); // 错开时间，显得更自然
            });
        }
    }
    saveAllData();
    if(elements.momentsOverlay.classList.contains('show')) renderMoments();
};
            const addMomentByUser = async (momentData) => {
    const newMoment = { id: generateId('moment'), senderId: 'user', timestamp: getFullTimestamp(), likes: [], comments: [], ...momentData };
    
    let momentTypeForAI;
    // 智能判断应该把动态发到哪里
    if (currentChat.type === 'group') {
        const group = getCurrentGroup();
        if (group) {
            if (!group.groupMoments) group.groupMoments = [];
            group.groupMoments.unshift(newMoment);
            momentTypeForAI = 'group';
        }
    } else {
        // 默认发到个人朋友圈
        if (!userMomentsProfile.posts) userMomentsProfile.posts = [];
        userMomentsProfile.posts.unshift(newMoment);
        momentTypeForAI = 'direct';
    }

    saveAllData();
    openMoments(); // 重新打开朋友圈以刷新

    // AI自动评论的逻辑保持不变，但确保触发逻辑更健壮
    const relevantChars = currentChat.type === 'direct' 
        ? [getCurrentCharacter()].filter(Boolean)
        : (getCurrentGroup() ? getCurrentGroup().memberIds.map(id => characterSets.find(c => c.id === id)).filter(Boolean) : []);
    
    for (let i = 0; i < relevantChars.length; i++) {
        const char = relevantChars[i];
        setTimeout(() => {
            // 在单人聊天中，有很大概率会评论
            const shouldComment = (currentChat.type === 'direct') ? (Math.random() > 0.1) : (Math.random() > 0.3);
            if (shouldComment) {
                triggerAiMomentComment(newMoment, char.id, momentTypeForAI);
            }
        }, (i + 1) * 4000 + Math.random() * 2000); 
    }
};
                                                                                                                                                            const triggerAiMomentComment = async (moment, commenterId, momentType) => {
    try {
        const commenterChar = characterSets.find(c => c.id === commenterId);
        if (!commenterChar) return;

        const postedByChar = characterSets.find(c => c.id === moment.senderId);
        const postedBy = moment.senderId === 'user' ? (userMomentsProfile.name || '我') : (postedByChar?.config.characterName || '一位朋友');
        
        const chatData = getCurrentChatData();
        const activeSession = chatData ? chatData.sessions?.find(s => s.id === chatData.activeSessionId) : null;
        const recentHistory = activeSession ? activeSession.history.slice(-5) : [];
        const historyContext = recentHistory.map(msg => `${msg.sender === 'user' ? 'User' : 'AI'}: ${msg.text || '(非文本消息)'}`).join('\n');
        
        const modelName = elements.modelSelect.value.toLowerCase();
        const isVisionModel = modelName.includes('vision') || modelName.includes('4o') || modelName.includes('gemini-1.5');
        
        let imageContext = '';
        let imageUrlForApi = null;
        if (moment.imageUrl) {
            if (isVisionModel) {
                imageContext = "The post also includes an image you can see.";
                imageUrlForApi = moment.imageUrl;
            } else {
                imageContext = "The post also includes an image, but you cannot see it.";
            }
        }

        const finalPrompt = `[Role]: You are ${commenterChar.config.characterName}. Your persona is: ${commenterChar.config.characterPrompt}
${CORE_BEHAVIOR_PROMPT}
[Recent Conversation Context]:
${historyContext}
[Current Situation]: You see a social media post from ${postedBy}. The post says: "${moment.content}". ${imageContext}
[Task]: Based on ALL the information above (your persona, the conversation, and the image if you can see it), write a short, natural, first-person comment in Simplified Chinese.
[CRITICAL OUTPUT FORMAT]: Your entire response MUST be a valid JSON array containing a single object, like this example:
[{"type": "moment_comment", "momentId": "${moment.id}", "comment_text": "Your actual comment text here."}]
Do NOT leave the comment_text empty. Do NOT add any text, markdown, or explanations outside the JSON array.`;

        const payload = getApiPayload(elements.modelSelect.value, [], finalPrompt, imageUrlForApi);
        
        const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
        const apiKey = elements.apiKeyInput.value.trim();
        const model = elements.modelSelect.value;
        const isGemini = apiBaseUrl.includes('google');
        
        const fetchUrl = isGemini ? `${apiBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}` : `${apiBaseUrl}/v1/chat/completions`;
        const headers = isGemini ? { 'Content-Type': 'application/json' } : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };

        const response = await fetch(fetchUrl, { method: 'POST', headers: headers, body: JSON.stringify(payload) });
        const rawText = await response.text();
        if (!response.ok) throw new Error(`API请求失败，官方报告 Status Code: ${response.status}`);

        const responseData = JSON.parse(rawText);
        let aiResponseText = '';
        if (isGemini) {
            if (!responseData.candidates || responseData.candidates.length === 0) { throw new Error("Gemini的candidates列表为空。"); }
            aiResponseText = responseData.candidates[0].content.parts.map(part => part.text || '').join('');
        } else {
            aiResponseText = responseData.choices?.[0]?.message?.content;
        }

        if (!aiResponseText) { throw new Error("AI的响应中没有有效的文本内容。"); }

        const cleanedJsonString = aiResponseText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');
        const jsonAction = JSON.parse(cleanedJsonString);

        if (jsonAction && Array.isArray(jsonAction) && jsonAction[0] && jsonAction[0].type === 'moment_comment' && jsonAction[0].comment_text && jsonAction[0].comment_text.trim() !== "") {
            addCommentOrReplyByAI('comment', moment.id, jsonAction[0].comment_text, commenterId, null, momentType);
        } else {
            console.error("最终解析出的JSON无效或内容为空。", jsonAction);
        }
    } catch (error) { 
        console.error("【重大错误】Moment comment AI trigger error:", error); 
    }
};
                                                                                                                                                            const triggerAiMomentReply = async (moment, commentToReply, replierId, momentType) => {
    try {
        const replierChar = characterSets.find(c => c.id === replierId);
        if (!replierChar) return;

        const originalPosterName = characterSets.find(c => c.id === moment.senderId)?.config.characterName || (userMomentsProfile.name || '我');
        const personBeingRepliedToName = characterSets.find(c => c.id === commentToReply.sender)?.config.characterName || (userMomentsProfile.name || '我');
        const chatData = getCurrentChatData();
        const activeSession = chatData ? chatData.sessions?.find(s => s.id === chatData.activeSessionId) : null;
        const recentHistory = activeSession ? activeSession.history.slice(-5) : [];
        const historyContext = recentHistory.map(msg => `${msg.sender === 'user' ? 'User' : 'AI'}: ${msg.text || '(非文本消息)'}`).join('\n');
        
        const finalPrompt = `[Role]: You are ${replierChar.config.characterName} (ID: ${replierId}). Your persona is: ${replierChar.config.characterPrompt}
${CORE_BEHAVIOR_PROMPT}
[Recent Conversation Context]:
${historyContext}
[Current Situation]: On ${originalPosterName}'s social media post, ${personBeingRepliedToName} left a comment saying: "${commentToReply.text}".
[Task]: Now, write a short, natural, first-person reply in Simplified Chinese to ${personBeingRepliedToName}'s comment.
[CRITICAL OUTPUT FORMAT]: Your entire response MUST be a valid JSON array containing a single object. It MUST include your own senderId. Example:
[{"senderId": "${replierId}", "type": "moment_reply", "momentId": "${moment.id}", "commentId": "${commentToReply.id}", "reply_text": "Your actual reply text here."}]
Do NOT leave the reply_text empty. Do NOT add any text, markdown, or explanations outside the JSON array.`;
        
        const payload = getApiPayload(elements.modelSelect.value, [], finalPrompt);

        const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
        const apiKey = elements.apiKeyInput.value.trim();
        const model = elements.modelSelect.value;
        const isGemini = apiBaseUrl.includes('google');
        
        const fetchUrl = isGemini ? `${apiBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}` : `${apiBaseUrl}/v1/chat/completions`;
        const headers = isGemini ? { 'Content-Type': 'application/json' } : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };
        
        const response = await fetch(fetchUrl, { method: 'POST', headers: headers, body: JSON.stringify(payload) });
        const rawText = await response.text();
        if (!response.ok) throw new Error(`API请求失败: ${rawText}`);

        const responseData = JSON.parse(rawText);
        let aiResponseText = '';
        if (isGemini) {
            if (!responseData.candidates) { throw new Error("Gemini的candidates列表为空。"); }
            aiResponseText = responseData.candidates[0].content.parts.map(part => part.text || '').join('');
        } else {
            aiResponseText = responseData.choices?.[0]?.message?.content;
        }

        if (!aiResponseText) { throw new Error("AI的响应中没有有效的文本内容。"); }
        
        const cleanedJsonString = aiResponseText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');
        processAiResponse(cleanedJsonString);
        
    } catch (error) { 
        console.error("【重大错误】AI trigger reply error:", error); 
    }
};
            
        const openMoments = () => { renderMoments(); elements.momentsOverlay.classList.add('show'); };
        
        const openPostMomentModal = () => {
    let tempImage = null;
    const bodyHtml = `
        <div class="form-group">
            <textarea id="new-moment-text" rows="5" placeholder="在想些什么？"></textarea>
        </div>
        <div class="form-group">
            <label id="add-moment-image-label" for="moment-post-image-input" class="file-input-label">添加图片</label>
            <img id="new-moment-preview" src="" style="max-width: 100px; max-height: 100px; border-radius: 8px; margin-top: 10px; display: none;">
        </div>
    `;
    openFeatureModal('发布新动态', bodyHtml, '发布', () => {
        const text = getEl('new-moment-text').value.trim();
        if (text || tempImage) {
            addMomentByUser({ content: text, imageUrl: tempImage });
            closeModal(elements.featureModal);
        }
    });
    const preview = getEl('new-moment-preview');
    // 【核心修复】我们现在通过唯一的ID来准确找到并绑定点击事件
    getEl('add-moment-image-label').onclick = () => elements.momentPostImageInput.click();
    elements.momentPostImageInput.onchange = e => handleFileUpload(e.target.files[0], (dataUrl) => {
        tempImage = dataUrl;
        preview.src = dataUrl;
        preview.style.display = 'block';
    });
};
        
        const openCreateRedPacketModal = () => {
            const bodyHtml = `
                <div class="form-group"><label for="red-packet-amount">总金额</label><input type="number" id="red-packet-amount" placeholder="0.00"></div>
                <div class="form-group"><label for="red-packet-count">红包个数</label><input type="number" id="red-packet-count" placeholder="例如: 5"></div>
                <div class="form-group"><label for="red-packet-memo">祝福语</label><input type="text" id="red-packet-memo" value="恭喜发财，大吉大利"></div>
            `;
            openFeatureModal('发红包', bodyHtml, '塞钱进红包', () => {
                const amount = parseFloat(getEl('red-packet-amount').value);
                const count = parseInt(getEl('red-packet-count').value);
                const memo = getEl('red-packet-memo').value.trim() || '恭喜发财，大吉大利';
                const group = getCurrentGroup();
                if (!group || amount <= 0 || count <= 0) { alert('请输入有效的金额和数量。'); return; }
                if (count > group.memberIds.length + 1) { alert('红包个数不能超过群成员总数。'); return; }
                if (amount < count * 0.01) { alert('总金额不足以让每个红包至少有0.01元。'); return; }

                handleUserAction({ 
                    sender: 'user', type: 'red-packet', packetId: generateId('rp'),
                    amount, count, memo, grabbers: {}, status: 'open',
                    llmContent: `[用户发了一个红包。祝福语: "${memo}"]` 
                });
                closeModal(elements.featureModal);
            });
        };

                                const renderRedPacket = (msg) => {
            if (!msg || typeof msg !== 'object') return '<p>红包数据错误</p>';
            const grabbers = msg.grabbers || {}; 
            const { packetId, memo, count, status } = msg;
            
            if (!packetId || !count) return '<p>红包信息不完整</p>';
            const hasGrabbed = Object.keys(grabbers).includes('user');
            const isFullyClaimed = Object.keys(grabbers).length >= count;
            let resultsHtml = '';
            if (Object.keys(grabbers).length > 0) {
                const items = Object.entries(grabbers).map(([id, amount]) => {
                    let name = '未知';
                    if (id === 'user') {
                        name = userMomentsProfile.name || '我';
                    } else {
                        const character = characterSets.find(c => c && c.id === id);
                        if (character && character.config) {
                            name = character.config.characterName;
                        }
                    }
                    const amountDisplay = typeof amount === 'number' ? amount.toFixed(2) : '...';
                    return `<div class="red-packet-result-item"><span>${name}</span><span>${amountDisplay}元</span></div>`;
                }).join('');
                resultsHtml = `<div class="red-packet-results">${items}</div>`;
            }
            const buttonHtml = (!hasGrabbed && !isFullyClaimed) ? `<button class="red-packet-grab-btn" onclick="handleGrabRedPacket('${packetId}')">开</button>` : '';
            const footerText = isFullyClaimed 
                ? `${count}个红包，已被抢完` 
                : (Object.keys(grabbers).length > 0 ? `已领取${Object.keys(grabbers).length}/${count}个` : `群红包，共${count}个`);
            return `<div class="red-packet-body"><div class="red-packet-body-header"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 4H6C4.9 4 4 4.9 4 6v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-6 11.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 6.5 12 6.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5z"/></svg><span class="red-packet-memo">${memo || '恭喜发财，大吉大利'}</span></div>${buttonHtml}</div>${resultsHtml}<div class="red-packet-footer">${footerText}</div>`;
        };
        
        window.handleGrabRedPacket = (packetId) => { // Make it global for inline onclick
            const group = getCurrentGroup();
            if (!group) return;
            const packet = group.chatHistory.find(m => m.packetId === packetId);
            if (!packet || packet.status === 'claimed' || Object.keys(packet.grabbers).includes('user')) return;
            const remainingAmount = packet.amount - Object.values(packet.grabbers).reduce((a, b) => a + b, 0);
            const remainingCount = packet.count - Object.keys(packet.grabbers).length;
            let grabbedAmount;
            if (remainingCount === 1) { grabbedAmount = remainingAmount; } 
            else { const min = 0.01; const max = (remainingAmount - (remainingCount - 1) * min); grabbedAmount = Math.random() * (max - min) + min; }
            packet.grabbers['user'] = parseFloat(grabbedAmount.toFixed(2));
            if (Object.keys(packet.grabbers).length >= packet.count) packet.status = 'claimed';
            saveAllData(); renderAllMessages();
            handleUserAction({ sender: 'user', type: 'text', text: `[我领取了红包]`, llmContent: `[用户领取了红包]` });
        };
        
                const handleAiGrabRedPacket = (packetId, grabberId) => {
            const group = getCurrentGroup(); if (!group) return;
            const packet = group.chatHistory.find(m => m.packetId === packetId);
            if (!packet || packet.status === 'claimed' || Object.keys(packet.grabbers).includes(grabberId)) return;
            const remainingAmount = packet.amount - Object.values(packet.grabbers).reduce((a, b) => a + b, 0);
            const remainingCount = packet.count - Object.keys(packet.grabbers).length;
            if (remainingCount <= 0) return;
            let grabbedAmount;
            if (remainingCount === 1) { grabbedAmount = remainingAmount; }
            else { const min = 0.01; const max = (remainingAmount - (remainingCount - 1) * min); grabbedAmount = Math.max(min, Math.random() * (Math.max(max, min) - min) + min); }
            const finalGrabbedAmount = parseFloat(grabbedAmount.toFixed(2));
            packet.grabbers[grabberId] = finalGrabbedAmount; 
            if (Object.keys(packet.grabbers).length >= packet.count) packet.status = 'claimed';
            saveAllData();
            return finalGrabbedAmount;
        };

        // --- Poll Logic ---
        const openCreatePollModal = () => { const bodyHtml = ` <div class="form-group"><label for="poll-question">投票问题</label><input type="text" id="poll-question" placeholder="晚饭吃什么？"></div> <div class="form-group"><label>选项 (每行一个)</label><textarea id="poll-options" rows="4" placeholder="披萨\n寿司\n墨西哥卷饼"></textarea></div> `; openFeatureModal('创建投票', bodyHtml, '创建', () => { const question = getEl('poll-question').value.trim(); const options = getEl('poll-options').value.split('\n').map(o => o.trim()).filter(o => o); if (question && options.length >= 2) { const pollId = generateId('poll'); handleUserAction({ sender: 'user', type: 'poll', pollId, question, options, llmContent: `[用户发起了一个投票。问题: "${question}", 选项: ${options.join(", ")}]` }); closeModal(elements.featureModal); } else { alert('请输入问题和至少两个选项。'); } }); };
        const renderPoll = (msg) => { const group = getCurrentGroup(); if (!group) return ''; const pollData = (group.polls || []).find(p => p.pollId === msg.pollId); if (!pollData) return `<p>投票数据加载失败。</p>`; const totalVotes = Object.values(pollData.votes).flat().length; const userHasVoted = Object.values(pollData.votes).flat().includes('user'); const optionsHtml = pollData.options.map(option => { const voters = pollData.votes[option] || []; const voteCount = voters.length; const percentage = totalVotes > 0 ? (voteCount / totalVotes * 100).toFixed(0) : 0; const voterAvatars = voters.map(voterId => { const avatarSrc = voterId === 'user' ? userMomentsProfile.chatAvatar : characterSets.find(c => c.id === voterId)?.config.aiAvatar; return avatarSrc ? `<img src="${avatarSrc}" class="poll-voter-avatar" title="${characterSets.find(c=>c.id===voterId)?.config.characterName || '我'}">` : ''; }).join(''); return ` <div class="poll-option"> <div class="poll-option-label">${option} (${voteCount}票)</div> <div class="poll-progress-bar"> <div class="poll-progress-fill" style="width: ${percentage}%;"> <span class="poll-percentage">${percentage}%</span> </div> </div> <div class="poll-voters">${voterAvatars}</div> ${!userHasVoted ? `<button class="poll-vote-btn" data-poll-id="${pollData.pollId}" data-option="${option}">投这一票</button>` : ''} </div>`; }).join(''); return `<div class="poll-question">${pollData.question}</div>${optionsHtml}`; };
        const handleUserVote = (pollId, option) => { const group = getCurrentGroup(); if (!group) return; const poll = (group.polls || []).find(p => p.pollId === pollId); if (!poll || poll.status === 'closed') return; Object.keys(poll.votes).forEach(key => { poll.votes[key] = (poll.votes[key] || []).filter(v => v !== 'user'); }); if (!poll.votes[option]) poll.votes[option] = []; poll.votes[option].push('user'); saveAllData(); renderAllMessages(); handleUserAction({ sender: 'user', type: 'text', text: `[我投了: 「${option}」]`, llmContent: `[用户投票了。选项: "${option}"]` }); };
        const handleAiVote_dataOnly = (voteAction) => { const group = getCurrentGroup(); if (!group) return; const poll = (group.polls || []).find(p => p.pollId === voteAction.pollId); const voterId = voteAction.senderId; const option = voteAction.option; if (!poll || !voterId || !option || poll.status === 'closed' || !poll.options.includes(option)) return; Object.keys(poll.votes).forEach(key => { poll.votes[key] = (poll.votes[key] || []).filter(v => v !== voterId); }); if (!poll.votes[option]) poll.votes[option] = []; poll.votes[option].push(voterId); saveAllData(); };
        
            

                      // ===================================================================
// ============= 全新的、修复后的朋友圈“渲染引擎” =============
// ===================================================================

// “配菜”菜谱 1：评论扁平化工具
const flattenComments = (comments) => {
    const flatList = [];
    const traverse = (commentNodes) => {
        if (!commentNodes || commentNodes.length === 0) return;
        for (const comment of commentNodes) {
            flatList.push(comment);
            traverse(comment.replies); 
        }
    };
    traverse(comments);
    return flatList;
};

// “配菜”菜谱 2：渲染评论区
const renderComments = (comments, post) => {
    const flatCommentList = flattenComments(comments);
    if (flatCommentList.length === 0) return '';
    
    return flatCommentList.map(comment => {
        const commenterChar = characterSets.find(char => char.id === comment.sender);
        const commenterName = comment.sender === 'user' ? (userMomentsProfile.name || '你')
            : (commenterChar?.config.characterName || '一位朋友');

        let repliedToName = null;
        if (comment.replyTo) {
            const repliedToChar = characterSets.find(char => char.id === comment.replyTo);
            repliedToName = comment.replyTo === 'user' 
                ? (userMomentsProfile.name || '我') 
                : (repliedToChar?.config.characterName || '一位朋友');
        }

        return `
            <div class="comment" data-comment-id="${comment.id}" data-sender-id="${comment.sender}">
                <span class="comment-user">${commenterName}</span>
                ${repliedToName ? ` <span style="color: #555; font-weight: normal;">回复</span> <span class="comment-user">${repliedToName}</span>` : ''}:
                <span class="comment-text">${comment.text}</span>
                <button class="delete-comment-btn" title="删除评论" style="background:none; border:none; color:#aaa; cursor:pointer; font-size:1.2em; padding: 0 5px;">×</button>
            </div>
        `;
    }).join('');
};

// “主菜”菜谱：渲染单条朋友圈动态
// --- 【修复5/5】从这里开始完整复制 ---
const renderSingleMoment = (post) => {
    const senderIsUser = post.senderId === 'user';
    const postChar = !senderIsUser ? characterSets.find(c => c.id === post.senderId) : null;
    
    // 【核心修复】当发动态的是您时，从正确的 character.userProfile 中获取您的朋友圈头像和名字
    const character = getCurrentCharacter();
    const userProfile = character ? character.userProfile : userMomentsProfile;
    
    const senderName = senderIsUser ? (userProfile.name || '你') : (postChar?.config.characterName || '一位朋友');
    const senderAvatar = senderIsUser ? (userProfile.momentsAvatar || '') : (postChar?.config.aiAvatar || '');
    
    const momentType = currentChat.type === 'direct' ? 'direct' : 'group';

    return `
        <div class="moment-post" data-moment-id="${post.id}" data-sender-id="${post.senderId}" data-moment-type="${momentType}">
            <img src="${senderAvatar}" alt="avatar" class="moment-avatar">
            <div class="moment-body">
                <div class="moment-username">${senderName}</div>
                <div class="moment-content">${post.content.replace(/\n/g, '<br>')}</div>
                ${post.imageUrl ? `<img src="${post.imageUrl}" alt="moment image" class="moment-image">` : ''}
                <div class="moment-footer">
                    <span class="moment-timestamp">${post.timestamp}</span>
                    <div class="moment-actions">
                        <button class="like-btn ${post.likes.includes('user') ? 'liked' : ''}">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
            <span class="like-count">${post.likes.length > 0 ? post.likes.length : ''}</span>
                        </button>
                        <button class="comment-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
                        </button>
                        <button class="delete-moment-btn" title="删除动态">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" height="18px" width="18px"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                        </button>
                    </div>
                </div>
                <div class="moment-comments">${renderComments(post.comments, post)}</div>
                <form class="comment-input-form" style="display: none;" data-reply-to="">
                    <input type="text" class="comment-input" placeholder="添加评论...">
                    <button type="submit">发送</button>
                </form>
            </div>
        </div>`;
};
// --- 到这里结束复制 ---

// 总管函数：负责组合所有朋友圈动态
// --- 【核心修复】从这里开始完整复制 ---
const renderMoments = () => {
    const chatData = getCurrentChatData(); 
    if(!chatData) { 
        elements.momentsFeed.innerHTML = ''; 
        return; 
    }
    let allPosts = [];
    elements.postNewMomentBtn.style.display = 'block';

    if (currentChat.type === 'direct') {
        const character = chatData;
        
        // 1. 获取动态列表（这部分逻辑是正确的，保持不变）
        allPosts = [
            ...(character.moments || []).map(m => ({ ...m, senderType: 'ai' })), 
            ...(userMomentsProfile.posts || []).map(p => ({ ...p, senderType: 'user' }))
        ];
        
        // 2. 【！！！这就是最关键的修复！！！】
        //    我们现在告诉程序，从与角色绑定的 userProfile 中，去拿您的朋友圈资料
        const userProfileForThisChat = character.userProfile;
        elements.momentsUserAvatar.src = userProfileForThisChat.momentsAvatar || '';
        elements.momentsUserName.textContent = userProfileForThisChat.name || '你';
        elements.momentsCoverArea.style.backgroundImage = `url(${userProfileForThisChat.momentsCover || ''})`;

    } else { // 群聊的逻辑是正确的，保持不变
        const group = chatData;
        allPosts = [...(group.groupMoments || [])];
        elements.momentsUserAvatar.src = group.avatar;
        elements.momentsUserName.textContent = group.name;
        elements.momentsCoverArea.style.backgroundImage = `url(${group.avatar})`;
    }
    
    // 3. 排序和渲染动态（这部分逻辑也是正确的，保持不变）
    allPosts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    elements.momentsFeed.innerHTML = allPosts.length === 0 
        ? `<p style="text-align:center; padding: 40px; color: #999;">这里还没有任何动态。</p>`
        : allPosts.map(post => renderSingleMoment(post)).join('');
};
// --- 到这里结束复制 ---
              // --- 全新的、用于删除评论的函数 ---
        const deleteCommentById = (commentArray, idToDelete) => {
            // 过滤掉当前层级中匹配ID的评论
            const filteredArray = commentArray.filter(comment => comment.id !== idToDelete);

            // 遍历过滤后的数组，对每一个评论的子回复进行递归操作
            filteredArray.forEach(comment => {
                if (comment.replies && comment.replies.length > 0) {
                    // 递归调用自身，处理子回复
                    comment.replies = deleteCommentById(comment.replies, idToDelete);
                }
            });

            return filteredArray;
        };
              // --- 全新的、修复AI评论和回复功能的核心函数 ---
        const addCommentOrReplyByAI = (type, momentId, text, senderId, replyToCommentId, momentType) => {
            let allPosts = [];
            if (momentType === 'direct') {
                const character = getCurrentCharacter();
                allPosts = [...(character?.moments || []), ...(userMomentsProfile.posts || [])];
            } else {
                const group = getCurrentGroup();
                allPosts = group ? [...(group.groupMoments || [])] : [];
            }
            const moment = allPosts.find(p => p.id === momentId);
            if (!moment) {
                console.error(`AI试图评论一个不存在的动态 (ID: ${momentId})`);
                return;
            }

            const newCommentByAI = { id: generateId('cmt'), sender: senderId, text, replies: [] };
            
            if (type === 'reply' && replyToCommentId) {
                newCommentByAI.replyTo = replyToCommentId; // 记录它回复的是谁的ID
                
                const findParentCommentAndPush = (comments, parentId, newReply) => {
                    for (const comment of comments) {
                        if (comment.id === parentId) {
                            if (!comment.replies) comment.replies = [];
                            comment.replies.push(newReply);
                            // 在给AI的回复中，记录它具体回复的是哪个用户的ID
                            newReply.replyTo = comment.sender;
                            return true;
                        }
                        if (comment.replies && findParentCommentAndPush(comment.replies, parentId, newReply)) {
                            return true;
                        }
                    }
                    return false;
                };
                findParentCommentAndPush(moment.comments || [], replyToCommentId, newCommentByAI);

            } else { // 'comment' type
                if (!moment.comments) moment.comments = [];
                moment.comments.push(newCommentByAI);
            }
            
            saveAllData();
            if (elements.momentsOverlay.classList.contains('show')) {
                renderMoments();
            }
        };
                       const handleMomentsInteraction = (e) => {
    const postEl = e.target.closest('.moment-post'); if (!postEl) return;
    const momentId = postEl.dataset.momentId;
    const momentType = postEl.dataset.momentType || (currentChat.type === 'group' ? 'group' : 'direct');

    let allVisiblePosts = [];
    if (momentType === 'direct') {
         const character = getCurrentCharacter();
         allVisiblePosts = [...(character?.moments || []), ...(userMomentsProfile.posts || [])];
    } else { 
        const group = getCurrentGroup(); 
        allVisiblePosts = group ? [...(group.groupMoments || [])] : []; 
    }
    
    // **修复您发的朋友圈角色不评论的bug的关键**
    // 如果在群聊里找不到这个动态，就去个人动态里找，确保能处理您自己的动态
    let moment = allVisiblePosts.find(m => m.id === momentId);
    if (!moment && momentType === 'group') {
         moment = userMomentsProfile.posts.find(p => p.id === momentId);
    }
    if (!moment) return;
    
    const likeBtn = e.target.closest('.like-btn');
    const commentBtn = e.target.closest('.comment-btn');
    const commentText = e.target.closest('.comment-text');
    const commentForm = e.target.closest('.comment-input-form');
    const deleteMomentBtn = e.target.closest('.delete-moment-btn');
    const deleteCommentBtn = e.target.closest('.delete-comment-btn');

    if (deleteMomentBtn) {
        if (confirm('您确定要删除这条动态吗？此操作无法撤销。')) {
            if (moment.senderId === 'user') { 
                userMomentsProfile.posts = userMomentsProfile.posts.filter(p => p.id !== momentId);
                if (momentType === 'group') { // 也从群聊里删除
                     const group = getCurrentGroup();
                     if (group && group.groupMoments) group.groupMoments = group.groupMoments.filter(m => m.id !== momentId);
                }
            } 
            else if (momentType === 'direct') { const postChar = characterSets.find(c => c.id === moment.senderId); if (postChar && postChar.moments) postChar.moments = postChar.moments.filter(m => m.id !== momentId); } 
            else if (momentType === 'group') { const group = getCurrentGroup(); if (group && group.groupMoments) group.groupMoments = group.groupMoments.filter(m => m.id !== momentId); }
            saveAllData(); renderMoments();
        }
        return;
    }
    if (deleteCommentBtn) { const commentEl = e.target.closest('.comment'); const commentIdToDelete = commentEl.dataset.commentId; if (confirm('您确定要删除这条评论吗？')) { moment.comments = deleteCommentById(moment.comments, commentIdToDelete);; saveAllData(); renderMoments(); } return; }
    if (likeBtn) { const likeIndex = moment.likes.indexOf('user'); if (likeIndex > -1) { moment.likes.splice(likeIndex, 1); } else { moment.likes.push('user'); } saveAllData(); renderMoments(); }
    if (commentBtn || commentText) {
        const form = postEl.querySelector('.comment-input-form');
        const input = form.querySelector('.comment-input');
        const targetCommentEl = e.target.closest('.comment');
        if(form.style.display === 'flex' && (targetCommentEl?.dataset.commentId === form.dataset.replyTo || !targetCommentEl)) { form.style.display = 'none'; } 
        else {
            form.style.display = 'flex';
            if (targetCommentEl) {
                form.dataset.replyTo = targetCommentEl.dataset.commentId;
                const repliedToChar = characterSets.find(c => c.id === targetCommentEl.dataset.senderId);
                const repliedToName = targetCommentEl.dataset.senderId === 'user' ? userMomentsProfile.name : (repliedToChar?.config.characterName || '一位朋友');
                input.placeholder = `回复 ${repliedToName}...`;
            } else { form.dataset.replyTo = ''; input.placeholder = '添加评论...'; }
            input.focus();
        }
    }

    if (commentForm) {
        e.preventDefault();
        const input = commentForm.querySelector('.comment-input');
        const text = input.value.trim();
        const replyToCommentId = commentForm.dataset.replyTo;
        if (text) {
            const newCommentByUser = { id: generateId('cmt'), sender: 'user', text, replies: [] };
            
            let repliedToAiId = null;

            if (replyToCommentId) { 
                 const findAndPushReply = (comments) => {
                    for (const c of comments) {
                        if (c.id === replyToCommentId) {
                            newCommentByUser.replyTo = c.sender;
                            if (c.sender !== 'user') repliedToAiId = c.sender;
                            if(!c.replies) c.replies = []; c.replies.push(newCommentByUser);
                            return true;
                        }
                        if (c.replies) { if(findAndPushReply(c.replies)) return true; }
                    }
                    return false;
                };
                findAndPushReply(moment.comments);
            } else { 
                if (!moment.comments) moment.comments = [];
                moment.comments.push(newCommentByUser);
                if(moment.senderId !== 'user') {
                    repliedToAiId = moment.senderId;
                }
            }
            
            input.value = ''; commentForm.style.display = 'none'; saveAllData(); renderMoments();

            // **核心升级：群聊里对AI的评论/回复，AI也会回应**
            if (repliedToAiId) {
                const finalCommentForAIToReplyTo = { ...newCommentByUser, sender: 'user' };
                setTimeout(() => triggerAiMomentReply(moment, finalCommentForAIToReplyTo, repliedToAiId, momentType), 2500 + Math.random() * 2000);
            }
        }
    }
};

        // --- Diary Logic ---
      // --- Forum Logic ---
const openForum = async () => {
    const chatData = getCurrentChatData();
    if (!chatData) return;
    if (!chatData.forum) chatData.forum = { posts: [], background: '' };

    const forumOverlay = getEl('forum-overlay');
    const forumFeed = getEl('forum-feed');
    
    forumOverlay.style.display = 'block';
    
    if (chatData.forum.posts.length === 0) {
        forumFeed.innerHTML = '<p style="text-align:center; padding: 40px; color: #999;">正在生成热门讨论，请稍候...</p>';
        await triggerAiForumGeneration(4, true); //首次进入，强制刷新
    } else {
        renderForum();
    }
};

const renderForum = () => {
    const chatData = getCurrentChatData();
    if (!chatData || !chatData.forum) return;

    const forumBg = getEl('forum-background');
    forumBg.style.backgroundImage = chatData.forum.background ? `url(${chatData.forum.background})` : 'none';

    const forumFeed = getEl('forum-feed');
    forumFeed.innerHTML = chatData.forum.posts.length === 0
        ? `<p style="text-align:center; padding: 40px; color: #999;">这里还没有任何讨论。</p>`
        : chatData.forum.posts.map(renderSingleForumPost).join('');
};

const renderSingleForumPost = (post) => {
    const commentsHtml = post.comments.map(comment => {
        const commenterName = comment.isAnonymous ? '（匿名）' : (comment.author || '热心网友');
        return `
            <div class="comment" data-comment-id="${comment.id}">
                <span class="comment-user">${commenterName}</span>:
                <span class="comment-text">${comment.text}</span>
            </div>
        `;
    }).join('');

    return `
        <div class="moment-post" data-post-id="${post.id}" style="background: rgba(255,255,255,0.85); backdrop-filter: blur(4px); border-radius: 12px; margin-bottom: 20px;">
            <div class="moment-body">
                <h3 class="forum-title" style="color: var(--accent-dark-color); margin-top:0;"># ${post.title} #</h3>
                <p class="forum-author" style="font-size: 0.8em; color: #888;">发起人: ${post.author}</p>
                <div class="moment-content" style="font-size: 1em;">${post.content.replace(/\n/g, '<br>')}</div>
                <div class="moment-footer">
                    <span class="moment-timestamp">${post.timestamp}</span>
                    <div class="moment-actions">
                        <button class="comment-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
                            <span>评论</span>
                        </button>
                    </div>
                </div>
                <div class="moment-comments">${commentsHtml}</div>
                <form class="comment-input-form" style="display: none;">
                    <input type="text" class="comment-input" placeholder="发表你的看法...">
                    <label style="display: flex; align-items: center; font-size: 0.8em; margin: 0 5px;">
                        <input type="checkbox" class="anonymous-checkbox">匿名
                    </label>
                    <button type="submit">发送</button>
                </form>
            </div>
        </div>`;
};

const triggerAiForumGeneration = async (count = 4, replace = false) => {
    const chatData = getCurrentChatData();
    if (!chatData) return;

    const charName = currentChat.type === 'direct' ? chatData.config.characterName : chatData.name;
    const userName = userMomentsProfile.name || 'TA';
    const activeSession = chatData.sessions?.find(s => s.id === chatData.activeSessionId);
    const history = (activeSession ? activeSession.history : (chatData.chatHistory || [])).slice(-10);
    const historyContext = history.map(msg => `${msg.sender === 'user' ? userName : charName}: ${msg.text || '(非文本消息)'}`).join('\n');

    const prompt = `
    [TASK] 你是一个顶级的“微博”/论坛内容生成器，你的任务是模拟一个围绕着“名人情侣”—— ${charName} 和 ${userName} ——展开的公共讨论区。
    [CONTEXT] 这是他们最近的聊天记录摘要，是你要创作的灵感来源:
    ${historyContext}
    [STYLE] 你的风格必须是：
    1. **有梗有趣**: 充满网络热梗、谐音梗，像真实网友一样插科打诨。
    2. **吃瓜群众视角**: 揣测他们的关系，放大他们互动中的小细节，进行“磕CP”式的解读。
    3. **标题党**: 帖子标题要像微博热搜一样吸引眼球。
    [OUTPUT FORMAT] 你必须严格返回一个包含 ${count} 个JSON对象的数组。每个对象代表一个帖子，结构如下:
    [
        {
            "title": "一个劲爆的帖子标题",
            "author": "一个随机、有趣的网友昵称 (例如: 瓜田里的猹, CP头子就是我)",
            "content": "帖子正文，至少50字，要对他们的关系进行有趣、有梗的分析或调侃。",
            "comments": [
                {"author": "另一个网友昵称", "text": "第一条评论，可以是附和或抬杠。"},
                {"author": "第三个网友昵称", "text": "第二条评论，延续话题。"}
            ]
        }
    ]
    ABSOLUTELY NO other text outside the JSON array.`;

    const payload = getApiPayload(elements.modelSelect.value, [], prompt);
    try {
        const jsonString = await makeApiCall(payload);
        const newPosts = JSON.parse(jsonString.trim().replace(/^```json\s*/, '').replace(/\s*```$/, ''));
        if (replace) chatData.forum.posts = [];
        newPosts.forEach(postData => {
            chatData.forum.posts.unshift({
                id: generateId('forum_post'),
                title: postData.title,
                author: postData.author,
                content: postData.content,
                timestamp: getFullTimestamp(),
                comments: postData.comments.map(c => ({
                    id: generateId('forum_cmt'),
                    author: c.author,
                    text: c.text,
                    isAnonymous: false
                })),
            });
        });
        saveAllData();
        renderForum();
    } catch (error) {
        console.error("生成论坛帖子失败:", error);
        getEl('forum-feed').innerHTML = `<p style="text-align:center; padding: 40px; color: #999;">生成失败了... ${error.message}</p>`;
    }
};

const handleUserForumComment = async (postId, text, isAnonymous) => {
    const chatData = getCurrentChatData();
    const post = chatData.forum.posts.find(p => p.id === postId);
    if (!post) return;

    // 【核心修复】在这里进行判断
    // 如果是匿名，作者字段就为空；如果不是，才使用用户的名字。
    const commentAuthor = isAnonymous ? null : (userMomentsProfile.name || '你');

    const newComment = {
        id: generateId('forum_cmt'),
        author: commentAuthor, // <-- 使用我们刚刚判断好的作者名
        text: text,
        isAnonymous: isAnonymous
    };
    post.comments.push(newComment);
    renderForum(); // Immediately show user's comment
    await triggerAiForumReplies(post, newComment);
};

const triggerAiForumReplies = async (post, userComment) => {
    const chatData = getCurrentChatData();
    const charName = currentChat.type === 'direct' ? chatData.config.characterName : chatData.name;
    const userName = userMomentsProfile.name || 'TA';
    const prompt = `
    [TASK] 你是一个论坛网友模拟器。在一个关于名人情侶 (${charName} 和 ${userName}) 的帖子里，一个用户刚刚发表了评论。请你生成3-4条其他网友的回复。
    [POST CONTEXT]
    - 标题: ${post.title}
    - 内容: ${post.content}
    [USER'S COMMENT]
    - 评论者: ${userComment.isAnonymous ? '一位匿名用户' : userName}
    - 评论内容: "${userComment.text}"
    [REPLY STYLE] 你的回复必须像真实网友：
    - 有的直接回复用户评论，有的可能只是针对原帖发表新看法。
    - 语气多样：可以是赞同、好奇、开玩笑、甚至是柠檬精。
    - 使用网络流行语和表情符号。
    [OUTPUT FORMAT] 你必须严格返回一个包含3-4个JSON对象的数组。每个对象代表一条回复，结构如下:
    [
        {"author": "一个随机的网友昵称", "text": "回复内容1"},
        {"author": "另一个随机的网友昵称", "text": "回复内容2"}
    ]
    ABSOLUTELY NO other text outside the JSON array.`;

    const payload = getApiPayload(elements.modelSelect.value, [], prompt);
    try {
        const jsonString = await makeApiCall(payload);
        const replies = JSON.parse(jsonString.trim().replace(/^```json\s*/, '').replace(/\s*```$/, ''));
        replies.forEach(reply => {
            post.comments.push({
                id: generateId('forum_cmt'),
                author: reply.author,
                text: reply.text,
                isAnonymous: false
            });
        });
        saveAllData();
        renderForum(); // Re-render to show AI replies
    } catch (error) {
        console.error("生成论坛回复失败:", error);
    }
};

const handleForumInteraction = (e) => {
    const postEl = e.target.closest('.moment-post');
    if (!postEl) return;
    const postId = postEl.dataset.postId;

    // Toggle comment form
    if (e.target.closest('.comment-btn')) {
        const form = postEl.querySelector('.comment-input-form');
        form.style.display = form.style.display === 'none' ? 'flex' : 'none';
        if (form.style.display === 'flex') form.querySelector('.comment-input').focus();
    }

    // --- Bug修复的关键位置 ---
    // Handle comment submission
    // 旧的判断条件是 if (e.target.closest('form'))
    // 新的判断条件更精确，只在点击发送按钮时才触发
    if (e.target.closest('form') && e.target.type === 'submit') {
        e.preventDefault(); // 现在只在提交时阻止页面刷新
        const form = e.target.closest('form');
        const input = form.querySelector('.comment-input');
        const checkbox = form.querySelector('.anonymous-checkbox');
        const text = input.value.trim();
        if (text) {
            handleUserForumComment(postId, text, checkbox.checked);
            input.value = '';
            form.style.display = 'none';
        }
    }
    // --- 修复结束 ---
};
        const openDiaryModal = async () => {
    // 基础检查，确保是在和单人角色聊天
    if (currentChat.type !== 'direct') return;
    const character = getCurrentCharacter();
    if (!character) return;

    // --- 核心修复：采纳您的智能触发方案 ---

    // 1. 获取今天的日期，并格式化为 "YYYY-MM-DD"
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day = String(today.getDate()).padStart(2, '0');
    const todayString = `${year}-${month}-${day}`;

    // 2. 检查角色的日记本里，是否已经有了今天的日记
    //    我们用 .some() 方法来检查，它只要找到一个符合条件的就会返回 true
    if (!character.diary) character.diary = []; // 确保日记数组存在
    const todayEntryExists = character.diary.some(entry => entry.date === todayString);

    // 3. 【关键】如果今天的日记不存在，就命令AI去写！
    if (!todayEntryExists) {
        try {
            // 调用AI写日记的函数，告诉它为今天(todayString)写
            // 这个过程会在后台悄悄进行
            triggerAiDiaryEntry(character, todayString);
            
            // 为了更好的体验，我们可以在界面上给一个提示
            // （但这步是可选的，核心功能已经实现）
            console.log(`检测到今天还没有日记，已触发${character.config.characterName}去写...`);
            
        } catch (error) {
            // 万一触发失败，在控制台记录错误，避免程序崩溃
            console.error("触发AI写日记时出错:", error);
        }
    }

    // --- 修复结束 ---

    // 后续的逻辑保持不变：设置日记本标题、渲染所有（可能刚刚更新的）日记、显示窗口
    elements.diaryHeader.textContent = `${character.config.characterName}的日记本`;
    renderDiary(character);
    elements.diaryModal.classList.add('show');
};
      // ==========================================================
// ============ 剧情线 (Session) 管理核心功能 (新增) ============
// ==========================================================
const openSessionManager = () => {
    const character = getCurrentCharacter();
    if (!character || currentChat.type !== 'direct') {
        alert("此功能仅在与单人角色聊天时可用。");
        return;
    }

    // 动态生成所有剧情线的列表HTML
    const sessionsHtml = character.sessions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).map(session => `
        <div class="chat-item ${session.id === character.activeSessionId ? 'active' : ''}" data-session-id="${session.id}">
            <div style="flex-grow: 1;">
                <input type="text" class="session-name-input" value="${session.name}" data-session-id="${session.id}" placeholder="点击修改名称">
                <small style="color: #999; display: block; margin-top: 4px;">创建于: ${new Date(session.createdAt).toLocaleString()}</small>
            </div>
            <button class="session-delete-btn" data-session-id="${session.id}" title="删除此剧情线">×</button>
        </div>
    `).join('');

    const bodyHtml = `
        <div class="chat-list" style="max-height: 50vh; overflow-y: auto;">
            ${sessionsHtml}
        </div>
        <button id="add-session-btn" class="add-new-btn" style="margin-top: 15px;">开启新的剧情线</button>
    `;

    openFeatureModal(`管理与「${character.config.characterName}」的剧情线`, bodyHtml, null, null);

    // 为管理窗口内的所有元素绑定事件
    const modalBody = getEl('feature-modal-body');

    modalBody.onclick = (e) => {
        const item = e.target.closest('.chat-item');
        const deleteBtn = e.target.closest('.session-delete-btn');
        const addBtn = e.target.closest('#add-session-btn');

        if (deleteBtn) {
            e.stopPropagation();
            handleDeleteSession(deleteBtn.dataset.sessionId);
        } else if (item) {
            handleSwitchSession(item.dataset.sessionId);
        } else if (addBtn) {
            handleAddNewSession();
        }
    };
    
    // 处理改名
    modalBody.querySelectorAll('.session-name-input').forEach(input => {
        input.addEventListener('change', (e) => {
            handleRenameSession(e.target.dataset.sessionId, e.target.value);
        });
    });
};

const handleSwitchSession = (sessionId) => {
    const character = getCurrentCharacter();
    if (!character || character.activeSessionId === sessionId) return;

    character.activeSessionId = sessionId;
    saveAllData();
    loadChat(currentChat.type, currentChat.id); // 重新加载聊天界面
    closeModal(elements.featureModal);
};

const handleAddNewSession = () => {
    const character = getCurrentCharacter();
    if (!character) return;

    const newName = prompt("请输入新剧情线的名称：", `支线剧情 ${character.sessions.length + 1}`);
    if (newName && newName.trim()) {
        const newSession = {
            id: generateId('session'),
            name: newName.trim(),
            history: [],
            createdAt: new Date().toISOString()
        };
        character.sessions.push(newSession);
        character.activeSessionId = newSession.id; // 创建后自动切换到新的剧情线
        saveAllData();
        loadChat(currentChat.type, currentChat.id);
        closeModal(elements.featureModal);
        alert(`已切换到新的剧情线: "${newName.trim()}"`);
    }
};

const handleDeleteSession = (sessionId) => {
    const character = getCurrentCharacter();
    if (!character) return;

    if (character.sessions.length <= 1) {
        alert("无法删除最后一条剧情线！");
        return;
    }

    const sessionToDelete = character.sessions.find(s => s.id === sessionId);
    if (confirm(`确定要永久删除剧情线「${sessionToDelete.name}」吗？\n此操作无法撤销！`)) {
        character.sessions = character.sessions.filter(s => s.id !== sessionId);

        // 如果删除的是当前激活的剧情线，就自动切换到最新的那一条
        if (character.activeSessionId === sessionId) {
            character.sessions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            character.activeSessionId = character.sessions[0].id;
            saveAllData();
            loadChat(currentChat.type, currentChat.id);
            closeModal(elements.featureModal);
        } else {
            saveAllData();
            openSessionManager(); // 重新打开管理窗口刷新列表
        }
    }
};

const handleRenameSession = (sessionId, newName) => {
    const character = getCurrentCharacter();
    const session = character?.sessions.find(s => s.id === sessionId);
    if (session && newName.trim()) {
        session.name = newName.trim();
        saveAllData();
        // 更新标题，如果修改的是当前聊天
        getEl('feature-modal-title').textContent = `管理与「${character.config.characterName}」的剧情线`;
    }
};
      // ==========================================================
// ============ 快乐问答 (Q&A Game) 核心功能 (新增) ============
// ==========================================================
let qnaGameSessionLog = []; // 用来临时记录一局游戏的对话

// --- 【修复2/5】从这里开始完整复制 ---
const openQnAGameModal = () => {
    const character = getCurrentCharacter();
    if (!character || currentChat.type !== 'direct') {
        alert("此功能仅在与单人角色聊天时可用。");
        return;
    }
    qnaGameSessionLog = [];

    // 【核心修复】从与角色绑定的 userProfile 中获取您的头像，并用在HTML模板里
    const userProfile = character.userProfile;
    const bodyHtml = `
        <div id="qna-game-board" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
            <div id="qna-avatars" style="display: flex; justify-content: space-around; width: 100%; align-items: center;">
                <div style="text-align: center;">
                    <img id="qna-user-avatar" src="${userProfile.chatAvatar || ''}" class="avatar-preview">
                    <p style="margin: 5px 0 0;">你</p>
                </div>
                <span style="font-size: 2em; color: var(--accent-dark-color);">VS</span>
                <div style="text-align: center;">
                    <img id="qna-char-avatar" src="${character.config.aiAvatar}" class="avatar-preview">
                    <p style="margin: 5px 0 0;">${character.config.characterName}</p>
                </div>
            </div>
            <div id="qna-result-area" style="min-height: 50px; text-align: center; font-weight: bold;">
                点击下方的按钮，一决胜负！
            </div>
            <div id="qna-dialogue-area" style="width: 100%; max-height: 25vh; overflow-y: auto; background: #f9f9f9; border-radius: 8px; padding: 10px; border: 1px solid #eee;"></div>
            <div id="qna-controls">
                <div id="qna-rps-buttons" style="display: flex; gap: 10px;">
                    <button class="qna-btn" data-choice="rock">✊ 石头</button>
                    <button class="qna-btn" data-choice="paper">✋ 布</button>
                    <button class="qna-btn" data-choice="scissors">✌️ 剪刀</button>
                </div>
                <div id="qna-user-input-area" style="display: none; width: 100%;">
                    <textarea id="qna-user-question" placeholder="你赢了！请向他提问..." rows="2" style="width: 100%; box-sizing: border-box;"></textarea>
                    <button id="qna-submit-question-btn" class="add-new-btn" style="width: 100%; margin-top: 5px;">发送问题</button>
                </div>
            </div>
            <button id="qna-end-game-btn" class="danger-zone" style="background: var(--delete-color); color: white; border: none; padding: 8px 15px; border-radius: 8px; cursor: pointer; margin-top: 10px; display: none;">结束游戏</button>
        </div>
        <style> .qna-btn { padding: 10px 15px; border-radius: 8px; border: 1px solid var(--accent-color); background: white; cursor: pointer; } </style>
    `;

    openFeatureModal(`快乐问答`, bodyHtml, null, null);

    const rpsButtons = getEl('qna-rps-buttons');
    rpsButtons.onclick = (e) => {
        if (e.target.classList.contains('qna-btn')) {
            playQnARound(e.target.dataset.choice); 
        }
    };
    getEl('qna-submit-question-btn').onclick = () => {
        const question = getEl('qna-user-question').value.trim();
        if (question) handleUserQuestion(question);
    };
    getEl('qna-end-game-btn').onclick = endQnAGame;
};
// --- 到这里结束复制 ---

const updateQnaDialogue = (speaker, text) => {
    const dialogueArea = getEl('qna-dialogue-area');
    dialogueArea.innerHTML += `<p><strong>${speaker}:</strong> ${text}</p>`;
    qnaGameSessionLog.push(`${speaker}: ${text}`);
    dialogueArea.scrollTop = dialogueArea.scrollHeight;
};

// 这是修复后的代码
const playQnARound = (userChoice) => { // 1. 这里现在会接收你传进来的命令了
    const choices = ['rock', 'paper', 'scissors'];
    const choiceMap = { rock: '✊ 石头', paper: '✋ 布', scissors: '✌️ 剪刀' };
    
    // 2. 我们把那句愚蠢的随机代码删掉了！现在你的选择就是你的选择！
    
    const charChoice = choices[Math.floor(Math.random() * 3)]; // 他的选择依然是随机的

    const resultArea = getEl('qna-result-area');
    let resultText = `你出了 ${choiceMap[userChoice]}，他出了 ${choiceMap[charChoice]}。<br>`;

    if (userChoice === charChoice) {
        resultText += "平局！再来一次！";
        resultArea.innerHTML = resultText;
    } else if (
        (userChoice === 'rock' && charChoice === 'scissors') ||
        (userChoice === 'scissors' && charChoice === 'paper') ||
        (userChoice === 'paper' && charChoice === 'rock')
    ) {
        resultText += "🎉 你赢了！轮到你提问了！";
        resultArea.innerHTML = resultText;
        promptUserQuestion();
    } else {
        resultText += "💔 你输了！他要开始提问咯！";
        resultArea.innerHTML = resultText;
        triggerAiQuestion();
    }
    getEl('qna-end-game-btn').style.display = 'block';
};
const setQnaLoading = (isLoading) => {
    getEl('qna-rps-buttons').style.display = isLoading ? 'none' : 'flex';
    getEl('qna-user-input-area').style.display = 'none';
    getEl('qna-result-area').innerHTML = isLoading ? '他正在绞尽脑汁想问题...' : getEl('qna-result-area').innerHTML;
};

const triggerAiQuestion = async () => {
    setQnaLoading(true);
    const character = getCurrentCharacter();
    const questionPrompt = `
[Task]: You are playing a Q&A game with the user. You won this round, so you get to ask the user a question.Your entire response MUST be in Simplified Chinese.
${CORE_BEHAVIOR_PROMPT}
[Persona]: ${character.config.characterPrompt}
[Question Rules]:
1.  Your question MUST be a single, complete sentence.
2.  Your question MUST be creative, interesting, and reflect your specific personality.
3.  ABSOLUTELY FORBIDDEN questions: Do not ask boring questions like "What did you eat today?", "Do you like me?", or any other robotic small talk.
4.  GOOD question examples: "What color is your underwear today?", "If you were given ten handsome guys, would you still choose me?", "If I were a cat instead of a person, would you still want me?", "Describe our daily interactions using only five emojis."
[Output Format]: Your entire response MUST be just the question text. NO JSON, NO MARKDOWN.
`;
    const payload = getApiPayload(elements.modelSelect.value, [], questionPrompt);
    // ... (API call logic is the same as other triggers)
    try {
        const responseText = await makeApiCall(payload);
        updateQnaDialogue(character.config.characterName, responseText);
        getEl('qna-result-area').innerHTML = '他问了，快回答！';
        promptUserAnswer(); // A new function to get user's answer
    } catch (e) {
        getEl('qna-result-area').textContent = `出错了: ${e.message}`;
        setQnaLoading(false);
    }
};
const promptUserAnswer = () => {
    const userInputArea = getEl('qna-user-input-area');
    userInputArea.style.display = 'block';
    getEl('qna-rps-buttons').style.display = 'none';
    const textarea = userInputArea.querySelector('#qna-user-question');
    const button = userInputArea.querySelector('#qna-submit-question-btn');
    textarea.placeholder = "请回答他的问题...";
    button.textContent = "回答他";
    button.onclick = () => {
        const answer = textarea.value.trim();
        if (answer) handleUserAnswer(answer);
    };
};

// 这是【新的、修复后的】代码
const handleUserAnswer = async (answer) => {
    updateQnaDialogue("你", answer);
    // 【核心修复】发送回答后，也清空输入框
    getEl('qna-user-question').value = ''; 
    setQnaLoading(true);
    getEl('qna-result-area').innerHTML = '他正在看你的回答...';
    const character = getCurrentCharacter();
    const reactionPrompt = `
[Task]: The user has just answered your question. Now, give a single-sentence reaction based on your personality and their answer.Your entire response MUST be in Simplified Chinese.
${CORE_BEHAVIOR_PROMPT}
[Persona]: ${character.config.characterPrompt}
[The Question You Asked]: ${qnaGameSessionLog[qnaGameSessionLog.length - 2].split(': ')[1]}
[The User's Answer]: ${answer}
[Reaction Rules]: Your reaction MUST be a single, short, in-character sentence.
[Output Format]: Your entire response MUST be just the reaction text. NO JSON, NO MARKDOWN.
`;
    const payload = getApiPayload(elements.modelSelect.value, [], reactionPrompt);
    try {
        const responseText = await makeApiCall(payload);
        updateQnaDialogue(character.config.characterName, responseText);
        getEl('qna-result-area').innerHTML = '一轮结束！可以继续，或结束游戏。';
    } catch (e) {
        updateQnaDialogue("系统", `出错了: ${e.message}`);
    } finally {
        setQnaLoading(false);
    }
};

const promptUserQuestion = () => {
    getEl('qna-rps-buttons').style.display = 'none';
    getEl('qna-user-input-area').style.display = 'block';
};

// 这是【新的、修复后的】代码
const handleUserQuestion = (question) => {
    updateQnaDialogue("你", question);
    triggerAiAnswer(question);
    // 【核心修复】发送问题后，清空输入框
    getEl('qna-user-question').value = '';
};

const triggerAiAnswer = async (question) => {
    setQnaLoading(true);
    getEl('qna-result-area').innerHTML = '他正在思考如何回答...';
    const character = getCurrentCharacter();
    const answerPrompt = `
[Task]: You are playing a Q&A game. The user won and is asking you a question. Answer it in a single sentence, staying true to your personality.Your entire response MUST be in Simplified Chinese.
${CORE_BEHAVIOR_PROMPT}
[Persona]: ${character.config.characterPrompt}
[The User's Question]: ${question}
[Answer Rules]: Your answer MUST be a single, short, in-character sentence.
[Output Format]: Your entire response MUST be just the answer text. NO JSON, NO MARKDOWN.
`;
    const payload = getApiPayload(elements.modelSelect.value, [], answerPrompt);
    try {
        const responseText = await makeApiCall(payload);
        updateQnaDialogue(character.config.characterName, responseText);
        getEl('qna-result-area').innerHTML = '一轮结束！可以继续，或结束游戏。';
    } catch (e) {
        updateQnaDialogue("系统", `出错了: ${e.message}`);
    } finally {
        setQnaLoading(false);
    }
};

// A new helper function for making API calls to avoid repetition
const makeApiCall = async (payload, retries = 2) => {
    const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
    const apiKey = elements.apiKeyInput.value.trim();
    const model = elements.modelSelect.value;
    const apiFormat = getApiFormat();

    let fetchUrl, headers;
    if (apiFormat === 'gemini_native') {
        fetchUrl = `${apiBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`;
        headers = { 'Content-Type': 'application/json' };
    } else {
        fetchUrl = `${apiBaseUrl}/v1/chat/completions`;
        headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };
    }

    // --- 第二层防御：自动重试机制 ---
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(fetchUrl, { method: 'POST', headers: headers, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);
            
            const responseData = await response.json();
            if (responseData.error) throw new Error(`API 错误: ${responseData.error.message}`);
            
            let content = '';
            if (apiFormat === 'gemini_native') {
                content = responseData.candidates?.[0]?.content?.parts?.[0]?.text;
            } else {
                content = responseData.choices?.[0]?.message?.content;
            }
            
            if (!content) throw new Error("API 未返回有效内容。");

            // --- 第一层防御：超级净化器 ---
            // 它会从AI可能返回的一大堆废话中，精准提取出被 {} 或 [] 包裹的核心JSON部分
            const jsonMatch = content.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                return jsonMatch[0]; // 成功找到并返回纯净的JSON字符串
            }
            return content.trim(); // 如果没找到JSON，就返回原始文本（用于问答等功能）

        } catch (error) {
            console.error(`API调用尝试 ${i + 1}/${retries} 失败:`, error);
            if (i === retries - 1) {
                // --- 第三层防御：智能回退 ---
                // 重试全部失败后，抛出一个用户友好的错误
                throw new Error("与AI的连接超时或发生错误，请稍后再试。");
            }
            // 等待1秒再重试
            await new Promise(res => setTimeout(res, 1000));
        }
    }
};

const endQnAGame = () => {
    if (qnaGameSessionLog.length > 0) {
        const summary = `[我们刚刚玩了一场快乐问答，这是游戏记录摘要：\n${qnaGameSessionLog.join('\n')}\n]`;
        addMessage({
            sender: 'system',
            type: 'video_log', // Using this type to hide it from UI but keep in memory
            llmContent: summary
        });
        alert("游戏结束！这段有趣的记忆已经被他记住啦。");
    }
    closeModal(elements.featureModal);
};
                                                                const triggerAiDiaryEntry = async (character, date) => {
            try {
                // 这是修复后的代码
const { config } = character;
const activeSession = character.sessions.find(s => s.id === character.activeSessionId);
const chatHistory = activeSession ? activeSession.history : [];
                
                 const recentHistory = chatHistory.slice(-10);
                 const historyContext = recentHistory.map(msg => `${msg.sender === 'user' ? 'User' : 'AI'}: ${msg.text || '(非文本消息)'}`).join('\n');
                 
                 const finalPrompt = `[Role]: You are ${config.characterName}. Your persona is: ${config.characterPrompt}
[Recent Conversation Context for today, ${date}]:
${historyContext}
[Task]: Based on ALL the information above (your persona and the recent conversation), write a short, natural, first-person diary entry in Simplified Chinese reflecting on the day's events and feelings.
[CRITICAL OUTPUT FORMAT]: Your entire response MUST be a valid JSON array containing a single object, like this example:
[{"type": "diary_entry", "content": "Your actual diary text here."}]
Do NOT leave the content empty. Do NOT add any text, markdown, or explanations outside the JSON array.`;

                const payload = getApiPayload(elements.modelSelect.value, [], finalPrompt);
                const apiBaseUrl = elements.apiBaseUrlInput.value.trim();
                const apiKey = elements.apiKeyInput.value.trim();
                const model = elements.modelSelect.value;
                const isGemini = apiBaseUrl.includes('google');
                const fetchUrl = isGemini ? `${apiBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}` : `${apiBaseUrl}/v1/chat/completions`;
                const headers = isGemini ? { 'Content-Type': 'application/json' } : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` };
                
                const response = await fetch(fetchUrl, { method: 'POST', headers: headers, body: JSON.stringify(payload) });
                const rawText = await response.text();
                if (!response.ok) throw new Error(`API请求失败，官方报告 Status Code: ${response.status}`);

                const responseData = JSON.parse(rawText);
                let aiResponseText = '';
                if (isGemini) {
                    if (!responseData.candidates || responseData.candidates.length === 0) { throw new Error("Gemini的candidates列表为空。"); }
                    aiResponseText = responseData.candidates[0].content.parts.map(part => part.text || '').join('');
                } else {
                    aiResponseText = responseData.choices?.[0]?.message?.content;
                }

                if (!aiResponseText) { throw new Error("AI的响应中没有有效的文本内容。"); }
                
                // --- 【这，就是那唯一、但却决定性的修复】 ---
                const cleanedJsonString = aiResponseText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');
                // --- 修复结束 ---
                
                const jsonAction = JSON.parse(cleanedJsonString);

                if (jsonAction && Array.isArray(jsonAction) && jsonAction[0] && jsonAction[0].type === 'diary_entry' && jsonAction[0].content && jsonAction[0].content.trim() !== "") {
                    addDiaryEntry(character.id, jsonAction[0].content, date);
                } else {
                    console.error("最终解析出的JSON无效或内容为空。", jsonAction);
                }
            } catch (e) {
                console.error("【重大错误】写日记时出错:", e);
                const entryEl = elements.diaryEntries.querySelector(`.diary-entry[data-date="${date}"] .diary-content`);
                if(entryEl) entryEl.textContent = `重写失败: ${e.message}`;
            }
        };
        const addDiaryEntry = (characterId, content, date) => {
            const character = characterSets.find(c => c.id === characterId);
            if (!character) return;
            if (!character.diary) character.diary = [];
            const existingEntryIndex = character.diary.findIndex(e => e.date === date);
            if (existingEntryIndex > -1) {
                character.diary[existingEntryIndex].content = content;
            } else {
                character.diary.unshift({ date: date, content });
            }
            saveAllData();
            if (elements.diaryModal.classList.contains('show')) renderDiary(character);
        };
                const renderDiary = (character) => {
            const entries = (character.diary || []).sort((a,b) => new Date(b.date) - new Date(a.date));
            if (entries.length === 0) {
                 elements.diaryEntries.innerHTML = '<p style="text-align:center; color:#999;">日记本还是空的。</p>';
            } else {
                elements.diaryEntries.innerHTML = entries.map(entry => `
                    <div class="diary-entry" data-date="${entry.date}">
                        <div class="diary-date">${entry.date}</div>
                        <div class="diary-content">${entry.content.replace(/\n/g, '<br>')}</div>
                        <button class="diary-regenerate-btn" title="为这一天重写日记">✏️</button>
                        <button class="diary-delete-btn" title="删除这篇日记">×</button>
                    </div>
                `).join('');
            }
        };
        const handleDeleteDiaryEntry = async (date) => {
            if (!confirm(`确定要删除 ${date} 的日记吗？删除后AI会重新生成一篇。`)) return;
            const character = getCurrentCharacter();
            if (!character || !character.diary) return;
            character.diary = character.diary.filter(entry => entry.date !== date);
            saveAllData();
            const entryEl = elements.diaryEntries.querySelector(`.diary-entry[data-date="${date}"]`);
            if (entryEl) {
                entryEl.innerHTML = `<div class="diary-date">${date}</div><div class="diary-content">正在重写中...</div>`;
            } else {
                renderDiary(character);
            }
            await triggerAiDiaryEntry(character, date);
        };
        const handleRegenerateDiaryEntry = async (date) => {
            if (!confirm(`您确定要让AI为 ${date} 重写一篇日记吗？原来的内容将会被覆盖。`)) return;
            const character = getCurrentCharacter();
            if (!character) return;
            const entryEl = elements.diaryEntries.querySelector(`.diary-entry[data-date="${date}"]`);
            if (entryEl) {
                const contentEl = entryEl.querySelector('.diary-content');
                if(contentEl) contentEl.innerHTML = '正在重写中...';
            }
            await triggerAiDiaryEntry(character, date);
        };

        // --- Data Import/Export ---
        const exportData = async () => {
    await saveAllData(); // 直接调用我们安全的保存函数
    const data = localStorage.getItem('aiBoyfriendBackup_v7_meta');
    const blob = new Blob([data], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ai_boyfriend_backup_${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    alert('全部数据已导出！');
};
        const importData = () => { if(confirm('确定要导入数据吗？这会覆盖所有当前数据。')) { elements.importDataInput.click(); } };
      // 这是一个全新的函数，负责将任何旧版本数据升级到最新的v7格式
const migrateDataToV7 = (oldData) => {
    console.log("开始数据迁移程序...");
    let newData = JSON.parse(JSON.stringify(oldData)); // 深拷贝一份，避免修改原始对象
    
    // 兼容最老版本 (v6)，它没有globalSettings
    if (!newData.globalSettings) {
        newData.globalSettings = {};
    }

    // 迁移主题和气泡样式到每个角色配置中
    const globalTheme = newData.globalSettings.theme || '1';
    const globalBubbleStyle = newData.globalSettings.bubbleStyle || 'default';
    if (newData.characterSets) {
        newData.characterSets.forEach(char => {
            if (char.config) {
                if (!char.config.theme) char.config.theme = globalTheme;
                if (!char.config.bubbleStyle) char.config.bubbleStyle = globalBubbleStyle;
            }
        });
    }
    delete newData.globalSettings.theme;
    delete newData.globalSettings.bubbleStyle;

    // 迁移全局 userPrompt 到每个角色中 (针对v6版本)
    if (newData.userMomentsProfile && newData.userMomentsProfile.userPrompt) {
        if (newData.characterSets) {
            newData.characterSets.forEach(char => {
                if (!char.userPrompt) char.userPrompt = newData.userMomentsProfile.userPrompt;
            });
        }
    }
    
    // 为旧数据添加新的默认设置
    if (newData.globalSettings.uiScale === undefined) newData.globalSettings.uiScale = 1.0;
    if (newData.globalSettings.fontSize === undefined) newData.globalSettings.fontSize = 13; // 您的默认值
    if (newData.globalSettings.bubblePadding === undefined) newData.globalSettings.bubblePadding = 10;
    if (newData.globalSettings.realTimeAwareness === undefined) newData.globalSettings.realTimeAwareness = false;
    if (!newData.globalSettings.presets) newData.globalSettings.presets = [];

    newData.version = '1.1'; // 标记为最新版本
    console.log("数据迁移完成！");
    return newData;
};
        const handleDataImport = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = e.target.result;
            let parsed = JSON.parse(data);

            // 智能检测并进行必要的升级
            if (!parsed.version || parsed.version !== '1.1') {
                alert('检测到旧版本备份文件，将为您进行升级转换...');
                parsed = migrateDataToV7(parsed); // 调用升级函数
            }

            if (parsed.characterSets && parsed.globalSettings) {
                // 在保存前，将图片数据存入IndexedDB，以保持数据格式一致性
                const isImage = (value) => typeof value === 'string' && value.startsWith('data:image');
                const processObjectForSaving = async (obj) => {
                    if (!obj || typeof obj !== 'object') return obj;
                    const newObj = Array.isArray(obj) ? [] : {};
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            const value = obj[key];
                            if (isImage(value)) {
                                const imageKey = `img_${generateId(key)}`;
                                await dbSet(imageKey, value);
                                newObj[key] = imageKey;
                            } else if (typeof value === 'object') {
                                newObj[key] = await processObjectForSaving(value);
                            } else {
                                newObj[key] = value;
                            }
                        }
                    }
                    return newObj;
                };
              // 这是一个全新的函数，负责将任何旧版本数据升级到最新的v7格式

                const processedData = await processObjectForSaving(parsed);
                localStorage.setItem('aiBoyfriendBackup_v7_meta', JSON.stringify(processedData));
                alert('数据导入并升级成功！页面即将刷新以应用您的备份。');
                location.reload();
            } else {
                alert('导入失败：文件内容格式不正确，缺少核心数据。');
            }
        } catch (error) {
            console.error("导入数据时发生错误:", error);
            alert(`导入失败：文件可能已损坏或不是有效的JSON文件。\n错误详情: ${error.message}`);
        }
    };
    reader.readAsText(file);
    event.target.value = '';
};

    // --- 全新的“计算并显示聊天天数”函数 ---
    const updateAndShowStreak = (character) => {
        if (!character || !character.config) return;

        const config = character.config;
        const streakEl = getEl('streak-notification');
        const streakTextEl = getEl('streak-text');
        
        const today = new Date();
        const todayStr = `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()}`;

        if (config.lastChatDate) {
            const lastDate = new Date(config.lastChatDate);
            const yesterday = new Date();
            yesterday.setDate(today.getDate() - 1);
            const yesterdayStr = `${yesterday.getFullYear()}-${yesterday.getMonth() + 1}-${yesterday.getDate()}`;
            
            // 如果上次聊天是昨天，天数+1
            if (config.lastChatDate === yesterdayStr) {
                config.streak++;
            } 
            // 如果上次聊天不是今天也不是昨天，天数重置为1
            else if (config.lastChatDate !== todayStr) {
                config.streak = 1;
            }
        } else {
            // 如果是第一次聊天，天数就是1
            config.streak = 1;
        }

        // 更新最后聊天日期为今天并保存
        config.lastChatDate = todayStr;
        saveAllData();

        // 更新并显示提示条
        streakTextEl.textContent = `與「${config.characterName}」已連續熱聊 ${config.streak} 天`;
        streakEl.classList.add('show');

        // 5秒后自动隐藏
        setTimeout(() => {
            streakEl.classList.remove('show');
        }, 5000);
    };
                          
                const setupEventListeners = () => {
                                    contextMenu.addEventListener('click', (e) => {
    // 【核心修复】我们不再直接问被点到的东西(e.target)，
    // 而是问它所属的那个最大的按钮(e.target.closest)
    const menuItem = e.target.closest('.context-menu-item');

    // 如果点的不是按钮区域，就什么也不做
    if (!menuItem) {
        hideContextMenu();
        return;
    }

    // 从那个大按钮上，读取它的指令 (data-action)
    const action = menuItem.dataset.action;
    const targetMessageId = currentContextMenuTargetId;

    if (!action || !targetMessageId) {
        hideContextMenu();
        return;
    }

    if (action === 'edit') {
        openEditModal(targetMessageId);
    } else if (action === 'select') {
        const targetMessageElement = document.querySelector(`.message[data-id="${targetMessageId}"]`);
        if (targetMessageElement) {
             if (!isMultiSelectMode) toggleMultiSelectMode(true);
             toggleMessageSelection(targetMessageElement);
        }
    }
    
    hideContextMenu(); // 执行完操作后关闭菜单
});
                  elements.darkModeToggle.addEventListener('change', () => applyDarkMode(elements.darkModeToggle.checked));
                  elements.compactModeToggle.addEventListener('change', () => applyCompactMode(elements.compactModeToggle.checked));       
                  elements.settingsBtn.onclick = openSettingsModal;
                      // 新增：点击歌曲信息区域，打开播放列表弹窗
    elements.songInfoTrigger.onclick = openPlaylistModal;
                  elements.closeSettingsBtn.onclick = () => closeModal(elements.settingsModal);
                 elements.saveSettingsBtn.onclick = async () => {
    // 更新全局应用设置 (这部分逻辑是正确的，保持不变)
    appSettings.apiBaseUrl = elements.apiBaseUrlInput.value;
    appSettings.apiKey = elements.apiKeyInput.value;
    appSettings.model = elements.modelSelect.value;
    appSettings.temperature = parseFloat(elements.temperatureSlider.value);
    appSettings.topP = parseFloat(elements.topPSlider.value);
    appSettings.realTimeAwareness = elements.realTimeAwarenessToggle.checked;
    appSettings.apiFormat = elements.apiFormatSelect.value;
    appSettings.globalTheme = elements.globalThemeSelect.value;
    appSettings.fontFamily = elements.fontSelect.value;
    appSettings.advancedBubbleStyles = elements.advancedBubbleStylesInput.value;
    appSettings.customFontName = elements.customFontNameInput.value;
    appSettings.customFontUrl = elements.customFontUrlInput.value;
    appSettings.uiScale = parseFloat(elements.uiScaleSlider.value) / 100;
    appSettings.fontSize = parseInt(elements.fontSizeSlider.value);
    appSettings.bubblePadding = parseInt(elements.bubbleSizeSlider.value);
    updatePresetsFromUI();
    appSettings.presets = globalPresets;

    // 根据当前聊天类型，将所有设置保存到正确的地方
    const chatData = getCurrentChatData();
    if (chatData) {
        if (currentChat.type === 'direct') {
            const character = chatData;
            
            // 1. 保存“我的个人资料”，存入与角色绑定的 userProfile
            character.userProfile.name = elements.userNameInput.value.trim() || '你';
            character.userProfile.chatAvatar = elements.userAvatarPreview.src;
            character.userProfile.momentsAvatar = elements.userMomentsAvatarPreview.src;
            character.userProfile.momentsCover = elements.userMomentsCoverPreview.src;
            character.userProfile.prompt = elements.userPromptInput.value;
            
            // 2. 保存“他的角色设置”，存入角色的 config
            character.config.characterName = elements.characterNameInput.value.trim() || '他';
            character.config.characterPrompt = elements.characterPromptInput.value;
            character.config.aiAvatar = elements.aiAvatarPreview.src; 
            character.config.memorySize = parseInt(elements.memorySizeInput.value) || 50;
            character.config.theme = elements.themeSelector.querySelector('.theme-option.active')?.dataset.theme || '1';
            character.config.bubbleStyle = elements.bubbleStyleSelect.value;

            // --- ✨ 新增的救星代码在这里！---
            // 这段代码会获取当前设置的背景图，并把它存到角色的配置里
            const bgImage = elements.chatContainer.style.backgroundImage;
            character.config.chatBackground = (bgImage && bgImage !== 'none') ? bgImage.slice(5, -2).replace(/"/g, "") : '';
            // --- 修复完成 ---

        } else { // 如果是群聊
            const group = chatData;
            group.name = elements.groupNameInput.value.trim() || '群聊';
            group.avatar = elements.groupAvatarPreview.src;
            group.userPrompt = elements.groupUserPromptInput.value;
            group.memorySize = parseInt(elements.groupMemorySizeInput.value) || 80;
            group.theme = elements.themeSelector.querySelector('.theme-option.active')?.dataset.theme || '1';
            group.bubbleStyle = elements.bubbleStyleSelect.value;
            const bgImage = elements.chatContainer.style.backgroundImage;
            group.chatBackground = (bgImage && bgImage !== 'none') ? bgImage.slice(5, -2).replace(/"/g, "") : '';
        }
    }
    
    // 执行最终保存，并关闭窗口
    await saveAllData();
    alert('设置已保存！');
    closeModal(elements.settingsModal);
    loadChat(currentChat.type, currentChat.id); // 重新加载聊天以应用更改
};
                  // 这是100%正确的代码版本
elements.sendBtn.onclick = () => {
    const text = elements.messageInput.value.trim();
    if (!text) return; // 如果输入框是空的，就什么也不做

    // 处理用户发送的动作
    handleUserAction({ sender: 'user', type: 'text', text, llmContent: text });
    
    // 发送后，立刻清空输入框
    elements.messageInput.value = '';
    
    // 并重置输入框高度
    autoResizeTextarea();
};

elements.messageInput.onkeydown = (e) => {
    // 同样，按回车键也执行完整的发送和清空逻辑
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // 阻止默认的回车换行行为
        elements.sendBtn.click(); // 触发上面定义好的、完整的onclick事件
    }
};
                  elements.receiveBtn.onclick = triggerAiResponse; // TASK 5
                  elements.messageInput.onkeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); elements.sendBtn.click(); } };
                  elements.videoSendBtn.onclick = () => { const text = elements.videoMessageInput.value.trim(); if (!text) return; addVideoChatMessageToUI({ sender: 'user', text: text }); elements.videoMessageInput.value = ''; triggerVideoCallAIResponse(); };
                  elements.videoMessageInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); elements.videoSendBtn.click(); } };
                  elements.mindVoiceCloseBtn.onclick = () => elements.mindVoiceModal.classList.remove('show');
                  elements.diaryModalCloseBtn.onclick = () => closeModal(elements.diaryModal);

                              // 新增：驱动动态歌词的“引擎”
            let lastActiveLyricIndex = -1;
            audioPlayer.addEventListener('timeupdate', () => {
                if (currentLyrics.length === 0) return;
                
                const currentTime = audioPlayer.currentTime;
                let activeLyricIndex = -1;

                // 找到当前应该高亮的歌词行
                for (let i = currentLyrics.length - 1; i >= 0; i--) {
                    if (currentTime >= currentLyrics[i].time) {
                        activeLyricIndex = i;
                        break;
                    }
                }
                
                // 如果高亮行没有变化，就什么也不做，以提高性能
                if (activeLyricIndex === lastActiveLyricIndex) return;

                const lyricsContainer = getEl('lyrics-lines');
                
                // 移除上一行的激活状态
                const lastActiveEl = lyricsContainer.querySelector(`.lyric-line[data-line-index="${lastActiveLyricIndex}"]`);
                if(lastActiveEl) lastActiveEl.classList.remove('lyric-active');
                
                // 激活当前行并滚动到视图中央
                if (activeLyricIndex > -1) {
                    const activeEl = lyricsContainer.querySelector(`.lyric-line[data-line-index="${activeLyricIndex}"]`);
                    if (activeEl) {
                        activeEl.classList.add('lyric-active');
                        // 平滑滚动到视野中
                        activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
                
                lastActiveLyricIndex = activeLyricIndex;
            });
                  
                  // TASK 2: Add event listener for diary deletion
                                      // --- 升级后的日记事件监听器 ---
                   elements.diaryEntries.addEventListener('click', (e) => {
                       const entryEl = e.target.closest('.diary-entry');
                       if (!entryEl) return;
                       
                       const date = entryEl.dataset.date;
                       if (e.target.closest('.diary-delete-btn')) {
                           handleDeleteDiaryEntry(date);
                       } else if (e.target.closest('.diary-regenerate-btn')) {
                           handleRegenerateDiaryEntry(date);
                       }
                   });

                  elements.actionBtn.onclick = () => toggleActionPanel();
                  elements.actionShowMoments.onclick = () => { openMoments(); toggleActionPanel(true); };
                  elements.actionShowDiary.onclick = () => { openDiaryModal(); toggleActionPanel(true); };
                  // 这是需要新增的事件绑定
elements.actionManageSessions = getEl('action-manage-sessions'); // 先获取按钮
elements.actionManageSessions.onclick = () => { openSessionManager(); toggleActionPanel(true); };
                  // 这是需要新增的事件绑定
elements.actionQnaGame = getEl('action-qna-game');
            elements.actionShowForum = getEl('action-show-forum');   
elements.actionQnaGame.onclick = () => { openQnAGameModal(); toggleActionPanel(true); };
                  getEl('action-show-forum').onclick = () => { openForum(); toggleActionPanel(true); };
                  elements.actionSendTextImage.onclick = () => { handleTextImageSend(); toggleActionPanel(true); };
                  elements.actionSendRealImage.onclick = () => { elements.realImageUploadInput.click(); toggleActionPanel(true); };
                  elements.actionSendVoice.onclick = () => { handleVoiceSend(); toggleActionPanel(true); };
                  elements.actionSendTransfer.onclick = () => { handleTransferSend(); toggleActionPanel(true); };
                  elements.actionSendRedPacket.onclick = () => { openCreateRedPacketModal(); toggleActionPanel(true); };
                  elements.actionSendSticker.onclick = () => { handleStickerSend(); toggleActionPanel(true); };
                  elements.actionVideoCall.onclick = () => { startVideoCall(); toggleActionPanel(true); };
                  elements.actionCreatePoll.onclick = () => { openCreatePollModal(); toggleActionPanel(true); };
                                                      elements.fetchModelsBtn.onclick = async () => {
    const baseUrl = elements.apiBaseUrlInput.value.trim();
    const apiKey = elements.apiKeyInput.value.trim();
    if (!baseUrl) {
        alert('请输入API端点');
        return;
    }
    elements.fetchModelsBtn.textContent = '获取中...';
    elements.fetchModelsBtn.disabled = true;

    const apiFormat = getApiFormat(); // 使用新的检测器
    let fetchUrl, headers;

    try {
        // 【核心改造】根据API格式，决定从哪里获取模型
        if (apiFormat === 'gemini_native') {
            if (!apiKey) {
                alert('使用原生Gemini格式时，API密钥不能为空');
                throw new Error('Missing API Key');
            }
            fetchUrl = `${baseUrl}/v1beta/models?key=${apiKey}`;
            headers = {};
        } else { // 'openai' and 'gemini_openai'
            fetchUrl = `${baseUrl}/v1/models`;
            headers = {
                'Authorization': `Bearer ${apiKey}`
            };
        }

        const response = await fetch(fetchUrl, {
            headers
        });
        if (!response.ok) throw new Error(`获取模型列表失败, Status: ${response.status} ${await response.text()}`);

        const data = await response.json();
        elements.modelSelect.innerHTML = '';

        const models = data.models || data.data || data;
        if (!Array.isArray(models)) throw new Error('API返回的模型列表格式不正确');

        // --- 核心修复：在这里“复印并珍藏”菜单 ---
        const modelCache = []; // 准备一个空数组来存放菜单项
        // --- 修复结束 ---

        models.forEach(model => {
            const modelId = model.name ? model.name.replace('models/', '') : model.id;
            if (modelId) {
                let isValidModel = false;
                if (apiFormat === 'gemini_native' && model.supportedGenerationMethods?.includes('generateContent') && modelId.includes('gemini')) {
                    isValidModel = true;
                } else if (apiFormat !== 'gemini_native') {
                    isValidModel = true;
                }

                if (isValidModel) {
                    elements.modelSelect.add(new Option(modelId, modelId));
                    // --- 核心修复：把每个菜品（模型）记下来 ---
                    modelCache.push({
                        id: modelId,
                        name: modelId
                    });
                    // --- 修复结束 ---
                }
            }
        });

        // --- 核心修复：将完整的菜单存入本地存储（那个“特殊抽屉”） ---
        localStorage.setItem('ai_boyfriend_model_cache', JSON.stringify(modelCache));
        // --- 修复结束 ---

        const currentModel = elements.modelSelect.value;
        if (currentModel) elements.modelSelect.value = currentModel;

    } catch (error) {
        alert(`获取模型失败: ${error.message}`);
    } finally {
        elements.fetchModelsBtn.textContent = '获取模型列表';
        elements.fetchModelsBtn.disabled = false;
    }
};
                  elements.themeSelector.onclick = (e) => { const t = e.target.closest('.theme-option'); if (t) applyTheme(t.dataset.theme, getCurrentChatData()); };
                  elements.fontSelect.addEventListener('change', () => applyFont(elements.fontSelect.value));   
                  const avatarCompression = { compress: true, quality: 0.7, maxWidth: 300, maxHeight: 300 };
                  const backgroundCompression = { compress: true, quality: 0.8, maxWidth: 1280, maxHeight: 1280 };
                  const chatImageCompression = { compress: true, quality: 0.75, maxWidth: 600, maxHeight: 600 };
                  elements.backgroundUploadInput.onchange = e => handleFileUpload(e.target.files[0], (d) => { elements.chatContainer.style.backgroundImage = `url(${d})`; }, backgroundCompression);
                  elements.aiAvatarUploadInput.onchange = e => handleFileUpload(e.target.files[0], (d) => { elements.aiAvatarPreview.src = d; if(currentChat.type==='direct') elements.headerAvatar.src = d; }, avatarCompression);
                  elements.groupAvatarSettingsInput.onchange = e => handleFileUpload(e.target.files[0], (d) => { elements.groupAvatarPreview.src = d; }, avatarCompression);
                  elements.userAvatarUploadInput.onchange = e => handleFileUpload(e.target.files[0], (d) => { elements.userAvatarPreview.src = d; }, avatarCompression);
                  elements.userMomentsAvatarInput.onchange = e => handleFileUpload(e.target.files[0], d => { elements.userMomentsAvatarPreview.src = d; }, avatarCompression);
                  elements.userMomentsCoverInput.onchange = e => handleFileUpload(e.target.files[0], d => { elements.userMomentsCoverPreview.src = d; }, backgroundCompression);
                  elements.realImageUploadInput.onchange = (e) => handleFileUpload(e.target.files[0], (d) => handleUserAction({ sender:'user', type:'image', imageUrl:d, llmContent:'[从相册发送了一张照片]' }), chatImageCompression);
                  elements.manageStickersBtn.onclick = () => openStickerManager('user');
                  elements.manageAiStickersBtn.onclick = () => openStickerManager('ai');
                  elements.clearHistoryBtn.onclick = clearChatHistory;
                  elements.deleteChatBtn.onclick = () => handleDeleteChat(currentChat.type, currentChat.id);
                  elements.exportDataBtn.onclick = exportData;
                  elements.importDataBtn.onclick = importData;
                  elements.importDataInput.onchange = handleDataImport;
                  elements.messageInput.addEventListener('input', autoResizeTextarea);
                  elements.featureModalCloseBtn.addEventListener('click', () => closeModal(elements.featureModal));
                  elements.featureModalSubmitBtn.addEventListener('click', () => { if (onFeatureModalSubmit) onFeatureModalSubmit(); });
                  elements.chatManagerBtn.onclick = openChatManager;
                  elements.momentsCloseBtn.onclick = () => elements.momentsOverlay.classList.remove('show');
                  elements.postNewMomentBtn.onclick = openPostMomentModal;
                  elements.momentsFeed.addEventListener('click', handleMomentsInteraction);
                  elements.messagesContainer.addEventListener('click', e => { const voteBtn = e.target.closest('.poll-vote-btn'); if (voteBtn && !voteBtn.disabled) handleUserVote(voteBtn.dataset.pollId, voteBtn.dataset.option); });
                  getEl('forum-overlay').addEventListener('click', (e) => {
    if (e.target.id === 'forum-close-btn') {
        getEl('forum-overlay').style.display = 'none';
    } else if (e.target.id === 'refresh-forum-btn') {
        if (confirm('刷新会替换掉所有现有帖子，确定吗？')) {
            triggerAiForumGeneration(4, true);
        }
    } else if (e.target.id === 'change-forum-bg-btn') {
        getEl('forum-background-input').click();
    }
});

getEl('forum-feed').addEventListener('click', handleForumInteraction);

getEl('forum-background-input').onchange = (e) => {
    const chatData = getCurrentChatData();
    if (!chatData) return;
    handleFileUpload(e.target.files[0], (dataUrl) => {
        if (!chatData.forum) chatData.forum = { posts: [], background: '' };
        chatData.forum.background = dataUrl;
        saveAllData();
        renderForum();
    }, { compress: true, quality: 0.8, maxWidth: 1920, maxHeight: 1080 });
};
                  window.addEventListener('click', (e) => { if (e.target === elements.settingsModal) closeModal(elements.settingsModal); if (e.target === elements.featureModal) closeModal(elements.featureModal); if (e.target === elements.diaryModal) closeModal(elements.diaryModal); if (e.target === elements.mindVoiceModal) elements.mindVoiceModal.classList.remove('show'); });
                  elements.chatNameHeader.addEventListener('blur', () => { const chatData = getCurrentChatData(); if(!chatData) return; const newName = elements.chatNameHeader.textContent.trim(); const oldName = currentChat.type === 'direct' ? chatData.config.characterName : chatData.name; if(newName && newName !== oldName){ if(currentChat.type === 'direct') chatData.config.characterName = newName; else chatData.name = newName; saveAllData(); } else { elements.chatNameHeader.textContent = oldName; } });
                  elements.confirmDeleteBtn.onclick = deleteSelectedMessages;
                  elements.cancelDeleteBtn.onclick = () => toggleMultiSelectMode(false);
                  
                  // TASK 9: Sizing slider event listeners
                  const updateSizing = () => applySizing({ uiScale: parseFloat(elements.uiScaleSlider.value) / 100, fontSize: parseInt(elements.fontSizeSlider.value), bubblePadding: parseInt(elements.bubbleSizeSlider.value) });
                  elements.uiScaleSlider.addEventListener('input', () => { elements.uiScaleValue.textContent = `${elements.uiScaleSlider.value}%`; updateSizing(); });
                  elements.fontSizeSlider.addEventListener('input', () => { elements.fontSizeValue.textContent = `${elements.fontSizeSlider.value}px`; updateSizing(); });
                  elements.bubbleSizeSlider.addEventListener('input', () => { elements.bubbleSizeValue.textContent = `${elements.bubbleSizeSlider.value}px`; updateSizing(); });
                  
                  elements.bubbleStyleSelect.addEventListener('change', (e) => { applyBubbleStyle(e.target.value, getCurrentCharacter()); });
                  elements.applyCustomFontBtn.onclick = () => applyCustomFont(elements.customFontNameInput.value, elements.customFontUrlInput.value);
                   // --- “一起听歌”功能的事件监听 ---
    elements.actionListenTogether.onclick = () => { openListenTogetherModal(); toggleActionPanel(true); };
    elements.closeListenModalBtn.onclick = closeListenTogetherModal;
    elements.startListenAlongBtn.onclick = startListenAlong;
    elements.addNewSongBtn.onclick = openAddSongModal;
    elements.addSongModal.querySelector('.feature-modal-close').onclick = () => closeModal(elements.addSongModal);
    elements.musicFileInput.onchange = handleMusicFileSelect;
    elements.songCoverInput.onchange = handleCoverFileSelect;
    elements.saveNewSongBtn.onclick = saveNewSong;
    elements.playPauseBtn.onclick = togglePlayPause;
    elements.nextSongBtn.onclick = nextSong;
    elements.prevSongBtn.onclick = prevSong;
            // 播放列表弹窗的交互 (V2 - 支持删除)
    elements.playlistModalOverlay.addEventListener('click', (e) => {
        const deleteBtn = e.target.closest('.playlist-delete-btn');
        const songItem = e.target.closest('li');

        if (deleteBtn) {
            // 如果点击的是删除按钮
            const index = parseInt(deleteBtn.dataset.index);
            handleDeleteSong(index);
        } else if (songItem && songItem.dataset.index) {
            // 如果点击的是歌曲本身（且不是删除按钮）
            playSongFromPlaylist(e);
        } else if (e.target.closest('#playlist-modal-close-btn') || e.target.id === 'playlist-modal-overlay') {
            // 如果点击的是关闭按钮或遮罩层
            closePlaylistModal();
        }
    });
    audioPlayer.addEventListener('ended', () => {
    const character = getCurrentCharacter();
    // 如果没有角色或播放列表为空，就什么也不做
    if (!character || !character.playlist || character.playlist.length === 0) {
        return;
    }

    // 【核心修复】在这里增加智能判断！
    if (character.playlist.length > 1) {
        // 如果歌单里不止一首歌，就正常播放下一首
        nextSong();
    } else {
        // 如果只有一首歌，就让它从头再来！
        audioPlayer.currentTime = 0; // 把进度条拉回开头
        audioPlayer.play(); // 播放！
    }
});
    // 新增的LRC和ZIP事件监听
    elements.importLrcBtn.onclick = () => elements.lrcFileInput.click();
        elements.lrcFileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                // 核心修复：直接将原始文本放入输入框，保留时间戳
                elements.newSongLyrics.value = event.target.result;
            };
            reader.readAsText(file);
        }
    };
    elements.importZipBtn.onclick = () => elements.zipFileInput.click();
    elements.zipFileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) handleZipImport(file);
    };
};
      
    // 新增：“一起听歌”背景更换的事件监听
    getEl('listen-along-bg-input').onchange = (e) => {
        const character = getCurrentCharacter();
        if (!character) return;
        handleFileUpload(e.target.files[0], (dataUrl) => {
            character.userProfile.listenAlongBg = dataUrl;
            saveAllData();
            // 实时更新背景
            getEl('listen-together-content').style.backgroundImage = `url(${dataUrl})`;
            getEl('listen-together-content').style.backgroundSize = 'cover';
        }, { compress: true, quality: 0.8, maxWidth: 800, maxHeight: 800 });
    };
      
const updatePresetsFromUI = () => {
    const presetItems = document.querySelectorAll('.preset-item');
    if (presetItems.length === 0 && globalPresets.length > 0) { globalPresets = []; return; }
    const updatedPresets = [];
    presetItems.forEach(itemEl => {
        const id = itemEl.dataset.id;
        const nameInput = itemEl.querySelector('.preset-name-input');
        const contentInput = itemEl.querySelector('.preset-content-input');
        const enabledToggle = itemEl.querySelector('.preset-enabled-toggle');
        if (id && nameInput && contentInput && enabledToggle) {
            updatedPresets.push({ id: id, name: nameInput.value, content: contentInput.value, enabled: enabledToggle.checked });
        }
    });
    globalPresets = updatedPresets;
};
      
    const renderPresets = () => {
        elements.presetListContainer.innerHTML = '';
        if (globalPresets.length === 0) {
            elements.presetListContainer.innerHTML = '<p style="text-align:center; color:#999;">还没有预设条目，点击下方按钮添加一个吧！</p>';
        } else {
            globalPresets.forEach(preset => {
                const presetEl = document.createElement('div');
                presetEl.className = 'preset-item';
                presetEl.dataset.id = preset.id;
                presetEl.innerHTML = `
                    <div class="preset-header">
                        <div class="form-group"><input type="text" class="preset-name-input" placeholder="给这个预设起个名" value="${preset.name || ''}"></div>
                        <div class="preset-actions">
                            <label class="preset-toggle"><input type="checkbox" class="preset-enabled-toggle" ${preset.enabled ? 'checked' : ''}><span class="slider"></span></label>
                            <button class="preset-delete-btn">删除</button>
                        </div>
                    </div>
                    <div class="form-group"><textarea class="preset-content-input" rows="3" placeholder="在此输入预设的提示词内容">${preset.content || ''}</textarea></div>`;
                elements.presetListContainer.appendChild(presetEl);
            });
        }
    };
    const setupPresetEventListeners = () => {
        elements.addPresetBtn.onclick = () => { updatePresetsFromUI(); const newPreset = { id: generateId('preset'), name: '', content: '', enabled: true }; globalPresets.push(newPreset); renderPresets(); };
        elements.presetListContainer.addEventListener('click', (e) => { if (e.target.classList.contains('preset-delete-btn')) { const item = e.target.closest('.preset-item'); if (item && confirm('确定要删除这个预设条目吗？')) { globalPresets = globalPresets.filter(p => p.id !== item.dataset.id); renderPresets(); } } });
        const updateSliderValue = (slider, valueEl) => { valueEl.textContent = slider.value; };
        elements.temperatureSlider.addEventListener('input', () => updateSliderValue(elements.temperatureSlider, elements.temperatureValue));
        elements.topPSlider.addEventListener('input', () => updateSliderValue(elements.topPSlider, elements.topPValue));
    };

        // --- Initialization ---
        loadAllData();
        setupEventListeners();
      elements.globalThemeSelect.addEventListener('change', (e) => applyGlobalTheme(e.target.value));
        setupPresetEventListeners();
        autoResizeTextarea();
    });
    </script>
</body>
</html>